{
  "api/MindControl.Anchors.ByteArrayMemoryAdapter.html": {
    "href": "api/MindControl.Anchors.ByteArrayMemoryAdapter.html",
    "title": "Class ByteArrayMemoryAdapter | MindControl",
    "summary": "Class ByteArrayMemoryAdapter Namespace MindControl.Anchors Assembly MindControl.dll Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes a byte array from and to memory using an address resolver and a size. public class ByteArrayMemoryAdapter : IMemoryAdapter<byte[]> Inheritance object ByteArrayMemoryAdapter Implements IMemoryAdapter<byte[]> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ByteArrayMemoryAdapter(IAddressResolver, int) Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes a byte array from and to memory using an address resolver and a size. public ByteArrayMemoryAdapter(IAddressResolver addressResolver, int size) Parameters addressResolver IAddressResolver Resolver that provides the address of the array in memory. size int Size of the byte array to read and write. Methods Read(ProcessMemory) Reads the value in the memory of the target process. public Result<byte[]> Read(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<byte[]> A result holding either the value read from memory, or a failure. Write(ProcessMemory, byte[]) Writes the value to the memory of the target process. public Result Write(ProcessMemory processMemory, byte[] value) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. value byte[] Value to write to memory. Returns Result A result indicating success or failure."
  },
  "api/MindControl.Anchors.FreezeFailureEventArgs.html": {
    "href": "api/MindControl.Anchors.FreezeFailureEventArgs.html",
    "title": "Class FreezeFailureEventArgs | MindControl",
    "summary": "Class FreezeFailureEventArgs Namespace MindControl.Anchors Assembly MindControl.dll Event arguments used when a freeze operation fails. public class FreezeFailureEventArgs : EventArgs Inheritance object EventArgs FreezeFailureEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FreezeFailureEventArgs(Failure) Event arguments used when a freeze operation fails. public FreezeFailureEventArgs(Failure failure) Parameters failure Failure Failure that occurred when trying to freeze the value. Properties Failure Gets the failure that occurred when trying to freeze the value. public Failure Failure { get; } Property Value Failure"
  },
  "api/MindControl.Anchors.GenericMemoryAdapter-1.html": {
    "href": "api/MindControl.Anchors.GenericMemoryAdapter-1.html",
    "title": "Class GenericMemoryAdapter<TValue> | MindControl",
    "summary": "Class GenericMemoryAdapter<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes any value type from and to memory using an address resolver. public class GenericMemoryAdapter<TValue> : IMemoryAdapter<TValue> where TValue : struct Type Parameters TValue Type of the value to read and write. Inheritance object GenericMemoryAdapter<TValue> Implements IMemoryAdapter<TValue> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GenericMemoryAdapter(IAddressResolver) Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes any value type from and to memory using an address resolver. public GenericMemoryAdapter(IAddressResolver addressResolver) Parameters addressResolver IAddressResolver Resolver that provides the address of the value in memory. Methods Read(ProcessMemory) Reads the value in the memory of the target process. public Result<TValue> Read(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<TValue> A result holding either the value read from memory, or a failure. Write(ProcessMemory, TValue) Writes the value to the memory of the target process. public Result Write(ProcessMemory processMemory, TValue value) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. value TValue Value to write to memory. Returns Result A result indicating success or failure."
  },
  "api/MindControl.Anchors.IMemoryAdapter-1.html": {
    "href": "api/MindControl.Anchors.IMemoryAdapter-1.html",
    "title": "Interface IMemoryAdapter<TValue> | MindControl",
    "summary": "Interface IMemoryAdapter<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Represents an adapter for reading and writing a value from and to memory. public interface IMemoryAdapter<TValue> Type Parameters TValue Type of the value to read and write. Methods Read(ProcessMemory) Reads the value in the memory of the target process. Result<TValue> Read(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<TValue> A result holding either the value read from memory, or a failure. Write(ProcessMemory, TValue) Writes the value to the memory of the target process. Result Write(ProcessMemory processMemory, TValue value) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. value TValue Value to write to memory. Returns Result A result indicating success or failure."
  },
  "api/MindControl.Anchors.StringPointerMemoryAdapter.html": {
    "href": "api/MindControl.Anchors.StringPointerMemoryAdapter.html",
    "title": "Class StringPointerMemoryAdapter | MindControl",
    "summary": "Class StringPointerMemoryAdapter Namespace MindControl.Anchors Assembly MindControl.dll Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes a string from and to memory using an address resolver and the string settings. public class StringPointerMemoryAdapter : IMemoryAdapter<string> Inheritance object StringPointerMemoryAdapter Implements IMemoryAdapter<string> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StringPointerMemoryAdapter(IAddressResolver, StringSettings) Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes a string from and to memory using an address resolver and the string settings. public StringPointerMemoryAdapter(IAddressResolver addressResolver, StringSettings stringSettings) Parameters addressResolver IAddressResolver Resolver that provides the address of the string in memory. stringSettings StringSettings Settings that define how the string is read and written. Methods Read(ProcessMemory) Reads the value in the memory of the target process. public Result<string> Read(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<string> A result holding either the value read from memory, or a failure. Write(ProcessMemory, string) Writes the value to the memory of the target process. public Result Write(ProcessMemory processMemory, string value) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. value string Value to write to memory. Returns Result A result indicating success or failure."
  },
  "api/MindControl.Anchors.ThreadValueFreezer-1.html": {
    "href": "api/MindControl.Anchors.ThreadValueFreezer-1.html",
    "title": "Class ThreadValueFreezer<TValue> | MindControl",
    "summary": "Class ThreadValueFreezer<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Provides methods to freeze a value in memory, using a thread that constantly writes the value. public class ThreadValueFreezer<TValue> : IDisposable Type Parameters TValue Type of the value to freeze. Inheritance object ThreadValueFreezer<TValue> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ThreadValueFreezer(ValueAnchor<TValue>, TValue) Freezes a value in memory, using a thread that constantly writes the target value. public ThreadValueFreezer(ValueAnchor<TValue> anchor, TValue value) Parameters anchor ValueAnchor<TValue> Anchor holding the memory value to freeze. value TValue Value to freeze in memory. Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) Disposes the timer and unsubscribes from the tick event. protected virtual void Dispose(bool disposing) Parameters disposing bool Whether the object is being disposed. Events FreezeFailed Event raised when a freeze operation fails. public event EventHandler<FreezeFailureEventArgs>? FreezeFailed Event Type EventHandler<FreezeFailureEventArgs>"
  },
  "api/MindControl.Anchors.TimerValueFreezer-1.html": {
    "href": "api/MindControl.Anchors.TimerValueFreezer-1.html",
    "title": "Class TimerValueFreezer<TValue> | MindControl",
    "summary": "Class TimerValueFreezer<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Provides methods to freeze a value in memory, using a timer to write the value at regular intervals. public class TimerValueFreezer<TValue> : IDisposable Type Parameters TValue Inheritance object TimerValueFreezer<TValue> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TimerValueFreezer(ValueAnchor<TValue>, TValue, TimeSpan) Freezes a value in memory, using a timer to write the value at regular intervals. public TimerValueFreezer(ValueAnchor<TValue> anchor, TValue value, TimeSpan timerInterval) Parameters anchor ValueAnchor<TValue> Anchor holding the memory value to freeze. value TValue Value to freeze in memory. timerInterval TimeSpan Interval at which the value should be written to memory. Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) Disposes the timer and unsubscribes from the tick event. protected virtual void Dispose(bool disposing) Parameters disposing bool Whether the object is being disposed. Events FreezeFailed Event raised when a freeze operation fails. public event EventHandler<FreezeFailureEventArgs>? FreezeFailed Event Type EventHandler<FreezeFailureEventArgs>"
  },
  "api/MindControl.Anchors.ValueAnchor-1.html": {
    "href": "api/MindControl.Anchors.ValueAnchor-1.html",
    "title": "Class ValueAnchor<TValue> | MindControl",
    "summary": "Class ValueAnchor<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Provides methods to manipulate and track a specific value in memory. public class ValueAnchor<TValue> Type Parameters TValue Type of the value to read and write. Inheritance object ValueAnchor<TValue> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueAnchor(IMemoryAdapter<TValue>, ProcessMemory) Provides methods to manipulate and track a specific value in memory. public ValueAnchor(IMemoryAdapter<TValue> memoryAdapter, ProcessMemory processMemory) Parameters memoryAdapter IMemoryAdapter<TValue> Adapter that reads and writes the value from and to memory. processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Methods Freeze(TValue) Freezes the memory area that the anchor is attached to, constantly overwriting its value, until the resulting instance is disposed. public TimerValueFreezer<TValue> Freeze(TValue value) Parameters value TValue Returns TimerValueFreezer<TValue> A TimerValueFreezer<TValue> instance that can be disposed to stop freezing the value, and provides a subscribable event raised when a recurrent write operation fails. Read() Reads the value in the memory of the target process. public Result<TValue> Read() Returns Result<TValue> A result holding either the value read from memory, or a failure. Watch(int) Provides a ValueWatcher<TValue> instance that periodically reads the value from the anchor and raises events when the value changes, until it is disposed. public ValueWatcher<TValue> Watch(int updatesPerSecond) Parameters updatesPerSecond int Target number of reads per second of the watcher. Returns ValueWatcher<TValue> A ValueWatcher<TValue> instance that periodically reads the value from the anchor and raises events when the value changes, until it is disposed. Watch(TimeSpan) Provides a ValueWatcher<TValue> instance that periodically reads the value from the anchor and raises events when the value changes, until it is disposed. public ValueWatcher<TValue> Watch(TimeSpan refreshInterval) Parameters refreshInterval TimeSpan Target time interval between each read operation in the watcher. Returns ValueWatcher<TValue> A ValueWatcher<TValue> instance that periodically reads the value from the anchor and raises events when the value changes, until it is disposed. Write(TValue) Writes the value to the memory of the target process. public Result Write(TValue value) Parameters value TValue Value to write to memory. Returns Result A result indicating success or failure."
  },
  "api/MindControl.Anchors.ValueChangedEventArgs-1.html": {
    "href": "api/MindControl.Anchors.ValueChangedEventArgs-1.html",
    "title": "Class ValueChangedEventArgs<TValue> | MindControl",
    "summary": "Class ValueChangedEventArgs<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Event arguments used when a value observed by a ValueWatcher<TValue> changes. public class ValueChangedEventArgs<TValue> : EventArgs Type Parameters TValue Type of the value that changed. Inheritance object EventArgs ValueChangedEventArgs<TValue> Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueChangedEventArgs(TValue?, TValue) Event arguments used when a value observed by a ValueWatcher<TValue> changes. public ValueChangedEventArgs(TValue? previousValue, TValue newValue) Parameters previousValue TValue Last known value before the change. newValue TValue New value freshly read after the change. Properties NewValue Gets the new value freshly read after the change. public TValue NewValue { get; } Property Value TValue PreviousValue Gets the last known value before the change. public TValue? PreviousValue { get; } Property Value TValue"
  },
  "api/MindControl.Anchors.ValueLostEventArgs-1.html": {
    "href": "api/MindControl.Anchors.ValueLostEventArgs-1.html",
    "title": "Class ValueLostEventArgs<TValue> | MindControl",
    "summary": "Class ValueLostEventArgs<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Event arguments used when a value observed by a ValueWatcher<TValue> becomes unreadable (causes a read failure). This may happen when the target process frees or rearranges its memory, or when the related ProcessMemory instance is detached. public class ValueLostEventArgs<TValue> : EventArgs Type Parameters TValue Inheritance object EventArgs ValueLostEventArgs<TValue> Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueLostEventArgs(TValue) Event arguments used when a value observed by a ValueWatcher<TValue> becomes unreadable (causes a read failure). This may happen when the target process frees or rearranges its memory, or when the related ProcessMemory instance is detached. public ValueLostEventArgs(TValue lastKnownValue) Parameters lastKnownValue TValue Last value read before a read error occurred. Properties LastKnownValue Gets the last value read before a read error occurred. public TValue LastKnownValue { get; } Property Value TValue"
  },
  "api/MindControl.Anchors.ValueReacquiredEventArgs-1.html": {
    "href": "api/MindControl.Anchors.ValueReacquiredEventArgs-1.html",
    "title": "Class ValueReacquiredEventArgs<TValue> | MindControl",
    "summary": "Class ValueReacquiredEventArgs<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Event arguments used when a value observed by a ValueWatcher<TValue> is successfully read after being lost. public class ValueReacquiredEventArgs<TValue> : EventArgs Type Parameters TValue Type of the value that was reacquired. Inheritance object EventArgs ValueReacquiredEventArgs<TValue> Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueReacquiredEventArgs(TValue) Event arguments used when a value observed by a ValueWatcher<TValue> is successfully read after being lost. public ValueReacquiredEventArgs(TValue newValue) Parameters newValue TValue New value freshly read. Properties NewValue Gets the new value freshly read. public TValue NewValue { get; } Property Value TValue"
  },
  "api/MindControl.Anchors.ValueWatcher-1.html": {
    "href": "api/MindControl.Anchors.ValueWatcher-1.html",
    "title": "Class ValueWatcher<TValue> | MindControl",
    "summary": "Class ValueWatcher<TValue> Namespace MindControl.Anchors Assembly MindControl.dll Uses a timer to periodically read a value from a given anchor and raise events when the value changes. public class ValueWatcher<TValue> : IDisposable Type Parameters TValue Type of the value held by the anchor. Inheritance object ValueWatcher<TValue> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueWatcher(ValueAnchor<TValue>, TimeSpan) Uses a timer to periodically read a value from a given anchor and raise events when the value changes. public ValueWatcher(ValueAnchor<TValue> anchor, TimeSpan refreshInterval) Parameters anchor ValueAnchor<TValue> The anchor holding the value to watch. refreshInterval TimeSpan Target time interval between each read operation. Properties IsValueReadable Gets a value indicating whether the last read operation was successful. public bool IsValueReadable { get; } Property Value bool LastChangeTime Gets the last time the value either changed, was lost, or reacquired after a loss. public DateTime LastChangeTime { get; } Property Value DateTime LastKnownValue Gets the last value read by the watcher. This value is updated every time the watcher successfully reads a new value. Even if the value is lost, this property will still hold the last successfully read value. If the value was never read successfully, this property will hold the default value of TValue. public TValue? LastKnownValue { get; } Property Value TValue Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() UpdateState() Reads the value from the anchor and raises events when the value changes. This method is called automatically by the timer, but can also be called manually to force a read. public void UpdateState() Events ValueChanged Event raised when the value observed by the watcher changes. public event EventHandler<ValueChangedEventArgs<TValue>>? ValueChanged Event Type EventHandler<ValueChangedEventArgs<TValue>> ValueLost Event raised when the value observed by the watcher becomes unreadable (causes a read failure). This may happen when the target process frees or rearranges its memory, or when the related ProcessMemory instance is detached. public event EventHandler<ValueLostEventArgs<TValue>>? ValueLost Event Type EventHandler<ValueLostEventArgs<TValue>> ValueReacquired Event raised when the value observed by the watcher is successfully read after being lost. public event EventHandler<ValueReacquiredEventArgs<TValue>>? ValueReacquired Event Type EventHandler<ValueReacquiredEventArgs<TValue>>"
  },
  "api/MindControl.Anchors.html": {
    "href": "api/MindControl.Anchors.html",
    "title": "Namespace MindControl.Anchors | MindControl",
    "summary": "Namespace MindControl.Anchors Classes ByteArrayMemoryAdapter Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes a byte array from and to memory using an address resolver and a size. FreezeFailureEventArgs Event arguments used when a freeze operation fails. GenericMemoryAdapter<TValue> Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes any value type from and to memory using an address resolver. StringPointerMemoryAdapter Represents an adapter for reading and writing a value from and to memory. This implementation reads and writes a string from and to memory using an address resolver and the string settings. ThreadValueFreezer<TValue> Provides methods to freeze a value in memory, using a thread that constantly writes the value. TimerValueFreezer<TValue> Provides methods to freeze a value in memory, using a timer to write the value at regular intervals. ValueAnchor<TValue> Provides methods to manipulate and track a specific value in memory. ValueChangedEventArgs<TValue> Event arguments used when a value observed by a ValueWatcher<TValue> changes. ValueLostEventArgs<TValue> Event arguments used when a value observed by a ValueWatcher<TValue> becomes unreadable (causes a read failure). This may happen when the target process frees or rearranges its memory, or when the related ProcessMemory instance is detached. ValueReacquiredEventArgs<TValue> Event arguments used when a value observed by a ValueWatcher<TValue> is successfully read after being lost. ValueWatcher<TValue> Uses a timer to periodically read a value from a given anchor and raise events when the value changes. Interfaces IMemoryAdapter<TValue> Represents an adapter for reading and writing a value from and to memory."
  },
  "api/MindControl.AssemblerExtensions.html": {
    "href": "api/MindControl.AssemblerExtensions.html",
    "title": "Class AssemblerExtensions | MindControl",
    "summary": "Class AssemblerExtensions Namespace MindControl Assembly MindControl.Code.dll Provides extension methods around code assembling. public static class AssemblerExtensions Inheritance object AssemblerExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AssembleToBytes(Assembler, ulong, int) Attempts to assemble the instructions registered on this assembler instance and return the resulting bytes. public static Result<byte[]> AssembleToBytes(this Assembler assembler, ulong baseAddress = 0, int bufferSize = 128) Parameters assembler Assembler Assembler instance to use to generate the instructions. baseAddress ulong Base address to use for the assembled instructions. Default is 0. bufferSize int Size of the buffer to use for the assembled instructions. Default is 128 bytes. Returns Result<byte[]> A result holding either the assembled instructions as a byte array, or a failure. RestoreFpuStack(Assembler) Restores the FPU stack state as a whole (pops all 8 ST registers from the stack). This cannot be done individually because ST registers are part of a stack and thus save and restore operations must be performed coordinatedly. public static void RestoreFpuStack(this Assembler assembler) Parameters assembler Assembler Assembler instance to use to generate the instructions. RestoreRegister(Assembler, Register) Restores the given register from the stack (pop it from the stack using instructions that depend on the register and bitness). public static void RestoreRegister(this Assembler assembler, Register register) Parameters assembler Assembler Assembler instance to use to generate the instructions. register Register Register to restore. SaveFpuStack(Assembler) Saves the FPU stack state as a whole (pushes all 8 ST registers to the stack). This cannot be done individually because ST registers are part of a stack and thus save and restore operations must be performed coordinatedly. public static void SaveFpuStack(this Assembler assembler) Parameters assembler Assembler Assembler instance to use to generate the instructions. SaveRegister(Assembler, Register) Saves the given register to the stack (push it on the stack using instructions that depend on the register and bitness). public static void SaveRegister(this Assembler assembler, Register register) Parameters assembler Assembler Assembler instance to use to generate the instructions. register Register Register to save. Exceptions ArgumentException Thrown if the register is not supported."
  },
  "api/MindControl.ByteSearchPattern.html": {
    "href": "api/MindControl.ByteSearchPattern.html",
    "title": "Class ByteSearchPattern | MindControl",
    "summary": "Class ByteSearchPattern Namespace MindControl Assembly MindControl.dll Represents a pattern of bytes to search for in memory. public class ByteSearchPattern Inheritance object ByteSearchPattern Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ByteSearchPattern(string) Creates a new instance of ByteSearchPattern from a pattern string. Prefer TryParse(string) for better error handling in cases where your pattern may be invalid. public ByteSearchPattern(string patternString) Parameters patternString string String representation of the byte pattern to find. This pattern should be a series of hexadecimal bytes, optionally separated by spaces. Each character, excluding spaces, can be a specific value (0-F) or a wildcard \"?\" character, indicating that the value to look for at this position could be any value. An example would be \"1F ?? 4B 00 ?6\". Read the documentation for more information. Exceptions ArgumentException Thrown when the pattern string is invalid. ByteSearchPattern(string, byte[], byte[]) Creates a new instance of ByteSearchPattern from a byte array and a mask array. protected ByteSearchPattern(string originalPatternString, byte[] byteArray, byte[] mask) Parameters originalPatternString string Original pattern string that was parsed into byte arrays. byteArray byte[] Byte array part of the pattern. mask byte[] Byte mask part of the pattern. Properties ByteArray Gets the byte array part of the pattern. public byte[] ByteArray { get; } Property Value byte[] Mask Gets the byte mask part of the pattern. public byte[] Mask { get; } Property Value byte[] Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. TryParse(string) Attempts to parse a pattern string into a ByteSearchPattern instance. public static Result<ByteSearchPattern> TryParse(string patternString) Parameters patternString string String representation of the byte pattern to find. This pattern should be a series of hexadecimal bytes, optionally separated by spaces. Each character, excluding spaces, can be a specific value (0-F) or a wildcard \"?\" character, indicating that the value to look for at this position could be any value. An example would be \"1F ?? 4B 00 ?6\". Read the documentation for more information. Returns Result<ByteSearchPattern> A result holding either the parsed ByteSearchPattern, or a failure. Operators implicit operator ByteSearchPattern(string) Implicitly converts a string to a ByteSearchPattern. public static implicit operator ByteSearchPattern(string patternString) Parameters patternString string Pattern string to convert. Returns ByteSearchPattern A new instance of ByteSearchPattern created from the given pattern string. Exceptions ArgumentException Thrown when the pattern string is invalid."
  },
  "api/MindControl.Code.CodeChange.html": {
    "href": "api/MindControl.Code.CodeChange.html",
    "title": "Class CodeChange | MindControl",
    "summary": "Class CodeChange Namespace MindControl.Code Assembly MindControl.Code.dll Represents a modification to a code section in the memory of a process. Allows reverting the alteration by writing the original bytes back to the code section. public class CodeChange Inheritance object CodeChange Derived CodeHook Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Address Gets the address of the first byte of the modified code section. public nuint Address { get; } Property Value nuint Length Gets the length in bytes of the modified code section. public int Length { get; } Property Value int Methods Revert() Reverts the code alteration, writing the original bytes back to the code section. public Result Revert() Returns Result A result indicating either a success or a failure."
  },
  "api/MindControl.Code.ProcessMemoryCodeExtensions.html": {
    "href": "api/MindControl.Code.ProcessMemoryCodeExtensions.html",
    "title": "Class ProcessMemoryCodeExtensions | MindControl",
    "summary": "Class ProcessMemoryCodeExtensions Namespace MindControl.Code Assembly MindControl.Code.dll Provides extension methods for ProcessMemory related to executable memory. public static class ProcessMemoryCodeExtensions Inheritance object ProcessMemoryCodeExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DisableCodeAt(ProcessMemory, PointerPath, int) Replaces the instruction (or multiple consecutive instructions) referenced by the given pointer path with NOP instructions that do nothing, effectively disabling the original code. public static Result<CodeChange> DisableCodeAt(this ProcessMemory processMemory, PointerPath pointerPath, int instructionCount = 1) Parameters processMemory ProcessMemory Process memory instance to use. pointerPath PointerPath Path to the address of the first instruction to replace. instructionCount int Number of consecutive instructions to replace. Default is 1. Returns Result<CodeChange> A result holding either a code change instance, allowing you to revert modifications, or a failure. DisableCodeAt(ProcessMemory, nuint, int) Replaces the instruction (or multiple consecutive instructions) at the given address with NOP instructions that do nothing, effectively disabling the original code. public static Result<CodeChange> DisableCodeAt(this ProcessMemory processMemory, nuint address, int instructionCount = 1) Parameters processMemory ProcessMemory Process memory instance to use. address nuint Address of the first instruction to replace. instructionCount int Number of consecutive instructions to replace. Default is 1. Returns Result<CodeChange> A result holding either a code change instance, allowing you to revert modifications, or a failure. StoreCode(ProcessMemory, Assembler, nuint?) Assembles and stores the instructions registered in the given assembler as executable code in the process memory. If needed, memory is allocated to store the data. Returns the reservation that holds the data. public static Result<MemoryReservation> StoreCode(this ProcessMemory processMemory, Assembler assembler, nuint? nearAddress = null) Parameters processMemory ProcessMemory Process memory instance to use. assembler Assembler Assembler holding the instructions to store. nearAddress nuint? Returns Result<MemoryReservation> A result holding either the reservation where the code has been written, or a failure."
  },
  "api/MindControl.Code.html": {
    "href": "api/MindControl.Code.html",
    "title": "Namespace MindControl.Code | MindControl",
    "summary": "Namespace MindControl.Code Classes CodeChange Represents a modification to a code section in the memory of a process. Allows reverting the alteration by writing the original bytes back to the code section. ProcessMemoryCodeExtensions Provides extension methods for ProcessMemory related to executable memory."
  },
  "api/MindControl.FindBytesSettings.html": {
    "href": "api/MindControl.FindBytesSettings.html",
    "title": "Class FindBytesSettings | MindControl",
    "summary": "Class FindBytesSettings Namespace MindControl Assembly MindControl.dll Settings for the FindBytes method. public class FindBytesSettings Inheritance object FindBytesSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties MaxResultCount Gets or sets the maximum number of results to return. If null (default), all results will be returned. public int? MaxResultCount { get; set; } Property Value int? SearchExecutable Gets or sets a value indicating if the search should scan executable memory. If null (default), the search will scan both executable and non-executable memory. Set this to true to search for code. public bool? SearchExecutable { get; set; } Property Value bool? SearchMapped Gets or sets a value indicating if the search should include mapped memory. If null (default), the search will scan both mapped and non-mapped memory. public bool? SearchMapped { get; set; } Property Value bool? SearchReadable Gets or sets a value indicating if the search should scan readable memory. If null (default), the search will scan both readable and non-readable memory. public bool? SearchReadable { get; set; } Property Value bool? SearchWritable Gets or sets a value indicating if the search should scan writable memory. If null (default), the search will scan both writable and non-writable memory. Set this to true to search for data. public bool? SearchWritable { get; set; } Property Value bool? Methods Validate() Throws an exception if the settings are invalid. public void Validate()"
  },
  "api/MindControl.Hooks.CodeHook.html": {
    "href": "api/MindControl.Hooks.CodeHook.html",
    "title": "Class CodeHook | MindControl",
    "summary": "Class CodeHook Namespace MindControl.Hooks Assembly MindControl.Code.dll Represents a modification to a code section in the memory of a process. The modification is a hook, which replaces code instructions with a jump to a block of injected code. Allows reverting the jump by writing the original instructions back to the code section. Reverting does not remove the injected code, but will remove the entry point to the code. public class CodeHook : CodeChange Inheritance object CodeChange CodeHook Inherited Members CodeChange.Address CodeChange.Length CodeChange.Revert() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InjectedCodeReservation Gets the reservation holding the injected code. public MemoryReservation InjectedCodeReservation { get; } Property Value MemoryReservation"
  },
  "api/MindControl.Hooks.HookExecutionMode.html": {
    "href": "api/MindControl.Hooks.HookExecutionMode.html",
    "title": "Enum HookExecutionMode | MindControl",
    "summary": "Enum HookExecutionMode Namespace MindControl.Hooks Assembly MindControl.Code.dll Defines how the injected code is executed in relation to the original code. public enum HookExecutionMode Fields ExecuteInjectedCodeFirst = 0 Executes the injected code before the original target instruction. ExecuteOriginalInstructionFirst = 1 Executes the original target instruction first, and then the injected code. If additional instructions are overwritten by the hook jump, they will be executed after the injected code. ReplaceOriginalInstruction = 2 Executes only the injected code, overwriting the instruction at the hook address. If additional instructions are overwritten by the hook jump, they will be executed after the injected code."
  },
  "api/MindControl.Hooks.HookJumpMode.html": {
    "href": "api/MindControl.Hooks.HookJumpMode.html",
    "title": "Enum HookJumpMode | MindControl",
    "summary": "Enum HookJumpMode Namespace MindControl.Hooks Assembly MindControl.Code.dll Defines how the hook jump should be performed. public enum HookJumpMode Fields NearJumpOnly = 1 Use a near jump only. If a near jump is not possible, the hook operation will fail. Use this only if hook performance is critical and a far jump would not be acceptable. For 32-bit processes, this mode is equivalent to NearJumpWithFallbackOnFarJump, as near jumps are always possible. NearJumpWithFallbackOnFarJump = 0 Use a near jump if possible. If a near jump is not possible, fall back to a far jump. This is the safest option, as it will always work, but may not always give you the best performance (although it should in most cases). For 32-bit processes, this mode is equivalent to NearJumpOnly, as near jumps are always possible."
  },
  "api/MindControl.Hooks.HookOptions.html": {
    "href": "api/MindControl.Hooks.HookOptions.html",
    "title": "Class HookOptions | MindControl",
    "summary": "Class HookOptions Namespace MindControl.Hooks Assembly MindControl.Code.dll Holds settings for a hook operation. public class HookOptions Inheritance object HookOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HookOptions(HookExecutionMode, HookJumpMode, params HookRegister[]) Initializes a new instance of the HookOptions class with the given values. public HookOptions(HookExecutionMode executionMode, HookJumpMode jumpMode, params HookRegister[] registersToPreserve) Parameters executionMode HookExecutionMode Execution mode of the injected code in relation to the original code. Defines whether the original code should be overwritten, executed before, or executed after the injected code. jumpMode HookJumpMode Jump mode, which defines what kind of jump should be used to redirect the code flow to the injected code. Use NearJumpWithFallbackOnFarJump, unless performance is critical and a far jump would be unacceptable. registersToPreserve HookRegister[] Optional registers to save before the injected code is executed, and restore after it is executed. Use this to isolate the injected code from the original code, to prevent it from affecting the original code behavior or causing crashes. HookOptions(HookExecutionMode, params HookRegister[]) Initializes a new instance of the HookOptions class with the given values. public HookOptions(HookExecutionMode executionMode, params HookRegister[] registersToPreserve) Parameters executionMode HookExecutionMode Execution mode of the injected code in relation to the original code. Defines whether the original code should be overwritten, executed before, or executed after the injected code. registersToPreserve HookRegister[] Optional registers to save before the injected code is executed, and restore after it is executed. Use this to isolate the injected code from the original code, to prevent it from affecting the original code's behavior or causing crashes. Properties ExecutionMode Gets the execution mode of the injected code in relation to the original code. Defines whether the original code should be overwritten, executed before, or executed after the injected code. public HookExecutionMode ExecutionMode { get; init; } Property Value HookExecutionMode JumpMode Gets the jump mode, which defines what kind of jump should be used to redirect the code flow to the injected code. Most of the time, you should leave it to its default NearJumpWithFallbackOnFarJump value. public HookJumpMode JumpMode { get; init; } Property Value HookJumpMode RegistersToPreserve Gets a collection of registers that should be saved before the injected code is executed, and restored after it is executed. This is used to isolate the injected code from the original code, to prevent it from affecting the original code's behavior or causing crashes. public HookRegister[] RegistersToPreserve { get; init; } Property Value HookRegister[]"
  },
  "api/MindControl.Hooks.HookRegister.html": {
    "href": "api/MindControl.Hooks.HookRegister.html",
    "title": "Enum HookRegister | MindControl",
    "summary": "Enum HookRegister Namespace MindControl.Hooks Assembly MindControl.Code.dll Registers or register groups that can be saved and restored in hooks. public enum HookRegister Fields Flags = 0 Represents the RFLAGS (in 64-bit) or EFLAGS (in 32-bit) register, holding CPU flags. FpuStack = 41 Represents all ST registers (ST0-ST7). Since they work as a stack, the whole stack is saved and restored coordinatedly. These registers are not normally used. They are shared with the MMX registers (MM0-MM7). Do not use both at the same time. Mm0 = 33 Represents the MM0 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm1 = 34 Represents the MM1 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm2 = 35 Represents the MM2 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm3 = 36 Represents the MM3 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm4 = 37 Represents the MM4 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm5 = 38 Represents the MM5 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm6 = 39 Represents the MM6 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. Mm7 = 40 Represents the MM7 register. This register is not normally used. It is shared with the FPU stack. Do not use both at the same time. R10 = 11 Represents the R10 register (64-bit only). R11 = 12 Represents the R11 register (64-bit only). R12 = 13 Represents the R12 register (64-bit only). R13 = 14 Represents the R13 register (64-bit only). R14 = 15 Represents the R14 register (64-bit only). R15 = 16 Represents the R15 register (64-bit only). R8 = 9 Represents the R8 register (64-bit only). R9 = 10 Represents the R9 register (64-bit only). RaxEax = 1 Represents the RAX (in 64-bit) or EAX (in 32-bit) register. RbpEbp = 7 Represents the RBP (in 64-bit) or EBP (in 32-bit) register. RbxEbx = 2 Represents the RBX (in 64-bit) or EBX (in 32-bit) register. RcxEcx = 3 Represents the RCX (in 64-bit) or ECX (in 32-bit) register. RdiEdi = 6 Represents the RDI (in 64-bit) or EDI (in 32-bit) register. RdxEdx = 4 Represents the RDX (in 64-bit) or EDX (in 32-bit) register. RsiEsi = 5 Represents the RSI (in 64-bit) or ESI (in 32-bit) register. RspEsp = 8 Represents the RSP (in 64-bit) or ESP (in 32-bit) register. Xmm0 = 17 Represents the XMM0 register. Xmm1 = 18 Represents the XMM1 register. Xmm10 = 27 Represents the XMM10 register (64-bit only). Xmm11 = 28 Represents the XMM11 register (64-bit only). Xmm12 = 29 Represents the XMM12 register (64-bit only). Xmm13 = 30 Represents the XMM13 register (64-bit only). Xmm14 = 31 Represents the XMM14 register (64-bit only). Xmm15 = 32 Represents the XMM15 register (64-bit only). Xmm2 = 19 Represents the XMM2 register. Xmm3 = 20 Represents the XMM3 register. Xmm4 = 21 Represents the XMM4 register. Xmm5 = 22 Represents the XMM5 register. Xmm6 = 23 Represents the XMM6 register. Xmm7 = 24 Represents the XMM7 register. Xmm8 = 25 Represents the XMM8 register (64-bit only). Xmm9 = 26 Represents the XMM9 register (64-bit only)."
  },
  "api/MindControl.Hooks.HookRegisters.html": {
    "href": "api/MindControl.Hooks.HookRegisters.html",
    "title": "Class HookRegisters | MindControl",
    "summary": "Class HookRegisters Namespace MindControl.Hooks Assembly MindControl.Code.dll Provides preset collections of registers for hooks. public static class HookRegisters Inheritance object HookRegisters Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields AllCommonRegisters Use this collection to preserve all commonly used registers. Works for both 32-bit and 64-bit processes (incompatible registers are filtered out). This collection includes all general-purpose registers and XMM registers. This is a good choice if you want to isolate the injected code from the original code, and are not sure which registers the injected code will use (e.g. when calling an injected DLL function). public static readonly HookRegister[] AllCommonRegisters Field Value HookRegister[] GeneralPurposeRegisters Use this collection to preserve flags and general-purpose registers. Works for both 32-bit and 64-bit processes (incompatible registers are filtered out). This collection includes RFLAGS/EFLAGS, RAX/EAX, RBX/EBX, RCX/ECX, RDX/EDX, RSI/ESI, RDI/EDI, RBP/EBP, RSP/ESP, and R8-R15 for 64-bit processes. It does not include the XMM registers commonly used for floating-point operations. public static readonly HookRegister[] GeneralPurposeRegisters Field Value HookRegister[] MmRegisters Use this collection to preserve MMX registers. Works for both 32-bit and 64-bit processes. This collection includes all MM registers, from MM0 to MM7. These registers are not normally used. They are shared with the FPU stack. Do not use both at the same time. public static readonly HookRegister[] MmRegisters Field Value HookRegister[] XmmRegisters Use this collection to preserve XMM registers. Works for both 32-bit and 64-bit processes (incompatible registers are filtered out). This collection includes all XMM registers, from XMM0 to XMM15 (XMM8 to XMM15 are only available in 64-bit processes). public static readonly HookRegister[] XmmRegisters Field Value HookRegister[]"
  },
  "api/MindControl.Hooks.ProcessMemoryHookExtensions.html": {
    "href": "api/MindControl.Hooks.ProcessMemoryHookExtensions.html",
    "title": "Class ProcessMemoryHookExtensions | MindControl",
    "summary": "Class ProcessMemoryHookExtensions Namespace MindControl.Hooks Assembly MindControl.Code.dll Provides extension methods for ProcessMemory related to code hooks. public static class ProcessMemoryHookExtensions Inheritance object ProcessMemoryHookExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Hook(ProcessMemory, PointerPath, Assembler, HookOptions) Injects code into the target process to be executed when the instruction at the executable address pointed by the given pointer path is reached. Depending on the options, the injected code may replace the original target instruction, or get executed either before or after it. If specified, additional instructions that save and restore registers will be added to the injected code. Execution of the original code will then continue normally (unless the provided code is designed otherwise). This signature uses an assembler, which is recommended, especially if your code contains instructions with relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to the intended locations. public static Result<CodeHook> Hook(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, Assembler codeAssembler, HookOptions options) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionPointerPath PointerPath Pointer path to the first byte of the instruction to hook into. codeAssembler Assembler Code assembler loaded with instructions to inject into the target process. The jump back to the original code will be appended automatically, so it is not necessary to include it. options HookOptions Options defining how the hook works. Returns Result<CodeHook> A result holding either a code hook instance that contains a reference to the injected code reservation and allows you to revert the hook, or a failure. Hook(ProcessMemory, PointerPath, byte[], HookOptions) Injects code into the target process to be executed when the instruction at the executable address pointed by the given pointer path is reached. Depending on the options, the injected code may replace the original target instruction, or get executed either before or after it. If specified, additional instructions that save and restore registers will be added to the injected code. Execution of the original code will then continue normally (unless the provided code is designed otherwise). This signature uses a byte array containing the code to inject. If your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the Hook(ProcessMemory, nuint, Assembler, HookOptions) signature. public static Result<CodeHook> Hook(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, byte[] code, HookOptions options) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionPointerPath PointerPath Pointer path to the first byte of the instruction to hook into. code byte[] Assembled code to inject into the target process. The jump back to the original code will be appended automatically, so it is not necessary to include it. Warning: if your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the Hook(ProcessMemory, PointerPath, Assembler, HookOptions) signature. options HookOptions Options defining how the hook works. Returns Result<CodeHook> A result holding either a code hook instance that contains a reference to the injected code reservation and allows you to revert the hook, or a failure. Hook(ProcessMemory, nuint, Assembler, HookOptions) Injects code into the target process to be executed when the instruction at the given executable address is reached. Depending on the options, the injected code may replace the original target instruction, or get executed either before or after it. If specified, additional instructions that save and restore registers will be added to the injected code. Execution of the original code will then continue normally (unless the provided code is designed otherwise). This signature uses an assembler, which is recommended, especially if your code contains instructions with relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to the intended locations. public static Result<CodeHook> Hook(this ProcessMemory processMemory, nuint targetInstructionAddress, Assembler codeAssembler, HookOptions options) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionAddress nuint Address of the first byte of the instruction to hook into. codeAssembler Assembler Code assembler loaded with instructions to inject into the target process. The jump back to the original code will be appended automatically, so it is not necessary to include it. options HookOptions Options defining how the hook works. Returns Result<CodeHook> A result holding either a code hook instance that contains a reference to the injected code reservation and allows you to revert the hook, or a failure. Hook(ProcessMemory, nuint, byte[], HookOptions) Injects code into the target process to be executed when the instruction at the given executable address is reached. Depending on the options, the injected code may replace the original target instruction, or get executed either before or after it. If specified, additional instructions that save and restore registers will be added to the injected code. Execution of the original code will then continue normally (unless the provided code is designed otherwise). This signature uses a byte array containing the code to inject. If your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the Hook(ProcessMemory, nuint, Assembler, HookOptions) signature. public static Result<CodeHook> Hook(this ProcessMemory processMemory, nuint targetInstructionAddress, byte[] code, HookOptions options) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionAddress nuint Address of the first byte of the instruction to hook into. code byte[] Assembled code to inject into the target process. The jump back to the original code will be appended automatically, so it is not necessary to include it. Warning: if your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the Hook(ProcessMemory, nuint, Assembler, HookOptions) signature. options HookOptions Options defining how the hook works. Returns Result<CodeHook> A result holding either a code hook instance that contains a reference to the injected code reservation and allows you to revert the hook, or a failure. InsertCodeAt(ProcessMemory, PointerPath, Assembler, params HookRegister[]) Injects code in the process to be executed right before the instruction pointed by the given pointer path, by performing a hook. This signature uses an assembler, which is recommended, especially if your code contains instructions with relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to the intended locations. public static Result<CodeHook> InsertCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, Assembler codeAssembler, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionPointerPath PointerPath Pointer path to the first byte of the target instruction. The injected code will be executed just before the instruction. codeAssembler Assembler Code assembler loaded with instructions to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeHook> A result holding either a code hook instance that contains the memory reservation holding the injected code and also allows you to revert the operation, or a failure. Remarks This method is essentially a shortcut for Hook(ProcessMemory, PointerPath, Assembler, HookOptions) with the execution mode set to ExecuteInjectedCodeFirst. It is provided for convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to achieve the same result. InsertCodeAt(ProcessMemory, PointerPath, byte[], params HookRegister[]) Injects code in the process to be executed right before the instruction pointed by the given pointer path, by performing a hook. This signature uses a byte array containing the code to inject. If your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[]) signature. public static Result<CodeHook> InsertCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, byte[] code, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionPointerPath PointerPath Pointer path to the first byte of the target instruction. The injected code will be executed just before the instruction. code byte[] Assembled code to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeHook> A result holding either a code hook instance that contains the memory reservation holding the injected code and also allows you to revert the operation, or a failure. Remarks This method is essentially a shortcut for Hook(ProcessMemory, PointerPath, byte[], HookOptions) with the execution mode set to ExecuteInjectedCodeFirst. It is provided for convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to achieve the same result. InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[]) Injects code in the process to be executed right before the instruction at the given address, by performing a hook. This signature uses an assembler, which is recommended, especially if your code contains instructions with relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to the intended locations. public static Result<CodeHook> InsertCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, Assembler codeAssembler, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionAddress nuint Address of the first byte of the target instruction. The injected code will be executed just before the instruction. codeAssembler Assembler Code assembler loaded with instructions to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeHook> A result holding either a code hook instance that contains the memory reservation holding the injected code and also allows you to revert the operation, or a failure. Remarks This method is essentially a shortcut for Hook(ProcessMemory, nuint, Assembler, HookOptions) with the execution mode set to ExecuteInjectedCodeFirst. It is provided for convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to achieve the same result. InsertCodeAt(ProcessMemory, nuint, byte[], params HookRegister[]) Injects code in the process to be executed right before the instruction at the given address, by performing a hook. This signature uses a byte array containing the code to inject. If your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[]) signature. public static Result<CodeHook> InsertCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, byte[] code, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionAddress nuint Address of the first byte of the target instruction. The injected code will be executed just before the instruction. code byte[] Assembled code to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeHook> A result holding either a code hook instance that contains the memory reservation holding the injected code and also allows you to revert the operation, or a failure. Remarks This method is essentially a shortcut for Hook(ProcessMemory, nuint, byte[], HookOptions) with the execution mode set to ExecuteInjectedCodeFirst. It is provided for convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to achieve the same result. ReplaceCodeAt(ProcessMemory, PointerPath, int, Assembler, params HookRegister[]) Replaces the instruction or instructions pointed by the given pointer path with the provided code. If the injected code does not fit in the space occupied by the original instructions, a hook will be performed so that the injected code can still be executed instead of the original instructions. This signature uses an assembler, which is recommended, especially if your code contains instructions with relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to the intended locations. public static Result<CodeChange> ReplaceCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, int instructionCount, Assembler codeAssembler, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionPointerPath PointerPath Pointer path to the first byte of the first instruction to replace. instructionCount int Number of consecutive instructions to replace. codeAssembler Assembler Code assembler loaded with instructions to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeChange> A result holding either a code change instance that allows you to revert the operation, or a failure. If the operation performed a hook, the result will be a CodeHook that also contains the reservation holding the injected code. ReplaceCodeAt(ProcessMemory, PointerPath, int, byte[], params HookRegister[]) Replaces the instruction or instructions at the address pointed by the given path with the provided code. If the injected code does not fit in the space occupied by the original instructions, a hook will be performed so that the injected code can still be executed instead of the original instructions. This signature uses a byte array containing the code to inject. If your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the ReplaceCodeAt(ProcessMemory, PointerPath, int, Assembler, params HookRegister[]) signature. public static Result<CodeChange> ReplaceCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, int instructionCount, byte[] code, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionPointerPath PointerPath Pointer path to the first byte of the first instruction to replace. instructionCount int Number of consecutive instructions to replace. code byte[] Assembled code to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeChange> A result holding either a code change instance that allows you to revert the operation, or a failure. If the operation performed a hook, the result will be a CodeHook that also contains the reservation holding the injected code. ReplaceCodeAt(ProcessMemory, nuint, int, Assembler, params HookRegister[]) Replaces the instruction or instructions at the given address with the provided code. If the injected code does not fit in the space occupied by the original instructions, a hook will be performed so that the injected code can still be executed instead of the original instructions. This signature uses an assembler, which is recommended, especially if your code contains instructions with relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to the intended locations. public static Result<CodeChange> ReplaceCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, int instructionCount, Assembler codeAssembler, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionAddress nuint Address of the first byte of the first instruction to replace. instructionCount int Number of consecutive instructions to replace. codeAssembler Assembler Code assembler loaded with instructions to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeChange> A result holding either a code change instance that allows you to revert the operation, or a failure. If the operation performed a hook, the result will be a CodeHook that also contains the reservation holding the injected code. ReplaceCodeAt(ProcessMemory, nuint, int, byte[], params HookRegister[]) Replaces the instruction or instructions at the given address with the provided code. If the injected code does not fit in the space occupied by the original instructions, a hook will be performed so that the injected code can still be executed instead of the original instructions. This signature uses a byte array containing the code to inject. If your code contains instructions with relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the ReplaceCodeAt(ProcessMemory, nuint, int, Assembler, params HookRegister[]) signature. public static Result<CodeChange> ReplaceCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, int instructionCount, byte[] code, params HookRegister[] registersToPreserve) Parameters processMemory ProcessMemory Process memory instance to use. targetInstructionAddress nuint Address of the first byte of the first instruction to replace. instructionCount int Number of consecutive instructions to replace. code byte[] Assembled code to inject into the target process. registersToPreserve HookRegister[] Optionally provided registers to be saved and restored around the injected code. This allows the injected code to modify registers without affecting the original code, which could otherwise lead to crashes or unexpected behavior. Returns Result<CodeChange> A result holding either a code change instance that allows you to revert the operation, or a failure. If the operation performed a hook, the result will be a CodeHook that also contains the reservation holding the injected code."
  },
  "api/MindControl.Hooks.html": {
    "href": "api/MindControl.Hooks.html",
    "title": "Namespace MindControl.Hooks | MindControl",
    "summary": "Namespace MindControl.Hooks Classes CodeHook Represents a modification to a code section in the memory of a process. The modification is a hook, which replaces code instructions with a jump to a block of injected code. Allows reverting the jump by writing the original instructions back to the code section. Reverting does not remove the injected code, but will remove the entry point to the code. HookOptions Holds settings for a hook operation. HookRegisters Provides preset collections of registers for hooks. ProcessMemoryHookExtensions Provides extension methods for ProcessMemory related to code hooks. Enums HookExecutionMode Defines how the injected code is executed in relation to the original code. HookJumpMode Defines how the hook jump should be performed. HookRegister Registers or register groups that can be saved and restored in hooks."
  },
  "api/MindControl.IAddressResolver.html": {
    "href": "api/MindControl.IAddressResolver.html",
    "title": "Interface IAddressResolver | MindControl",
    "summary": "Interface IAddressResolver Namespace MindControl Assembly MindControl.dll Provides a way to resolve an address in the target process. public interface IAddressResolver Methods ResolveFor(ProcessMemory) Resolves the address in the target process using the given ProcessMemory instance. Result<nuint> ResolveFor(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<nuint> A result holding either the resolved address, or a failure."
  },
  "api/MindControl.LiteralAddressResolver.html": {
    "href": "api/MindControl.LiteralAddressResolver.html",
    "title": "Class LiteralAddressResolver | MindControl",
    "summary": "Class LiteralAddressResolver Namespace MindControl Assembly MindControl.dll Provides a way to resolve an address in the target process. This implementation takes a literal address and always resolves to that same address. public class LiteralAddressResolver : IAddressResolver Inheritance object LiteralAddressResolver Implements IAddressResolver Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LiteralAddressResolver(nuint) Provides a way to resolve an address in the target process. This implementation takes a literal address and always resolves to that same address. public LiteralAddressResolver(nuint address) Parameters address nuint Literal address to return in ResolveFor(ProcessMemory). Properties Address Gets the literal address to return in ResolveFor(ProcessMemory). public nuint Address { get; } Property Value nuint Methods ResolveFor(ProcessMemory) Resolves the address in the target process using the given ProcessMemory instance. public Result<nuint> ResolveFor(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<nuint> A result holding either the resolved address, or a failure expressed as a string."
  },
  "api/MindControl.MemoryAllocation.html": {
    "href": "api/MindControl.MemoryAllocation.html",
    "title": "Class MemoryAllocation | MindControl",
    "summary": "Class MemoryAllocation Namespace MindControl Assembly MindControl.dll Represents a range of memory that has been allocated in a process. Can be used to safely manage data or code storage using reservations. public class MemoryAllocation : IDisposable Inheritance object MemoryAllocation Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsDisposed Gets a boolean indicating if this instance has been disposed. If True, the instance is no longer usable. public bool IsDisposed { get; } Property Value bool IsExecutable Gets a value indicating if the memory range has been allocated with executable permissions. public bool IsExecutable { get; } Property Value bool Range Gets the memory range allocated. public MemoryRange Range { get; } Property Value MemoryRange Reservations Gets the reservations managed by this allocation. public IReadOnlyList<MemoryReservation> Reservations { get; } Property Value IReadOnlyList<MemoryReservation> Methods ClearReservations() Removes all reservations from the range, meaning the whole allocated range will be available for reservations. public void ClearReservations() Dispose() Releases all reservations, and frees up the allocated space. After this method is called, this instance will be made unusable, and you may no longer be able to read or write memory in this range. public void Dispose() FreeRange(MemoryRange) Makes reserved space overlapping the specified range available for future reservations. Affected reservations will be disposed, and may be either completely gone, reduced, or split into two ranges. Consider disposing reservations instead, unless you want more control over the range to free. public void FreeRange(MemoryRange rangeToFree) Parameters rangeToFree MemoryRange The range of memory to free from reservations in this instance. GetLargestReservableSpace() Gets the largest contiguous, unreserved space in the range. This is the largest space that can be reserved in a single allocation. public MemoryRange? GetLargestReservableSpace() Returns MemoryRange? The largest contiguous, unreserved space in the range. GetNextRangeFittingSize(ulong, uint?) Gets the first free range that can fit the specified size, with an optional alignment. Returns null if no range is large enough to fit the requested size with the specified alignment. Note that this method does not reserve the range. Most of the time, you should use ReserveRange(ulong, uint?) instead of this method. public MemoryRange? GetNextRangeFittingSize(ulong size, uint? byteAlignment = 8) Parameters size ulong Requested size of the range to find, in bytes. byteAlignment uint? Optional byte alignment for the range. When null, values are not aligned. The default value is 8, meaning that for example a range of [0x15,0x3C] will be aligned to [0x18,0x38] and thus only accomodate 32 bytes. Alignment means the resulting range might be bigger than the size, but will never make it smaller. An alignment of 4 or 8 usually provide better performance when reading or writing memory. Returns MemoryRange? The first free range that can fit the specified size, or null if no range is large enough. GetRemainingSpace() Gets the total space available for reservation in the range, in bytes. Note that space might be fragmented and thus unavailable for a single reservation. Use GetNextRangeFittingSize(ulong, uint?) if you want to make sure your data fits in the range. public ulong GetRemainingSpace() Returns ulong The total space available for reservation in the range. GetTotalReservedSpace() Gets the total space reserved in the allocated range, in bytes. public ulong GetTotalReservedSpace() Returns ulong The total space reserved in the allocated range, in bytes. ReserveRange(ulong, uint?) Reserves and returns the next available range with the specified size. Data stored in the returned range will not be overwritten by future reservations until the reservation is freed. public Result<MemoryReservation> ReserveRange(ulong size, uint? byteAlignment = 8) Parameters size ulong Minimal size that the range to get must be able to accomodate, in bytes. byteAlignment uint? Optional byte alignment for the range. When null, values are not aligned. The default value is 8, meaning that for example a range of [0x15,0x3C] will be aligned to [0x18,0x38] and thus only accomodate 32 bytes. Alignment means the actual reserved space might be bigger than the size, but will never make it smaller. Returns Result<MemoryReservation> A result holding the resulting reservation or a reservation failure."
  },
  "api/MindControl.MemoryProtectionStrategy.html": {
    "href": "api/MindControl.MemoryProtectionStrategy.html",
    "title": "Enum MemoryProtectionStrategy | MindControl",
    "summary": "Enum MemoryProtectionStrategy Namespace MindControl Assembly MindControl.dll Enumerates potential strategies to deal with memory protection. public enum MemoryProtectionStrategy Fields Ignore = 0 Attempt to perform an operation without dealing with memory protection. Use this strategy if you care about performance and know that the memory area you target is not protected. Remove = 1 Remove any memory protection on the target memory region before attempting a memory operation. RemoveAndRestore = 2 Remove any memory protection on the target memory region before attempting a memory operation, and then restore it to its previous state after the operation is done. This strategy is the safest but slowest choice."
  },
  "api/MindControl.MemoryRange.html": {
    "href": "api/MindControl.MemoryRange.html",
    "title": "Struct MemoryRange | MindControl",
    "summary": "Struct MemoryRange Namespace MindControl Assembly MindControl.dll Represents a range of memory addresses in a process. public readonly record struct MemoryRange : IEquatable<MemoryRange> Implements IEquatable<MemoryRange> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors MemoryRange(nuint, nuint) Builds a MemoryRange. public MemoryRange(nuint Start, nuint End) Parameters Start nuint Start address of the range. End nuint End address of the range. Fields Full32BitRange Instance representing the full 32-bit address space. public static readonly MemoryRange Full32BitRange Field Value MemoryRange Remarks There is no 64-bit equivalent because, if the system is 32-bit, such a range cannot be represented. Properties End End address of the range. public nuint End { get; init; } Property Value nuint Start Start address of the range. public nuint Start { get; init; } Property Value nuint Methods AlignedTo(uint, RangeAlignmentMode) Returns a subset of this range, aligned to the specified byte alignment. For example, a range of [2,9] aligned to 4 bytes will result in [4,8]. public MemoryRange? AlignedTo(uint alignment, RangeAlignmentMode alignmentMode = RangeAlignmentMode.AlignBlock) Parameters alignment uint Alignment in bytes. Usually 4 for 32-bit processes, or 8 for 64-bit processes. An alignment of 4 or 8 usually provide better performance when reading or writing memory. alignmentMode RangeAlignmentMode Alignment mode. Defines how the range should be aligned. Defaults to AlignBlock. Returns MemoryRange? The aligned memory range. The returned range is always a subset of the range, or the range itself. If the aligned memory range cannot fit in the original range, returns null. Contains(MemoryRange) Determines if the specified range is entirely contained within this range. public bool Contains(MemoryRange range) Parameters range MemoryRange Range to check. Returns bool True if the range is entirely contained within this range, false otherwise. Contains(nuint) Determines if the specified address is within the memory range. public bool Contains(nuint address) Parameters address nuint Address to check. Returns bool True if the address is within the memory range, false otherwise. Deconstruct(out nuint, out nuint) Deconstructs the memory range into its start and end addresses. public void Deconstruct(out nuint start, out nuint end) Parameters start nuint Start address of the range. end nuint End address of the range. DistanceTo(nuint) Determines the shortest distance between the specified address and any address within the range. public ulong DistanceTo(nuint address) Parameters address nuint Target address. Returns ulong The distance between the address and the range. Exclude(MemoryRange) Returns the result of excluding the given range from this range. This can be seen as an XOR operation between the two ranges. This will result in no range when this range is entirely contained within the given range, two ranges when the given range is in the middle of this range, or in other cases a single range that will be reduced by the overlapping part (if any). public IEnumerable<MemoryRange> Exclude(MemoryRange rangeToExclude) Parameters rangeToExclude MemoryRange The range to subtract from this range. Returns IEnumerable<MemoryRange> The resulting ranges. The resulting collection may be empty. FromStartAndSize(nuint, ulong) Creates a new memory range from a start address and a size. public static MemoryRange FromStartAndSize(nuint start, ulong size) Parameters start nuint Start address of the range. size ulong Size of the range in bytes. Returns MemoryRange GetSize() Returns the size of the memory range. public ulong GetSize() Returns ulong Intersect(MemoryRange) Obtains the intersection of this range with the given range, which is the range that is common to both. public MemoryRange? Intersect(MemoryRange otherRange) Parameters otherRange MemoryRange The range to intersect with. Returns MemoryRange? The intersection of the two ranges, or null if there is no intersection. Overlaps(MemoryRange) Determines if the specified range overlaps with this range. public bool Overlaps(MemoryRange range) Parameters range MemoryRange Range to check. Returns bool True if the range overlaps with this range, false otherwise. ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/MindControl.MemoryReservation.html": {
    "href": "api/MindControl.MemoryReservation.html",
    "title": "Class MemoryReservation | MindControl",
    "summary": "Class MemoryReservation Namespace MindControl Assembly MindControl.dll Represents a reservation of a range of memory within a MemoryAllocation. Reservations within an allocation cannot overlap and thus can be used to safely manage data or code storage over a process. Disposing a reservation will free the memory range for other uses. public class MemoryReservation : IDisposable Inheritance object MemoryReservation Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Address Gets the starting address of the reservation. public nuint Address { get; } Property Value nuint IsDisposed Gets a boolean indicating if the reservation has been disposed. public bool IsDisposed { get; } Property Value bool ParentAllocation Gets the allocation that handles this reservation. public MemoryAllocation ParentAllocation { get; } Property Value MemoryAllocation Range Gets the memory range of this reservation. public MemoryRange Range { get; } Property Value MemoryRange Size Gets the size of the reservation in bytes. This is a shortcut for calling GetSize() on the Range. public ulong Size { get; } Property Value ulong Methods Dispose() Releases this reservation, allowing the parent MemoryAllocation to reuse the space for other data. public void Dispose() Shrink(ulong) Shrinks the reservation by the given number of bytes. public void Shrink(ulong difference) Parameters difference ulong Number of bytes to remove from the reservation. Exceptions ArgumentException Thrown when the difference is equal to or greater than the size of the reservation."
  },
  "api/MindControl.Modules.RemoteModule.html": {
    "href": "api/MindControl.Modules.RemoteModule.html",
    "title": "Class RemoteModule | MindControl",
    "summary": "Class RemoteModule Namespace MindControl.Modules Assembly MindControl.dll Represents a module loaded into another process. public class RemoteModule Inheritance object RemoteModule Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetManagedModule() Gets the managed module instance. public ProcessModule GetManagedModule() Returns ProcessModule The managed module instance. GetRange() Gets the range of memory occupied by the module. public MemoryRange GetRange() Returns MemoryRange The memory range of the module. ReadExportTable() Attempts to read the export table of the module, associating the names of the exported functions with their absolute addresses in the process memory. This is useful to locate specific functions in a DLL, like Windows API functions from kernel32.dll or user32.dll, or your own functions in a DLL you have injected into the process. public Result<Dictionary<string, nuint>> ReadExportTable() Returns Result<Dictionary<string, nuint>> A result holding either a dictionary containing the names and addresses of the exported functions, or an error message in case the export table could not be read."
  },
  "api/MindControl.Modules.html": {
    "href": "api/MindControl.Modules.html",
    "title": "Namespace MindControl.Modules | MindControl",
    "summary": "Namespace MindControl.Modules Classes RemoteModule Represents a module loaded into another process."
  },
  "api/MindControl.Native.IOperatingSystemService.html": {
    "href": "api/MindControl.Native.IOperatingSystemService.html",
    "title": "Interface IOperatingSystemService | MindControl",
    "summary": "Interface IOperatingSystemService Namespace MindControl.Native Assembly MindControl.dll Provides process-related features. public interface IOperatingSystemService Methods AllocateMemory(nint, int, MemoryAllocationType, MemoryProtection) Allocates memory in the specified process. The address is determined automatically by the operating system. Result<nuint> AllocateMemory(nint processHandle, int size, MemoryAllocationType allocationType, MemoryProtection protection) Parameters processHandle nint Handle of the target process. size int Size in bytes of the memory to allocate. allocationType MemoryAllocationType Type of memory allocation. protection MemoryProtection Protection flags of the memory to allocate. Returns Result<nuint> A result holding either a pointer to the start of the allocated memory, or a system failure. AllocateMemory(nint, nuint, int, MemoryAllocationType, MemoryProtection) Allocates memory in the specified process at the specified address. Result<nuint> AllocateMemory(nint processHandle, nuint address, int size, MemoryAllocationType allocationType, MemoryProtection protection) Parameters processHandle nint Handle of the target process. address nuint Address where the memory will be allocated. size int Size in bytes of the memory to allocate. allocationType MemoryAllocationType Type of memory allocation. protection MemoryProtection Protection flags of the memory to allocate. Returns Result<nuint> A result holding either a pointer to the start of the allocated memory, or a system failure. CloseHandle(nint) Closes the given handle. Result CloseHandle(nint handle) Parameters handle nint Handle to close. Returns Result A result indicating either a success or a system failure. CreateRemoteThread(nint, nuint, nuint) Spawns a thread in the specified process, starting at the given address. Result<nint> CreateRemoteThread(nint processHandle, nuint startAddress, nuint parameterAddress) Parameters processHandle nint Handle of the target process. startAddress nuint Address of the start routine to be executed by the thread. parameterAddress nuint Address of any parameter to be passed to the start routine. Returns Result<nint> A result holding either the handle of the thread, or a system failure. GetFullMemoryRange(bool) Gets the range of memory addressable by applications of the given bitness in the current system. MemoryRange GetFullMemoryRange(bool is64Bit) Parameters is64Bit bool A boolean indicating if the target application is 64-bit or not. Returns MemoryRange GetPageSize() Gets the page size of the system. uint GetPageSize() Returns uint GetRegionMetadata(nint, nuint) Gets the metadata of a memory region in the virtual address space of a process. Result<MemoryRangeMetadata> GetRegionMetadata(nint processHandle, nuint baseAddress) Parameters processHandle nint Handle of the target process. baseAddress nuint Base address of the target memory region. Returns Result<MemoryRangeMetadata> A result holding either the metadata of the target memory region, or a system failure. IsProcess64Bit(int) Returns a value indicating if the process with the given identifier is a 64-bit process or not. Result<bool> IsProcess64Bit(int pid) Parameters pid int Identifier of the target process. Returns Result<bool> A result holding either a boolean indicating if the process is 64-bit, or a system failure. OpenProcess(int) Opens the process with the given identifier, in a way that allows memory manipulation. Result<nint> OpenProcess(int pid) Parameters pid int Identifier of the target process. Returns Result<nint> A result holding either the handle of the opened process, or a system failure. ReadAndOverwriteProtection(nint, bool, nuint, MemoryProtection) Overwrites the memory protection of the page that the given address is part of. Returns the memory protection that was effective on the page before being changed. Result<MemoryProtection> ReadAndOverwriteProtection(nint processHandle, bool is64Bit, nuint targetAddress, MemoryProtection newProtection) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_OPERATION access. is64Bit bool A boolean indicating if the target process is 64-bit or not. targetAddress nuint An address in the target page. newProtection MemoryProtection New protection value for the page. Returns Result<MemoryProtection> A result holding either the memory protection value that was effective on the page before being changed, or a system failure. Exceptions ArgumentException The process handle is invalid (zero pointer). ArgumentOutOfRangeException The target address is invalid (zero pointer). ReadProcessMemory(nint, nuint, ulong) Reads a targeted range of the memory of a specified process. Result<byte[]> ReadProcessMemory(nint processHandle, nuint baseAddress, ulong length) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_READ access. baseAddress nuint Starting address of the memory range to read. length ulong Length of the memory range to read. Returns Result<byte[]> A result holding either an array of bytes containing the data read from the process memory, or a system failure. ReadProcessMemoryPartial(nint, nuint, byte[], int, ulong) Reads a targeted range of the memory of a specified process into the given buffer. Supports partial reads, in case the full length failed to be read but at least one byte was successfully copied into the buffer. Prefer ReadProcessMemory(nint, nuint, ulong) when you know the length of the data to read. Result<ulong> ReadProcessMemoryPartial(nint processHandle, nuint baseAddress, byte[] buffer, int offset, ulong length) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_READ access. baseAddress nuint Starting address of the memory range to read. buffer byte[] Buffer to store the data read from the memory. The buffer must be large enough to store the data read. offset int Offset in the buffer where the data will be stored. length ulong Length of the memory range to read. Returns Result<ulong> A result holding either the number of bytes actually read from memory, or a system failure when no byte were successfully read. ReleaseMemory(nint, nuint) Frees the memory allocated in the specified process for a region or a placeholder. Result ReleaseMemory(nint processHandle, nuint regionBaseAddress) Parameters processHandle nint Handle of the target process. regionBaseAddress nuint Base address of the region or placeholder to free, as returned by the allocation methods. Returns Result A result indicating either a success or a system failure. WaitThread(nint, TimeSpan) Waits for the specified thread to finish execution and returns its exit code. Result<uint> WaitThread(nint threadHandle, TimeSpan timeout) Parameters threadHandle nint Handle of the target thread. timeout TimeSpan Maximum time to wait for the thread to finish. Returns Result<uint> A result holding either the exit code of the thread, or a thread failure when the operation failed. WriteProcessMemory(nint, nuint, Span<byte>) Writes the given bytes into the memory of the specified process, at the target address. Result WriteProcessMemory(nint processHandle, nuint targetAddress, Span<byte> value) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access. targetAddress nuint Base address in the memory of the process to which data will be written. value Span<byte> Bytes to write in the process memory. Returns Result A result indicating either a success or a system failure."
  },
  "api/MindControl.Native.MemoryAllocationType.html": {
    "href": "api/MindControl.Native.MemoryAllocationType.html",
    "title": "Enum MemoryAllocationType | MindControl",
    "summary": "Enum MemoryAllocationType Namespace MindControl.Native Assembly MindControl.dll Allocation types for memory allocation functions. [Flags] public enum MemoryAllocationType : uint Fields Commit = 4096 Allocates physical storage in memory or in the paging file on disk for the specified reserved memory pages. LargePages = 536870912 Allocates memory using large page support. Physical = 4194304 Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. Reserve = 8192 Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk. Reset = 524288 Indicates that data in the memory range is no longer of interest. ResetUndo = 16777216 Reverses the effects of Reset. TopDown = 1048576 Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations."
  },
  "api/MindControl.Native.MemoryFreeType.html": {
    "href": "api/MindControl.Native.MemoryFreeType.html",
    "title": "Enum MemoryFreeType | MindControl",
    "summary": "Enum MemoryFreeType Namespace MindControl.Native Assembly MindControl.dll Allocation types for memory freeing functions. [Flags] public enum MemoryFreeType : uint Fields Decommit = 16384 Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. Release = 32768 Releases the specified region of pages. After this operation, the pages are in the free state."
  },
  "api/MindControl.Native.MemoryProtection.html": {
    "href": "api/MindControl.Native.MemoryProtection.html",
    "title": "Enum MemoryProtection | MindControl",
    "summary": "Enum MemoryProtection Namespace MindControl.Native Assembly MindControl.dll Protection attributes attributed to a memory page. [Flags] public enum MemoryProtection : uint Fields Execute = 16 Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation. ExecuteRead = 32 Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. ExecuteReadWrite = 64 Enables execute, read-only, or read/write access to the committed region of pages. ExecuteWriteCopy = 128 Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as ExecuteReadWrite, and the change is written to the new page. NoAccess = 1 Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation. NoCache = 512 Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. This flag cannot be used with the PageGuard, NoAccess, or WriteCombine flags. PageGuard = 256 Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page exception occurs during a system service, the service typically returns a failure status indicator. This value cannot be used with NoAccess. ReadOnly = 2 Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation. ReadWrite = 4 Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation. WriteCombine = 1024 Sets all pages to be write-combined. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. This flag cannot be specified with the NoAccess, PageGuard, and NoCache flags. WriteCopy = 8 Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as ReadWrite, and the change is written to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation."
  },
  "api/MindControl.Native.MemoryRangeMetadata.html": {
    "href": "api/MindControl.Native.MemoryRangeMetadata.html",
    "title": "Struct MemoryRangeMetadata | MindControl",
    "summary": "Struct MemoryRangeMetadata Namespace MindControl.Native Assembly MindControl.dll Contains properties about a uniform range in the virtual address space of a process. public struct MemoryRangeMetadata Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties IsCommitted Gets a boolean indicating if the memory is committed. public bool IsCommitted { readonly get; init; } Property Value bool IsExecutable Gets a boolean indicating if the memory is executable. public bool IsExecutable { readonly get; init; } Property Value bool IsFree Gets a boolean indicating if the memory is free. public bool IsFree { readonly get; init; } Property Value bool IsMapped Gets a boolean indicating if the memory is mapped to a file. public bool IsMapped { readonly get; init; } Property Value bool IsProtected Gets a boolean indicating if the memory is guarded or marked for no access. public bool IsProtected { readonly get; init; } Property Value bool IsReadable Gets a boolean indicating if the memory is readable. public bool IsReadable { readonly get; init; } Property Value bool IsWritable Gets a boolean indicating if the memory is writable. public bool IsWritable { readonly get; init; } Property Value bool Size Gets the size of the range, in bytes. public nuint Size { readonly get; init; } Property Value nuint StartAddress Gets a pointer to the start address of the range. public nuint StartAddress { readonly get; init; } Property Value nuint Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/MindControl.Native.Win32Service.html": {
    "href": "api/MindControl.Native.Win32Service.html",
    "title": "Class Win32Service | MindControl",
    "summary": "Class Win32Service Namespace MindControl.Native Assembly MindControl.dll Contains DllImports for Windows functions required internally by other components. public class Win32Service : IOperatingSystemService Inheritance object Win32Service Implements IOperatingSystemService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AllocateMemory(nint, int, MemoryAllocationType, MemoryProtection) Allocates memory in the specified process. public Result<nuint> AllocateMemory(nint processHandle, int size, MemoryAllocationType allocationType, MemoryProtection protection) Parameters processHandle nint Handle of the target process. size int Size in bytes of the memory to allocate. allocationType MemoryAllocationType Type of memory allocation. protection MemoryProtection Protection flags of the memory to allocate. Returns Result<nuint> A result holding either a pointer to the start of the allocated memory, or a failure. AllocateMemory(nint, nuint, int, MemoryAllocationType, MemoryProtection) Allocates memory in the specified process at the specified address. public Result<nuint> AllocateMemory(nint processHandle, nuint address, int size, MemoryAllocationType allocationType, MemoryProtection protection) Parameters processHandle nint Handle of the target process. address nuint Address where the memory will be allocated. size int Size in bytes of the memory to allocate. allocationType MemoryAllocationType Type of memory allocation. protection MemoryProtection Protection flags of the memory to allocate. Returns Result<nuint> A result holding either a pointer to the start of the allocated memory, or a failure. CloseHandle(nint) Closes the given handle. public Result CloseHandle(nint handle) Parameters handle nint Handle to close. Returns Result A result indicating either a success or a system failure. CreateRemoteThread(nint, nuint, nuint) Spawns a thread in the specified process, starting at the given address. public Result<nint> CreateRemoteThread(nint processHandle, nuint startAddress, nuint parameterAddress) Parameters processHandle nint Handle of the target process. startAddress nuint Address of the start routine to be executed by the thread. parameterAddress nuint Address of any parameter to be passed to the start routine. Returns Result<nint> A result holding either the handle of the thread, or a system failure. GetFullMemoryRange(bool) Gets the range of memory addressable by applications in the current system. public MemoryRange GetFullMemoryRange(bool is64Bit) Parameters is64Bit bool A boolean indicating if the target application is 64-bit or not. Returns MemoryRange GetPageSize() Gets the page size of the system. public uint GetPageSize() Returns uint GetRegionMetadata(nint, nuint) Gets the metadata of a memory region in the virtual address space of a process. public Result<MemoryRangeMetadata> GetRegionMetadata(nint processHandle, nuint baseAddress) Parameters processHandle nint Handle of the target process. baseAddress nuint Base address of the target memory region. Returns Result<MemoryRangeMetadata> A result holding either the metadata of the target memory region, or a system failure. IsProcess64Bit(int) Returns a value indicating if the process with the given identifier is a 64-bit process or not. public Result<bool> IsProcess64Bit(int pid) Parameters pid int Identifier of the target process. Returns Result<bool> A result holding either a boolean indicating if the process is 64-bit, or a system failure. OpenProcess(int) Opens the process with the given identifier, in a way that allows memory manipulation. public Result<nint> OpenProcess(int pid) Parameters pid int Identifier of the target process. Returns Result<nint> A result holding either the handle of the opened process, or a system failure. ReadAndOverwriteProtection(nint, bool, nuint, MemoryProtection) Overwrites the memory protection of the page that the given address is part of. Returns the memory protection that was effective on the page before being changed. public Result<MemoryProtection> ReadAndOverwriteProtection(nint processHandle, bool is64Bit, nuint targetAddress, MemoryProtection newProtection) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_OPERATION access. is64Bit bool A boolean indicating if the target process is 64-bit or not. targetAddress nuint An address in the target page. newProtection MemoryProtection New protection value for the page. Returns Result<MemoryProtection> A result holding either the memory protection value that was effective on the page before being changed, or a failure. ReadProcessMemory(nint, nuint, ulong) Reads a targeted range of the memory of a specified process. public Result<byte[]> ReadProcessMemory(nint processHandle, nuint baseAddress, ulong length) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_READ access. baseAddress nuint Starting address of the memory range to read. length ulong Length of the memory range to read. Returns Result<byte[]> A result holding either an array of bytes containing the data read from the process memory, or a system failure. ReadProcessMemoryPartial(nint, nuint, byte[], int, ulong) Reads a targeted range of the memory of a specified process into the given buffer. Supports partial reads, in case the full length failed to be read but at least one byte was successfully copied into the buffer. Prefer ReadProcessMemory(nint, nuint, ulong) when you know the length of the data to read. public Result<ulong> ReadProcessMemoryPartial(nint processHandle, nuint baseAddress, byte[] buffer, int offset, ulong length) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_READ access. baseAddress nuint Starting address of the memory range to read. buffer byte[] Buffer to store the data read from the memory. The buffer must be large enough to store the data read. offset int Offset in the buffer where the data will be stored. length ulong Length of the memory range to read. Returns Result<ulong> A result holding either the number of bytes actually read from memory, or a system failure. ReleaseMemory(nint, nuint) Frees the memory allocated in the specified process for a region or a placeholder. public Result ReleaseMemory(nint processHandle, nuint regionBaseAddress) Parameters processHandle nint Handle of the target process. regionBaseAddress nuint Base address of the region or placeholder to free, as returned by the memory allocation methods. Returns Result A result indicating either a success or a system failure. VirtualProtectEx(nint, nuint, nint, MemoryProtection, out MemoryProtection) Changes the protection on a region of committed pages in the virtual address space of a specified process. public static extern bool VirtualProtectEx(nint hProcess, nuint lpAddress, nint dwSize, MemoryProtection flNewProtect, out MemoryProtection lpflOldProtect) Parameters hProcess nint A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION access right. lpAddress nuint A pointer to the base address of the region of pages whose access protection attributes are to be changed. dwSize nint The size of the region whose access protection attributes are changed, in bytes. flNewProtect MemoryProtection The memory protection option. This parameter can be one of the memory protection constants. lpflOldProtect MemoryProtection A pointer to a variable that receives the previous access protection of the first page in the specified region of pages. Returns bool If the function succeeds, the return value is true. Otherwise, it will be false. WaitThread(nint, TimeSpan) Waits for the specified thread to finish execution and returns its exit code. public Result<uint> WaitThread(nint threadHandle, TimeSpan timeout) Parameters threadHandle nint Handle of the target thread. timeout TimeSpan Maximum time to wait for the thread to finish. Returns Result<uint> A result holding either the exit code of the thread, or a failure. WriteProcessMemory(nint, nuint, ref byte, nuint, out nuint) Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails. public static extern bool WriteProcessMemory(nint hProcess, nuint lpBaseAddress, ref byte lpBuffer, nuint nSize, out nuint lpNumberOfBytesWritten) Parameters hProcess nint A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process. lpBaseAddress nuint A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails. lpBuffer byte A pointer to the buffer that contains data to be written in the address space of the specified process. nSize nuint The number of bytes to be written to the specified process. lpNumberOfBytesWritten nuint A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If null, it will be ignored. Returns bool If the function succeeds, the return value is true. Otherwise, it will be false. WriteProcessMemory(nint, nuint, Span<byte>) Writes the given bytes into the memory of the specified process, at the target address. public Result WriteProcessMemory(nint processHandle, nuint targetAddress, Span<byte> value) Parameters processHandle nint Handle of the target process. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access. targetAddress nuint Base address in the memory of the process to which data will be written. value Span<byte> Bytes to write in the process memory. Returns Result A result indicating either a success or a failure."
  },
  "api/MindControl.Native.html": {
    "href": "api/MindControl.Native.html",
    "title": "Namespace MindControl.Native | MindControl",
    "summary": "Namespace MindControl.Native Classes Win32Service Contains DllImports for Windows functions required internally by other components. Structs MemoryRangeMetadata Contains properties about a uniform range in the virtual address space of a process. Interfaces IOperatingSystemService Provides process-related features. Enums MemoryAllocationType Allocation types for memory allocation functions. MemoryFreeType Allocation types for memory freeing functions. MemoryProtection Protection attributes attributed to a memory page."
  },
  "api/MindControl.PointerExtensions.html": {
    "href": "api/MindControl.PointerExtensions.html",
    "title": "Class PointerExtensions | MindControl",
    "summary": "Class PointerExtensions Namespace MindControl Assembly MindControl.dll Provides extension methods for pointers. public static class PointerExtensions Inheritance object PointerExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DistanceTo(nuint, nuint) Determines the distance between two pointers, without wrap-around. public static ulong DistanceTo(this nuint a, nuint b) Parameters a nuint First pointer. b nuint Second pointer. Returns ulong The distance between the two pointers, without wrap-around. Remarks As remarked by the documentation, the distance provided does not wrap around, meaning that, for example, the distance between 0 and MaxValue is equal to MaxValue and not 1. GetRangeAround(nuint, ulong) Gets a range of memory around the given address, with the specified size and without wrap-around. public static MemoryRange GetRangeAround(this nuint address, ulong size) Parameters address nuint Target address. size ulong Size of the range. Note that the resulting range may be smaller if the address is near the beginning or end of the address space. Returns MemoryRange A memory range around the address, with the specified size and without wrap-around."
  },
  "api/MindControl.PointerOffset.html": {
    "href": "api/MindControl.PointerOffset.html",
    "title": "Struct PointerOffset | MindControl",
    "summary": "Struct PointerOffset Namespace MindControl Assembly MindControl.dll Describes a pointer offset as part of a PointerPath. Effectively, this is a number ranging from -0xFFFFFFFFFFFFFFFF to 0xFFFFFFFFFFFFFFFF. public readonly record struct PointerOffset : IEquatable<PointerOffset> Implements IEquatable<PointerOffset> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PointerOffset(ulong, bool) Describes a pointer offset as part of a PointerPath. Effectively, this is a number ranging from -0xFFFFFFFFFFFFFFFF to 0xFFFFFFFFFFFFFFFF. public PointerOffset(ulong Offset, bool IsNegative) Parameters Offset ulong Absolute value of the offset. IsNegative bool Sign of the offset. Fields Zero Represents a zero offset. public static readonly PointerOffset Zero Field Value PointerOffset Properties Is64Bit Gets a value indicating whether this offset is 64-bit. public bool Is64Bit { get; } Property Value bool IsNegative Sign of the offset. public bool IsNegative { get; init; } Property Value bool Offset Absolute value of the offset. public ulong Offset { get; init; } Property Value ulong Methods AsAddress() Returns the value of this offset as an address, or null if the offset is negative. public nuint? AsAddress() Returns nuint? The value of this offset as an address, or null if the offset is negative. OffsetAddress(nuint) Offsets the given address by this offset. public nuint? OffsetAddress(nuint address) Parameters address nuint Address to offset. Returns nuint? The offset address, or null if the result overflows or is negative. Plus(PointerOffset) Produces the result of the addition between this offset and the given offset. public PointerOffset? Plus(PointerOffset other) Parameters other PointerOffset Offset to add to this offset. Returns PointerOffset? The result of the addition, or null if the result overflows or underflows. Plus(ulong, bool) Produces the result of the addition between this offset and the given value. public PointerOffset? Plus(ulong value, bool isNegative) Parameters value ulong Value to add to this offset. isNegative bool Sign of the value to add. Returns PointerOffset? The result of the addition, or null if the result overflows or underflows. ShiftAndAdd(byte) Produces the result of the sum of the multiplication of the value of this offset by 16 and the given value. The resulting sign will always be the sign of this offset. This is useful when building up a pointer offset from a sequence of bytes. public PointerOffset? ShiftAndAdd(byte value) Parameters value byte Value to add to the result of the multiplication. Returns PointerOffset? The result of the multiplication and addition, or null if the result overflows or underflows. ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/MindControl.PointerPath.html": {
    "href": "api/MindControl.PointerPath.html",
    "title": "Class PointerPath | MindControl",
    "summary": "Class PointerPath Namespace MindControl Assembly MindControl.dll Holds a string expression consisting in a base address followed by a sequence of pointer offsets. Allows programs to consistently retrieve data in the process memory by following pointers to reach a dynamic address. A pointer path instance can be reused to optimize performance, as it is only parsed once, when constructed. public class PointerPath Inheritance object PointerPath Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors PointerPath(string) Builds a pointer path from the given expression. public PointerPath(string expression) Parameters expression string Pointer path expression. Some examples include \"myprocess.exe+001F468B,1B,0,A0\", or \"1F07A314\", or \"1F07A314+A0\", or \"1F07A314-A0,4\". Exceptions ArgumentException Thrown when the expression is not valid. PointerPath(string, nuint, params long[]) Builds a pointer path from a base module name, a base module offset, and a series of offsets. public PointerPath(string baseModuleName, nuint baseModuleOffset, params long[] pointerOffsets) Parameters baseModuleName string Name of the base module, where the starting pointer is found. For example, in \"mygame.exe+3FF0,4,1C\", this would be \"mygame.exe\" (without the quotes). baseModuleOffset nuint Offset applied to the base module to get the address of the first pointer to evaluate. For example, in \"mygame.exe+3FF0,4,1C\", this would be 0x3FF0. pointerOffsets long[] Collection of offsets to follow sequentially in order to evaluate the final memory address. For example, in \"mygame.exe+3FF0,4,1C\", this would be [0x4, 0x1C]. PointerPath(nuint, params long[]) Builds a pointer path from a pointer and a series of offsets. public PointerPath(nuint basePointerAddress, params long[] pointerOffsets) Parameters basePointerAddress nuint Address of the base pointer, which is the first address to evaluate. For example, in \"1F07A314,4,1C\", this would be 0x1F07A314. pointerOffsets long[] Collection of offsets to follow sequentially in order to evaluate the final memory address. For example, in \"1F07A314,4,1C\", this would be [0x4, 0x1C]. Properties BaseModuleName Gets the base module name. For example, for the expression \"myprocess.exe+01F4684-4,18+4,C\", gets \"myprocess.exe\". For expression with no module name, like \"01F4684-4,18\", gets a null value. public string? BaseModuleName { get; } Property Value string BaseModuleOffset Gets the offset of the base module name. For example, for the expression \"myprocess.exe+01F4684-4,18+4,C\", gets 0x1F4680. For expressions without a module offset, like \"01F4684-4,18\" or \"myprocess.exe\", gets 0. public PointerOffset BaseModuleOffset { get; } Property Value PointerOffset Expression Gets the pointer path expression. Some examples include \"myprocess.exe+001F468B,1B,0,A0\", or \"1F07A314\", or \"1F07A314+A0\", or \"1F07A314-A0,4\". public string Expression { get; } Property Value string IsStrictly64Bit Gets a boolean indicating if the path is a 64-bit only path, or if it can also be used in a 32-bit process. For example, for the expression \"app.dll+0000F04AA1218410\", this boolean would be True. For the expression \"app.dll+00000000F04AA121\", this boolean would be False. Note that evaluating a 32-bit-compatible address may still end up overflowing. public bool IsStrictly64Bit { get; } Property Value bool PointerOffsets Gets the collection of pointer offsets to follow sequentially in order to evaluate the memory address. For example, for the expression \"myprocess.exe+01F4684-4,18+4,C\", gets [0x1C, 0xC]. public PointerOffset[] PointerOffsets { get; } Property Value PointerOffset[] Methods IsValid(string, bool) Checks the given expression and returns a boolean indicating if it is valid or not. public static bool IsValid(string expression, bool allowOnly32Bit = false) Parameters expression string Expression to check. allowOnly32Bit bool If set to True, valid 64-bit expressions will still cause False to be returned. Returns bool True if the expression is valid. ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. TryParse(string, bool) Attempts to parse the given expression. Returns the resulting PointerPath instance if the expression was successfully parsed, or null if the expression is not valid. public static PointerPath? TryParse(string expression, bool allowOnly32Bit = false) Parameters expression string Expression to check. allowOnly32Bit bool If set to True, valid 64-bit expressions will still cause null to be returned. Returns PointerPath The resulting PointerPath instance if the expression was successfully parsed, or null if the expression is not valid. Operators implicit operator PointerPath(string) Implicitly converts the given string to a PointerPath instance using the constructor. public static implicit operator PointerPath(string s) Parameters s string String to convert. Returns PointerPath Pointer path instance built from the string."
  },
  "api/MindControl.PointerPathResolver.html": {
    "href": "api/MindControl.PointerPathResolver.html",
    "title": "Class PointerPathResolver | MindControl",
    "summary": "Class PointerPathResolver Namespace MindControl Assembly MindControl.dll Provides a way to resolve an address in the target process. This implementation takes a pointer path and resolves it to an address in the target process. public class PointerPathResolver : IAddressResolver Inheritance object PointerPathResolver Implements IAddressResolver Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PointerPathResolver(PointerPath) Provides a way to resolve an address in the target process. This implementation takes a pointer path and resolves it to an address in the target process. public PointerPathResolver(PointerPath pointerPath) Parameters pointerPath PointerPath Target pointer path. Properties PointerPath Gets the pointer path to resolve. public PointerPath PointerPath { get; } Property Value PointerPath Methods ResolveFor(ProcessMemory) Evaluates the pointer path in the target process using the given ProcessMemory instance. public Result<nuint> ResolveFor(ProcessMemory processMemory) Parameters processMemory ProcessMemory Instance of ProcessMemory attached to the target process. Returns Result<nuint> A result holding either the resolved address, or a failure."
  },
  "api/MindControl.ProcessMemory.html": {
    "href": "api/MindControl.ProcessMemory.html",
    "title": "Class ProcessMemory | MindControl",
    "summary": "Class ProcessMemory Namespace MindControl Assembly MindControl.dll Provides methods to manipulate the memory of a process. public class ProcessMemory : IDisposable Inheritance object ProcessMemory Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ProcessMemoryCodeExtensions.DisableCodeAt(ProcessMemory, PointerPath, int) ProcessMemoryCodeExtensions.DisableCodeAt(ProcessMemory, nuint, int) ProcessMemoryCodeExtensions.StoreCode(ProcessMemory, Assembler, nuint?) ProcessMemoryHookExtensions.Hook(ProcessMemory, PointerPath, Assembler, HookOptions) ProcessMemoryHookExtensions.Hook(ProcessMemory, PointerPath, byte[], HookOptions) ProcessMemoryHookExtensions.Hook(ProcessMemory, nuint, Assembler, HookOptions) ProcessMemoryHookExtensions.Hook(ProcessMemory, nuint, byte[], HookOptions) ProcessMemoryHookExtensions.InsertCodeAt(ProcessMemory, PointerPath, Assembler, params HookRegister[]) ProcessMemoryHookExtensions.InsertCodeAt(ProcessMemory, PointerPath, byte[], params HookRegister[]) ProcessMemoryHookExtensions.InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[]) ProcessMemoryHookExtensions.InsertCodeAt(ProcessMemory, nuint, byte[], params HookRegister[]) ProcessMemoryHookExtensions.ReplaceCodeAt(ProcessMemory, PointerPath, int, Assembler, params HookRegister[]) ProcessMemoryHookExtensions.ReplaceCodeAt(ProcessMemory, PointerPath, int, byte[], params HookRegister[]) ProcessMemoryHookExtensions.ReplaceCodeAt(ProcessMemory, nuint, int, Assembler, params HookRegister[]) ProcessMemoryHookExtensions.ReplaceCodeAt(ProcessMemory, nuint, int, byte[], params HookRegister[]) Properties Allocations Gets the ranges that have been allocated for this process. Dispose a range to free the memory and remove it from this list. public IReadOnlyList<MemoryAllocation> Allocations { get; } Property Value IReadOnlyList<MemoryAllocation> DefaultRawStringMaxLength Gets or sets the default maximum length of strings to read with ReadRawString(nuint, Encoding, int?, bool) when the length is not specified. The default value is an arbitrary 100. public int DefaultRawStringMaxLength { get; set; } Property Value int DefaultWriteStrategy Gets or sets the default way this instance deals with memory protection. This value is used when no strategy is specified in memory write operations. By default, this value will be RemoveAndRestore. public MemoryProtectionStrategy DefaultWriteStrategy { get; set; } Property Value MemoryProtectionStrategy Is64Bit Gets a boolean indicating if the process is 64-bit. public bool Is64Bit { get; } Property Value bool IsAttached Gets a value indicating if the process is currently attached or not. public bool IsAttached { get; } Property Value bool ProcessHandle Gets the handle of the attached process. Use this if you need to manually call Win32 API functions. public nint ProcessHandle { get; } Property Value nint Methods Allocate(ulong, bool, MemoryRange?, nuint?) Attempts to allocate a memory range of the given size within the process. Use this method only when automatic allocation management through the Store methods or Reserve(ulong, bool, MemoryRange?, nuint?) method are not appropriate. public DisposableResult<MemoryAllocation> Allocate(ulong size, bool forExecutableCode, MemoryRange? limitRange = null, nuint? nearAddress = null) Parameters size ulong Size of the memory range to allocate. forExecutableCode bool Determines if the memory range can be used to store executable code. limitRange MemoryRange? Specify this parameter to limit the allocation to a specific range of memory. nearAddress nuint? If specified, try to allocate as close as possible to this address. Returns DisposableResult<MemoryAllocation> A result holding either the allocated memory range, or a failure. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() EvaluateMemoryAddress(PointerPath) Evaluates the given pointer path to the memory address it points to in the process. public Result<nuint> EvaluateMemoryAddress(PointerPath pointerPath) Parameters pointerPath PointerPath Pointer path to evaluate. Returns Result<nuint> The memory address pointed by the pointer path. FindBytes(ByteSearchPattern, MemoryRange?, FindBytesSettings?) Scans the memory of the target process for a byte pattern. Returns the address of each occurrence in the target range, or in the whole memory if no range is specified. Depending on the parameters, the scan may take a long time to complete. Use the asynchronous variant if you need to keep your program responsive while the scan is going on. Read the documentation to learn how to perform efficient scans. public IEnumerable<nuint> FindBytes(ByteSearchPattern pattern, MemoryRange? range = null, FindBytesSettings? settings = null) Parameters pattern ByteSearchPattern Byte pattern to look for. See TryParse(string). You can use a string instead and it will be converted implicitly. An example would be \"1F ?? 4B 00 ?6\". range MemoryRange? Range of memory to scan. Leave this to null (the default) to scan the whole process memory. Restricting the memory range can dramatically improve the performance of the scan. settings FindBytesSettings Settings for the search. Leave this to null (the default) to use the default settings. Using more restrictive settings can dramatically improve the performance of the scan. Returns IEnumerable<nuint> An enumerable of addresses where the pattern was found. FindBytesAsync(ByteSearchPattern, MemoryRange?, FindBytesSettings?) Scans the memory of the target process for a byte pattern. Returns the address of each occurrence in the target range, or in the whole memory if no range is specified. This is the asynchronous variant of FindBytes(ByteSearchPattern, MemoryRange?, FindBytesSettings?). Use this variant if you need to keep your program responsive while the scan is going on. Read the documentation to learn how to perform efficient scans. public IAsyncEnumerable<nuint> FindBytesAsync(ByteSearchPattern pattern, MemoryRange? range = null, FindBytesSettings? settings = null) Parameters pattern ByteSearchPattern Byte pattern to look for. See TryParse(string). You can use a string instead and it will be converted implicitly. An example would be \"1F ?? 4B 00 ?6\". range MemoryRange? Range of memory to scan. Leave this to null (the default) to scan the whole process memory. Restricting the memory range can dramatically improve the performance of the scan. settings FindBytesSettings Settings for the search. Leave this to null (the default) to use the default settings. Using more restrictive settings can dramatically improve the performance of the scan. Returns IAsyncEnumerable<nuint> An asynchronous enumerable of addresses where the pattern was found. FindStringSettings(PointerPath, string) Attempts to find appropriate settings to read and write strings at the pointer referred by the given path, pointing to a known string. As this is based on guesses, the settings may not be determined correctly for every possible case, but they should be accurate most of the time. public Result<StringSettings> FindStringSettings(PointerPath pointerPath, string expectedString) Parameters pointerPath PointerPath Path to a pointer that points to a known string. expectedString string Known string that the pointer points to. Very short strings consisting of only a few characters may lead to unaccurate results. Strings containing diacritics or non-Latin characters provide better results. Returns Result<StringSettings> A result holding the potential string settings if they were successfully determined, or a failure otherwise. FindStringSettings(nuint, string) Attempts to find appropriate settings to read and write strings at the given address pointing to a known string. As this is based on guesses, the settings may not be determined correctly for every possible case, but they should be accurate most of the time. public Result<StringSettings> FindStringSettings(nuint stringPointerAddress, string expectedString) Parameters stringPointerAddress nuint Address to a pointer that points to a known string. expectedString string Known string that the pointer points to. Very short strings consisting of only a few characters may lead to unaccurate results. Strings containing diacritics or non-Latin characters provide better results. Returns Result<StringSettings> A result holding the potential string settings if they were successfully determined, or a failure otherwise. GetAnchor<T>(PointerPath) Builds and returns an anchor for a value of type T at the address referred by the given pointer path. Anchors allow you to track and manipulate a specific value in memory. When not needed anymore, anchors should be disposed. public ValueAnchor<T> GetAnchor<T>(PointerPath pointerPath) where T : struct Parameters pointerPath PointerPath Pointer path to the address of the value in memory. Returns ValueAnchor<T> An anchor for the value at the specified address. Type Parameters T Type of the value to read and write. GetAnchor<T>(nuint) Builds and returns an anchor for a value of type T at the specified address. Anchors allow you to track and manipulate a specific value in memory. When not needed anymore, anchors should be disposed. public ValueAnchor<T> GetAnchor<T>(nuint address) where T : struct Parameters address nuint Address of the value in memory. Returns ValueAnchor<T> An anchor for the value at the specified address. Type Parameters T Type of the value to read and write. GetAttachedProcessInstance() Gets a new instance of Process representing the attached process. The returned instance is owned by the caller and should be disposed when no longer needed. public DisposableResult<Process> GetAttachedProcessInstance() Returns DisposableResult<Process> GetByteArrayAnchor(PointerPath, int) Builds and returns an anchor for a byte array at the address referred by the given pointer path. Anchors allow you to track and manipulate a specific value in memory. When not needed anymore, anchors should be disposed. public ValueAnchor<byte[]> GetByteArrayAnchor(PointerPath pointerPath, int size) Parameters pointerPath PointerPath Pointer path to the address of the target array in memory. size int Size of the target byte array. Returns ValueAnchor<byte[]> An anchor for the array at the specified address. GetByteArrayAnchor(nuint, int) Builds and returns an anchor for a byte array at the specified address. Anchors allow you to track and manipulate a specific value in memory. When not needed anymore, anchors should be disposed. public ValueAnchor<byte[]> GetByteArrayAnchor(nuint address, int size) Parameters address nuint Address of target byte array in memory. size int Size of the target byte array. Returns ValueAnchor<byte[]> An anchor for the array at the specified address. GetMemoryStream(PointerPath) Creates and returns a new ProcessMemoryStream instance that starts at the address pointed by the given path. The stream can be used to read or write into the process memory. It is owned by the caller and must be disposed when no longer needed. public DisposableResult<ProcessMemoryStream> GetMemoryStream(PointerPath pointerPath) Parameters pointerPath PointerPath Pointer path to the starting address of the stream. Returns DisposableResult<ProcessMemoryStream> A result holding either the created process memory stream, or a path evaluation failure. GetMemoryStream(nuint) Creates and returns a new ProcessMemoryStream instance that starts at the given address. The stream can be used to read or write into the process memory. It is owned by the caller and must be disposed when no longer needed. public ProcessMemoryStream GetMemoryStream(nuint startAddress) Parameters startAddress nuint Starting address of the stream. Returns ProcessMemoryStream The created process memory stream. GetModule(string) Gets the module with the given name, if it exists. public RemoteModule? GetModule(string moduleName) Parameters moduleName string Name of the target module. Returns RemoteModule The module if found, null otherwise. GetStringPointerAnchor(PointerPath, StringSettings) Builds and returns an anchor for a string pointer at the address referred by the specified pointer path. Anchors allow you to track and manipulate a specific value in memory. When not needed anymore, anchors should be disposed. String anchors are read-only. To write strings, please see the documentation. public ValueAnchor<string> GetStringPointerAnchor(PointerPath pointerPath, StringSettings stringSettings) Parameters pointerPath PointerPath Pointer path to the address of the string pointer in memory. stringSettings StringSettings Settings to read the string. Returns ValueAnchor<string> An anchor for the value at the specified address. GetStringPointerAnchor(nuint, StringSettings) Builds and returns an anchor for a string pointer at the specified address. Anchors allow you to track and manipulate a specific value in memory. When not needed anymore, anchors should be disposed. String anchors are read-only. To write strings, please see the documentation. public ValueAnchor<string> GetStringPointerAnchor(nuint address, StringSettings stringSettings) Parameters address nuint Address of the string pointer in memory. stringSettings StringSettings Settings to read the string. Returns ValueAnchor<string> An anchor for the value at the specified address. InjectLibrary(string) Injects a library into the attached process. public Result InjectLibrary(string libraryPath) Parameters libraryPath string Path to the library file to inject into the process. Returns Result A result indicating success or failure. InjectLibrary(string, TimeSpan) Injects a library into the attached process. public Result InjectLibrary(string libraryPath, TimeSpan waitTimeout) Parameters libraryPath string Path to the library file to inject into the process. waitTimeout TimeSpan Time to wait for the injection thread to return. Returns Result A result indicating success or failure. OpenProcess(Process) Attaches to the given process, and returns the resulting ProcessMemory instance. public static Result<ProcessMemory> OpenProcess(Process target) Parameters target Process Process to attach to. Returns Result<ProcessMemory> A result holding either the attached process instance, or a failure. OpenProcess(Process, IOperatingSystemService) Attaches to the given process, and returns the resulting ProcessMemory instance. This variant allows you to specify an implementation of IOperatingSystemService to use instead of the default implementation. Unless you have very specific needs, use another overload of this method. public static Result<ProcessMemory> OpenProcess(Process target, IOperatingSystemService osService) Parameters target Process Process to attach to. osService IOperatingSystemService Service that provides system-specific process-oriented features. Returns Result<ProcessMemory> A result holding either the attached process instance, or a failure. OpenProcessById(int) Attaches to the process with the given identifier and returns the resulting ProcessMemory instance. public static Result<ProcessMemory> OpenProcessById(int pid) Parameters pid int Identifier of the process to attach to. Returns Result<ProcessMemory> A result holding either the attached process instance, or a failure. OpenProcessByName(string) Attaches to a process with the given name and returns the resulting ProcessMemory instance. If multiple processes with the specified name are running, a MultipleTargetProcessesFailure will be returned. When there is any risk of this happening, it is recommended to use OpenProcessById(int) instead. public static Result<ProcessMemory> OpenProcessByName(string processName) Parameters processName string Name of the process to open. Returns Result<ProcessMemory> A result holding either the attached process instance, or a failure. Read(Type, PointerPath) Reads a specific type of data from the address referred by the given pointer path, in the process memory. This method only supports value types (primitive types and structures). public Result<object> Read(Type type, PointerPath pointerPath) Parameters type Type Type of data to read. Only value types are supported (primitive types and structures). pointerPath PointerPath Pointer path to the target address. Can be implicitly converted from a string. Example: \"MyGame.exe+1F1688,1F,4\". Reuse PointerPath instances to optimize execution time. Returns Result<object> The value read from the process memory, or a failure. Read(Type, nuint) Reads a specific type of data from the given address, in the process memory. This method only supports value types (primitive types and structures). public Result<object> Read(Type type, nuint address) Parameters type Type Type of data to read. Only value types are supported (primitive types and structures). address nuint Target address in the process memory. Returns Result<object> The value read from the process memory, or a failure. ReadBytes(PointerPath, long) Reads a sequence of bytes from the address referred by the given pointer path, in the process memory. public Result<byte[]> ReadBytes(PointerPath pointerPath, long length) Parameters pointerPath PointerPath Optimized, reusable path to the target address. length long Number of bytes to read. Returns Result<byte[]> The value read from the process memory, or a failure. ReadBytes(PointerPath, ulong) Reads a sequence of bytes from the address referred by the given pointer path, in the process memory. public Result<byte[]> ReadBytes(PointerPath pointerPath, ulong length) Parameters pointerPath PointerPath Optimized, reusable path to the target address. length ulong Number of bytes to read. Returns Result<byte[]> The value read from the process memory, or a failure. ReadBytes(nuint, long) Reads a sequence of bytes from the given address in the process memory. public Result<byte[]> ReadBytes(nuint address, long length) Parameters address nuint Target address in the process memory. length long Number of bytes to read. Returns Result<byte[]> The value read from the process memory, or a failure. ReadBytes(nuint, ulong) Reads a sequence of bytes from the given address in the process memory. public Result<byte[]> ReadBytes(nuint address, ulong length) Parameters address nuint Target address in the process memory. length ulong Number of bytes to read. Returns Result<byte[]> The value read from the process memory, or a failure. ReadBytesPartial(PointerPath, byte[], ulong) Reads a sequence of bytes from the address pointed by the given path in the process memory. The resulting bytes are read into the provided buffer array. Unlike ReadBytes(nuint, long), this method succeeds even when only a part of the bytes are read. Use it when you are not sure how many bytes you need to read, or when you want to read as many bytes as possible. public Result<ulong> ReadBytesPartial(PointerPath pointerPath, byte[] buffer, ulong maxLength) Parameters pointerPath PointerPath Pointer path to the target address in the process memory. buffer byte[] Buffer to store the bytes read. maxLength ulong Number of bytes to read, at most. Returns Result<ulong> The value read from the process memory, or a failure in case no bytes could be read. ReadBytesPartial(nuint, byte[], ulong) Reads a sequence of bytes from the given address in the process memory. The resulting bytes are read into the provided buffer array. Unlike ReadBytes(nuint, long), this method succeeds even when only a part of the bytes are read. Use it when you are not sure how many bytes you need to read, or when you want to read as many bytes as possible. public Result<ulong> ReadBytesPartial(nuint address, byte[] buffer, ulong maxLength) Parameters address nuint Target address in the process memory. buffer byte[] Buffer to store the bytes read. maxLength ulong Number of bytes to read, at most. Returns Result<ulong> The value read from the process memory, or a failure in case no bytes could be read. ReadRawString(PointerPath, Encoding, int?, bool) Reads a string from the address referred by the given pointer path, in the process memory. The address must point to the start of the actual string bytes. Consider ReadStringPointer(PointerPath, StringSettings) to read strings from pointers more efficiently. Read the documentation for more information. public Result<string> ReadRawString(PointerPath pointerPath, Encoding encoding, int? maxLength = null, bool isNullTerminated = true) Parameters pointerPath PointerPath Path to the first byte of the raw string in the process memory. encoding Encoding Encoding of the string to use when decoding. Try changing this parameter if you get garbage characters or empty strings. Common values include UTF8 and Unicode. maxLength int? Maximum length of the string to read, in characters. If left null (default), the DefaultRawStringMaxLength will be used. isNullTerminated bool Boolean indicating if the string is null-terminated. If true, the string will be read until the first null character. If false, the string will be read up to the maximum length specified. Returns Result<string> The string read from the process memory, or a failure. ReadRawString(nuint, Encoding, int?, bool) Reads a string from the given address in the process memory. The address must point to the start of the actual string bytes. Consider ReadStringPointer(nuint, StringSettings) to read strings from pointers more efficiently. Read the documentation for more information. public Result<string> ReadRawString(nuint address, Encoding encoding, int? maxLength = null, bool isNullTerminated = true) Parameters address nuint Address of the first byte of the raw string in the process memory. encoding Encoding Encoding of the string to use when decoding. Try changing this parameter if you get garbage characters or empty strings. Common values include UTF8 and Unicode. maxLength int? Maximum length of the string to read, in characters. If left null (default), the DefaultRawStringMaxLength will be used. isNullTerminated bool Boolean indicating if the string is null-terminated. If true, the string will be read until the first null character. If false, the string will be read up to the maximum length specified. Returns Result<string> The string read from the process memory, or a failure. ReadStringPointer(PointerPath, StringSettings) Reads the string pointed by the pointer evaluated from the given pointer path from the process memory. This method uses a StringSettings instance to determine how to read the string. public Result<string> ReadStringPointer(PointerPath pointerPath, StringSettings settings) Parameters pointerPath PointerPath Pointer path to the pointer to the string in the process memory. settings StringSettings Settings that define how to read the string. If you cannot figure out what settings to use, try FindStringSettings(nuint, string) to automatically determine the right settings for a known string pointer. See the documentation for more information. Returns Result<string> The string read from the process memory, or a failure. ReadStringPointer(nuint, StringSettings) Reads the string pointed by the pointer at the given address from the process memory. This method uses a StringSettings instance to determine how to read the string. public Result<string> ReadStringPointer(nuint address, StringSettings settings) Parameters address nuint Address of the pointer to the string in the process memory. settings StringSettings Settings that define how to read the string. If you cannot figure out what settings to use, try FindStringSettings(nuint, string) to automatically determine the right settings for a known string pointer. See the documentation for more information. Returns Result<string> The string read from the process memory, or a failure. Read<T>(PointerPath) Reads a specific type of data from the address referred by the given pointer path, in the process memory. This method only supports value types (primitive types and structures). public Result<T> Read<T>(PointerPath pointerPath) where T : struct Parameters pointerPath PointerPath Pointer path to the target address. Can be implicitly converted from a string. Example: \"MyGame.exe+1F1688,1F,4\". Reuse PointerPath instances to optimize execution time. Returns Result<T> The value read from the process memory, or a failure. Type Parameters T Type of data to read. Only value types are supported (primitive types and structures). Read<T>(nuint) Reads a specific type of data from the given address, in the process memory. This method only supports value types (primitive types and structures). public Result<T> Read<T>(nuint address) where T : struct Parameters address nuint Target address in the process memory. Returns Result<T> The value read from the process memory, or a failure. Type Parameters T Type of data to read. Only value types are supported (primitive types and structures). RefreshModuleCache() Refreshes the module cache used when evaluating pointer paths. Call this method when your process' modules have changed due to external factors such as plugins being loaded, or other third-party software interacting with the process. public void RefreshModuleCache() Reserve(ulong, bool, MemoryRange?, nuint?) Reserves a range of memory of the given size. If no suitable range is found within the current allocations, a new range is allocated, and a reservation is made on it. public DisposableResult<MemoryReservation> Reserve(ulong size, bool requireExecutable, MemoryRange? limitRange = null, nuint? nearAddress = null) Parameters size ulong Size of the memory range to reserve. requireExecutable bool Set to true if the memory range must be executable (to store code). limitRange MemoryRange? Specify this parameter to limit the reservation to allocations within a specific range of memory. If left null (default), any allocation can be used. Otherwise, only allocations within the specified range will be considered, and if none are available, a new allocation will be attempted within that range. nearAddress nuint? If specified, prioritize allocations by their proximity to this address. If no matching allocation is found, a new allocation as close as possible to this address will be attempted. Returns DisposableResult<MemoryReservation> A result holding either the resulting reservation, or a failure. RunThread(PointerPath, nuint?) Starts a new thread in the target process, running the function at the address pointed by the given pointer path. This method will not wait for the thread to finish execution. Use the resulting RemoteThread instance to wait for the thread to finish if you need to. public DisposableResult<RemoteThread> RunThread(PointerPath functionPointerPath, nuint? parameter = null) Parameters functionPointerPath PointerPath Pointer path to the function (or start instruction) to run in the target process. parameter nuint? An optional parameter to pass to the function. It can be either an address or a value. This input value will be stored in register RCX for x64, or EBX for x86. If this does not match the call conventions of the target function, the thread must execute a \"trampoline\" code that arranges the parameter in the expected way before calling the function. See the documentation for more info. Returns DisposableResult<RemoteThread> A result holding either the thread instance that you can use to wait for the thread to return, or a failure. RunThread(string, string, nuint?) Starts a new thread in the target process, running the specified exported function from a module loaded into the target process. This method will not wait for the thread to finish execution. Use the resulting RemoteThread instance to wait for the thread to finish if you need to. public DisposableResult<RemoteThread> RunThread(string moduleName, string functionName, nuint? parameter = null) Parameters moduleName string Name of the module containing the function to run (e.g. \"kernel32.dll\"). functionName string Name of the exported function to run from the specified module. parameter nuint? An optional parameter to pass to the function. It can be either an address or a value. This input value will be stored in register RCX for x64, or EBX for x86. If this does not match the call conventions of the target function, the thread must execute a \"trampoline\" code that arranges the parameter in the expected way before calling the function. See the documentation for more info. Returns DisposableResult<RemoteThread> A result holding either the thread instance that you can use to wait for the thread to return, or a failure. RunThread(nuint, nuint?) Starts a new thread in the target process, running the function at the specified address. This method will not wait for the thread to finish execution. Use the resulting RemoteThread instance to wait for the thread to finish if you need to. public DisposableResult<RemoteThread> RunThread(nuint functionAddress, nuint? parameter = null) Parameters functionAddress nuint Address of the function (starting instruction) to run in the target process. parameter nuint? An optional parameter to pass to the function. It can be either an address or a value. This input value will be stored in register RCX for x64, or EBX for x86. If this does not match the call conventions of the target function, the thread must execute a \"trampoline\" code that arranges the parameter in the expected way before calling the function. See the documentation for more info. Returns DisposableResult<RemoteThread> A result holding either the thread instance that you can use to wait for the thread to return, or a failure. Store(byte[], MemoryAllocation) Stores the given data in the specified allocated range. Returns the reservation that holds the data. In most situations, you can use the Store<T>(T) or Store(byte[], bool) signatures instead, to have the ProcessMemory instance handle allocations automatically. Use this signature if you need to manage allocations and reservations manually. public DisposableResult<MemoryReservation> Store(byte[] data, MemoryAllocation allocation) Parameters data byte[] Data to store. allocation MemoryAllocation Allocated memory to store the data. Returns DisposableResult<MemoryReservation> A result holding either the reservation storing the data, or a failure. Store(byte[], bool) Stores the given data in the process memory. If needed, memory is allocated to store the data. Returns the reserved range that you can utilize to use the data. public DisposableResult<MemoryReservation> Store(byte[] data, bool isCode = false) Parameters data byte[] Data to store. isCode bool Set to true if the data is executable code. Defaults to false. Returns DisposableResult<MemoryReservation> A result holding either the reserved memory range, or an allocation failure. StoreString(string, StringSettings) Stores the given string in the process memory. If needed, memory is allocated to store the string. Returns the reservation that holds the string. public DisposableResult<MemoryReservation> StoreString(string value, StringSettings settings) Parameters value string String to store. settings StringSettings String settings to use to write the string. Returns DisposableResult<MemoryReservation> A result holding either the reservation where the string has been written, or a failure. StoreString(string, StringSettings, MemoryAllocation) Stores the given string in the specified range of memory. Returns the reservation that holds the string. In most situations, you should use the StoreString(string, StringSettings) signature instead, to have the ProcessMemory instance handle allocations automatically. Use this signature if you need to manage allocations and reservations manually. public DisposableResult<MemoryReservation> StoreString(string value, StringSettings settings, MemoryAllocation allocation) Parameters value string String to store. settings StringSettings String settings to use to write the string. allocation MemoryAllocation Range of memory to store the string in. Returns DisposableResult<MemoryReservation> A result holding either the reservation where the string has been written, or a failure. Store<T>(T) Stores the given value or structure in the process memory. If needed, memory is allocated to store the data. Returns the reservation that holds the data. public DisposableResult<MemoryReservation> Store<T>(T value) Parameters value T Value or structure to store. Returns DisposableResult<MemoryReservation> A result holding either the reservation where the data has been written, or a failure. Type Parameters T Type of the value or structure. Store<T>(T, MemoryAllocation) Stores the given value or structure in the specified range of memory. Returns the reservation that holds the data. In most situations, you can use the Store<T>(T) or Store(byte[], bool) signatures instead, to have the ProcessMemory instance handle allocations automatically. Use this signature if you need to manage allocations and reservations manually. public DisposableResult<MemoryReservation> Store<T>(T value, MemoryAllocation allocation) where T : struct Parameters value T Value or structure to store. allocation MemoryAllocation Range of memory to store the data in. Returns DisposableResult<MemoryReservation> A result holding either the reservation where the data has been written, or a failure. Type Parameters T Type of the value or structure. WriteBytes(PointerPath, byte[], MemoryProtectionStrategy?) Writes a sequence of bytes to the address referred by the given pointer path in the process memory. public Result WriteBytes(PointerPath path, byte[] value, MemoryProtectionStrategy? memoryProtectionStrategy = null) Parameters path PointerPath Optimized, reusable path to the target address. value byte[] Value to write. memoryProtectionStrategy MemoryProtectionStrategy? Strategy to use to deal with memory protection. If null (default), the DefaultWriteStrategy of this instance is used. Returns Result A result indicating either a success or a failure. WriteBytes(nuint, Span<byte>, MemoryProtectionStrategy?) Writes a sequence of bytes to the given address in the process memory. public Result WriteBytes(nuint address, Span<byte> value, MemoryProtectionStrategy? memoryProtectionStrategy = null) Parameters address nuint Target address in the process memory. value Span<byte> Value to write. memoryProtectionStrategy MemoryProtectionStrategy? Strategy to use to deal with memory protection. If null (default), the DefaultWriteStrategy of this instance is used. Returns Result A result indicating either a success or a failure. Write<T>(PointerPath, T, MemoryProtectionStrategy?) Writes a value to the address referred by the given pointer path in the process memory. public Result Write<T>(PointerPath path, T value, MemoryProtectionStrategy? memoryProtectionStrategy = null) Parameters path PointerPath Optimized, reusable path to the target address. value T Value to write. memoryProtectionStrategy MemoryProtectionStrategy? Strategy to use to deal with memory protection. If null (default), the DefaultWriteStrategy of this instance is used. Returns Result A result indicating either a success or a failure. Type Parameters T Type of the value to write. Exceptions ArgumentException Thrown when the type of the value is not supported. Write<T>(nuint, T, MemoryProtectionStrategy?) Writes a value to the given address in the process memory. public Result Write<T>(nuint address, T value, MemoryProtectionStrategy? memoryProtectionStrategy = null) Parameters address nuint Target address in the process memory. value T Value to write. memoryProtectionStrategy MemoryProtectionStrategy? Strategy to use to deal with memory protection. If null (default), the DefaultWriteStrategy of this instance is used. Returns Result A result indicating either a success or a failure. Type Parameters T Type of the value to write. Events ProcessDetached Event raised when the process detaches for any reason. public event EventHandler? ProcessDetached Event Type EventHandler"
  },
  "api/MindControl.ProcessMemoryStream.html": {
    "href": "api/MindControl.ProcessMemoryStream.html",
    "title": "Class ProcessMemoryStream | MindControl",
    "summary": "Class ProcessMemoryStream Namespace MindControl Assembly MindControl.dll A stream that reads or writes into the memory of a process. public class ProcessMemoryStream : Stream, IAsyncDisposable, IDisposable Inheritance object MarshalByRefObject Stream ProcessMemoryStream Implements IAsyncDisposable IDisposable Inherited Members Stream.Null Stream.BeginRead(byte[], int, int, AsyncCallback, object) Stream.BeginWrite(byte[], int, int, AsyncCallback, object) Stream.Close() Stream.CopyTo(Stream) Stream.CopyTo(Stream, int) Stream.CopyToAsync(Stream) Stream.CopyToAsync(Stream, int) Stream.CopyToAsync(Stream, int, CancellationToken) Stream.CopyToAsync(Stream, CancellationToken) Stream.CreateWaitHandle() Stream.Dispose() Stream.Dispose(bool) Stream.DisposeAsync() Stream.EndRead(IAsyncResult) Stream.EndWrite(IAsyncResult) Stream.FlushAsync() Stream.FlushAsync(CancellationToken) Stream.ObjectInvariant() Stream.Read(Span<byte>) Stream.ReadAsync(byte[], int, int) Stream.ReadAsync(byte[], int, int, CancellationToken) Stream.ReadAsync(Memory<byte>, CancellationToken) Stream.ReadAtLeast(Span<byte>, int, bool) Stream.ReadAtLeastAsync(Memory<byte>, int, bool, CancellationToken) Stream.ReadByte() Stream.ReadExactly(byte[], int, int) Stream.ReadExactly(Span<byte>) Stream.ReadExactlyAsync(byte[], int, int, CancellationToken) Stream.ReadExactlyAsync(Memory<byte>, CancellationToken) Stream.Synchronized(Stream) Stream.ValidateBufferArguments(byte[], int, int) Stream.ValidateCopyToArguments(Stream, int) Stream.Write(ReadOnlySpan<byte>) Stream.WriteAsync(byte[], int, int) Stream.WriteAsync(byte[], int, int, CancellationToken) Stream.WriteAsync(ReadOnlyMemory<byte>, CancellationToken) Stream.WriteByte(byte) Stream.CanTimeout Stream.ReadTimeout Stream.WriteTimeout MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CanRead Returns True to indicate that this stream supports reading. public override bool CanRead { get; } Property Value bool true. CanSeek Returns False to indicate that this stream does not support seeking. public override bool CanSeek { get; } Property Value bool true. CanWrite Returns True to indicate that this stream supports writing. public override bool CanWrite { get; } Property Value bool true Length In this implementation, this getter is not supported. public override long Length { get; } Property Value long A long value representing the length of the stream in bytes. Exceptions NotSupportedException Always thrown, as this implementation does not support seeking. Position Gets or sets the position within the current stream, relative to the start address. public override long Position { get; set; } Property Value long Methods Flush() In this implementation, does not perform any action. public override void Flush() Read(byte[], int, int) Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read. public override int Read(byte[] buffer, int offset, int count) Parameters buffer byte[] An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source. offset int The zero-based byte offset in buffer at which to begin storing the data read from the current stream. count int The maximum number of bytes to be read from the current stream. Returns int The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached. Exceptions ArgumentException The sum of offset and count is larger than the buffer length. ArgumentNullException buffer is null. ArgumentOutOfRangeException offset or count is negative. IOException An I/O error occurs. ObjectDisposedException Methods were called after the stream was closed. Seek(long, SeekOrigin) Moves the position within the current stream by the specified offset, relative to either the start of the stream (the base address), or the current position. Seeking relative to the end is not supported by this implementation, as there is no end by design. public override long Seek(long offset, SeekOrigin origin) Parameters offset long A byte offset relative to the origin parameter. origin SeekOrigin A value of type SeekOrigin indicating the reference point used to obtain the new position. In this implementation, End is not supported. Returns long The new position within the current stream. Exceptions NotSupportedException Thrown when origin is set to End, as this implementation has no length and thus no end. SetLength(long) In this implementation, this method is not supported. public override void SetLength(long value) Parameters value long The desired length of the current stream in bytes. Exceptions NotSupportedException Always thrown, as this stream implementation does not support seeking. Write(byte[], int, int) Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written. public override void Write(byte[] buffer, int offset, int count) Parameters buffer byte[] An array of bytes. This method copies count bytes from buffer to the current stream. offset int The zero-based byte offset in buffer at which to begin copying bytes to the current stream. count int The number of bytes to be written to the current stream. Exceptions ArgumentException The sum of offset and count is greater than the buffer length. ArgumentNullException buffer is null. ArgumentOutOfRangeException offset or count is negative. IOException An I/O error occurred. ObjectDisposedException Write(byte[], int, int) was called after the stream was closed."
  },
  "api/MindControl.ProcessTracker.html": {
    "href": "api/MindControl.ProcessTracker.html",
    "title": "Class ProcessTracker | MindControl",
    "summary": "Class ProcessTracker Namespace MindControl Assembly MindControl.dll Provides a ProcessMemory for a process identified by its name. The tracker is able to re-attach to a process with the same name after it has been closed and reopened. public class ProcessTracker : IDisposable Inheritance object ProcessTracker Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ProcessTracker(string) Builds a tracker for the process with the given name. public ProcessTracker(string processName) Parameters processName string Name of the process to track. Properties IsAttached Gets a value indicating if the process is currently attached. public bool IsAttached { get; } Property Value bool ProcessName Gets the name of the process tracked by this instance. public string ProcessName { get; } Property Value string Methods Dispose() Releases the underlying process memory if required. public void Dispose() GetProcessMemory() Gets the ProcessMemory instance for the currently attached process. If no process is attached yet, make an attempt to attach to the target process by its name. Returns null if no process with the target name can be found. public ProcessMemory? GetProcessMemory() Returns ProcessMemory Events Attached Event raised when attaching to the target process. public event EventHandler? Attached Event Type EventHandler Detached Event raised when detached from the target process. public event EventHandler? Detached Event Type EventHandler"
  },
  "api/MindControl.RangeAlignmentMode.html": {
    "href": "api/MindControl.RangeAlignmentMode.html",
    "title": "Enum RangeAlignmentMode | MindControl",
    "summary": "Enum RangeAlignmentMode Namespace MindControl Assembly MindControl.dll Defines a byte alignment mode for memory ranges. public enum RangeAlignmentMode Fields AlignBlock = 2 Align both the start and the size of the range. AlignStart = 1 Align the start of the range, but not the size. None = 0 Do not align the range."
  },
  "api/MindControl.Results.BaseModuleNotFoundFailure.html": {
    "href": "api/MindControl.Results.BaseModuleNotFoundFailure.html",
    "title": "Class BaseModuleNotFoundFailure | MindControl",
    "summary": "Class BaseModuleNotFoundFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a path evaluation operation when the base module specified in the pointer path was not found. public record BaseModuleNotFoundFailure : Failure, IEquatable<Failure>, IEquatable<BaseModuleNotFoundFailure> Inheritance object Failure BaseModuleNotFoundFailure Implements IEquatable<Failure> IEquatable<BaseModuleNotFoundFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors BaseModuleNotFoundFailure(string) Represents a failure in a path evaluation operation when the base module specified in the pointer path was not found. public BaseModuleNotFoundFailure(string ModuleName) Parameters ModuleName string Name of the module that was not found. Properties ModuleName Name of the module that was not found. public string ModuleName { get; init; } Property Value string"
  },
  "api/MindControl.Results.CodeAssemblyFailure.html": {
    "href": "api/MindControl.Results.CodeAssemblyFailure.html",
    "title": "Class CodeAssemblyFailure | MindControl",
    "summary": "Class CodeAssemblyFailure Namespace MindControl.Results Assembly MindControl.Code.dll Represents a failure that occurred in a hook operation when instructions could not be assembled into a code block. public record CodeAssemblyFailure : Failure, IEquatable<Failure>, IEquatable<CodeAssemblyFailure> Inheritance object Failure CodeAssemblyFailure Implements IEquatable<Failure> IEquatable<CodeAssemblyFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CodeAssemblyFailure(HookCodeAssemblySource, string) Represents a failure that occurred in a hook operation when instructions could not be assembled into a code block. public CodeAssemblyFailure(HookCodeAssemblySource Source, string Message) Parameters Source HookCodeAssemblySource Block where the code assembly failed. Message string Message that describes the failure. Properties Source Block where the code assembly failed. public HookCodeAssemblySource Source { get; init; } Property Value HookCodeAssemblySource"
  },
  "api/MindControl.Results.CodeDecodingFailure.html": {
    "href": "api/MindControl.Results.CodeDecodingFailure.html",
    "title": "Class CodeDecodingFailure | MindControl",
    "summary": "Class CodeDecodingFailure Namespace MindControl.Results Assembly MindControl.Code.dll Represents a failure that occurred while writing code to a target process when a disassembling operation failed. public record CodeDecodingFailure : Failure, IEquatable<Failure>, IEquatable<CodeDecodingFailure> Inheritance object Failure CodeDecodingFailure Implements IEquatable<Failure> IEquatable<CodeDecodingFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CodeDecodingFailure(DecoderError) Represents a failure that occurred while writing code to a target process when a disassembling operation failed. public CodeDecodingFailure(DecoderError Error) Parameters Error DecoderError Error code that describes the failure. Properties Error Error code that describes the failure. public DecoderError Error { get; init; } Property Value DecoderError"
  },
  "api/MindControl.Results.ConversionFailure.html": {
    "href": "api/MindControl.Results.ConversionFailure.html",
    "title": "Class ConversionFailure | MindControl",
    "summary": "Class ConversionFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory read operation when trying to convert the bytes read from memory to the target type. public record ConversionFailure : Failure, IEquatable<Failure>, IEquatable<ConversionFailure> Inheritance object Failure ConversionFailure Implements IEquatable<Failure> IEquatable<ConversionFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ConversionFailure() Represents a failure in a memory read operation when trying to convert the bytes read from memory to the target type. public ConversionFailure()"
  },
  "api/MindControl.Results.ConversionWriteFailure.html": {
    "href": "api/MindControl.Results.ConversionWriteFailure.html",
    "title": "Class ConversionWriteFailure | MindControl",
    "summary": "Class ConversionWriteFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory write operation when trying to convert the value to write to an array of bytes to write in memory. public record ConversionWriteFailure : Failure, IEquatable<Failure>, IEquatable<ConversionWriteFailure> Inheritance object Failure ConversionWriteFailure Implements IEquatable<Failure> IEquatable<ConversionWriteFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ConversionWriteFailure(Type, Exception) Represents a failure in a memory write operation when trying to convert the value to write to an array of bytes to write in memory. public ConversionWriteFailure(Type Type, Exception ConversionException) Parameters Type Type Type that caused the failure. ConversionException Exception Exception that occurred during the conversion. Properties ConversionException Exception that occurred during the conversion. public Exception ConversionException { get; init; } Property Value Exception Type Type that caused the failure. public Type Type { get; init; } Property Value Type"
  },
  "api/MindControl.Results.DetachedProcessFailure.html": {
    "href": "api/MindControl.Results.DetachedProcessFailure.html",
    "title": "Class DetachedProcessFailure | MindControl",
    "summary": "Class DetachedProcessFailure Namespace MindControl.Results Assembly MindControl.dll Failure that occurs when the process is not attached. public record DetachedProcessFailure : Failure, IEquatable<Failure>, IEquatable<DetachedProcessFailure> Inheritance object Failure DetachedProcessFailure Implements IEquatable<Failure> IEquatable<DetachedProcessFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DetachedProcessFailure() Failure that occurs when the process is not attached. public DetachedProcessFailure()"
  },
  "api/MindControl.Results.DisposableResult-1.html": {
    "href": "api/MindControl.Results.DisposableResult-1.html",
    "title": "Class DisposableResult<TResult> | MindControl",
    "summary": "Class DisposableResult<TResult> Namespace MindControl.Results Assembly MindControl.dll Represents the result of an operation that can either succeed or fail, with a result value in case of success. This variant is disposable and may hold a disposable result. When a successful instance is disposed, the result will be too. public class DisposableResult<TResult> : Result<TResult>, IDisposable where TResult : IDisposable Type Parameters TResult Type of the result that can be returned in case of success. Inheritance object Result Result<TResult> DisposableResult<TResult> Implements IDisposable Inherited Members Result<TResult>.Value Result<TResult>.ValueOrDefault() Result<TResult>.ValueOr(TResult) Result<TResult>.CastValueFrom<TOtherResult>(Result<TOtherResult>) Result<TResult>.ToString() Result.SuccessString Result.Success Result.Failure Result.IsSuccess Result.IsFailure Result.ThrowOnFailure() Result.ToException() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DisposableResult(Failure) Initializes a new failed DisposableResult<TResult> instance. protected DisposableResult(Failure failure) Parameters failure Failure A representation of the failure. DisposableResult(TResult) Initializes a new successful DisposableResult<TResult> instance. protected DisposableResult(TResult value) Parameters value TResult Result of the operation. Methods Dispose() Disposes the result value if the operation was successful. public void Dispose() FailWith(Failure) Creates a new failed DisposableResult<TResult> instance. public static DisposableResult<TResult> FailWith(Failure failure) Parameters failure Failure A representation of the failure. Returns DisposableResult<TResult> FromResult(TResult) Creates a new successful DisposableResult<TResult> instance. public static DisposableResult<TResult> FromResult(TResult result) Parameters result TResult Result of the operation. Returns DisposableResult<TResult> Operators implicit operator DisposableResult<TResult>(Failure) Implicitly converts a failure to an unsuccessful DisposableResult<TResult> instance. public static implicit operator DisposableResult<TResult>(Failure failure) Parameters failure Failure Failure to convert. Returns DisposableResult<TResult> implicit operator DisposableResult<TResult>(TResult) Implicitly converts a result value to a successful DisposableResult<TResult> instance. public static implicit operator DisposableResult<TResult>(TResult result) Parameters result TResult Result value to convert. Returns DisposableResult<TResult>"
  },
  "api/MindControl.Results.DisposedAllocationFailure.html": {
    "href": "api/MindControl.Results.DisposedAllocationFailure.html",
    "title": "Class DisposedAllocationFailure | MindControl",
    "summary": "Class DisposedAllocationFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory reservation operation when the target allocation has been disposed. public record DisposedAllocationFailure : Failure, IEquatable<Failure>, IEquatable<DisposedAllocationFailure> Inheritance object Failure DisposedAllocationFailure Implements IEquatable<Failure> IEquatable<DisposedAllocationFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DisposedAllocationFailure() Represents a failure in a memory reservation operation when the target allocation has been disposed. public DisposedAllocationFailure()"
  },
  "api/MindControl.Results.DisposedThreadFailure.html": {
    "href": "api/MindControl.Results.DisposedThreadFailure.html",
    "title": "Class DisposedThreadFailure | MindControl",
    "summary": "Class DisposedThreadFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a thread operation when the thread handle has already been disposed. public record DisposedThreadFailure : Failure, IEquatable<Failure>, IEquatable<DisposedThreadFailure> Inheritance object Failure DisposedThreadFailure Implements IEquatable<Failure> IEquatable<DisposedThreadFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors DisposedThreadFailure() Represents a failure in a thread operation when the thread handle has already been disposed. public DisposedThreadFailure()"
  },
  "api/MindControl.Results.Failure.html": {
    "href": "api/MindControl.Results.Failure.html",
    "title": "Class Failure | MindControl",
    "summary": "Class Failure Namespace MindControl.Results Assembly MindControl.dll Base class for failures. Can also be used directly when no specific failure type is needed. public record Failure : IEquatable<Failure> Inheritance object Failure Implements IEquatable<Failure> Derived BaseModuleNotFoundFailure CodeAssemblyFailure CodeDecodingFailure ConversionFailure ConversionWriteFailure DetachedProcessFailure DisposedAllocationFailure DisposedThreadFailure FunctionNotFoundFailure IncompatibleBitnessPointerFailure IncompatibleBitnessProcessFailure IncompatibleBitnessWriteFailure IncompatiblePointerPathBitnessFailure InsufficientSpaceFailure InvalidArgumentFailure InvalidBytePatternFailure InvalidStringSettingsFailure LibraryFileNotFoundFailure LibraryLoadFailure LimitRangeOutOfBoundsFailure MemoryProtectionRemovalFailure MemoryProtectionRestorationFailure ModuleAlreadyLoadedFailure MultipleTargetProcessesFailure NoFreeMemoryFailure NotSupportedFailure OperatingSystemCallFailure PointerOutOfRangeFailure StringTooLongFailure TargetProcessNotFoundFailure TargetProcessNotRunningFailure ThreadWaitAbandonedFailure ThreadWaitTimeoutFailure UndeterminedStringSettingsFailure UnsupportedTypeReadFailure UnsupportedTypeWriteFailure ZeroPointerFailure Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Failure(string) Base class for failures. Can also be used directly when no specific failure type is needed. public Failure(string Message) Parameters Message string Message describing the failure. Properties Message Message describing the failure. public string Message { get; init; } Property Value string Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/MindControl.Results.FunctionNotFoundFailure.html": {
    "href": "api/MindControl.Results.FunctionNotFoundFailure.html",
    "title": "Class FunctionNotFoundFailure | MindControl",
    "summary": "Class FunctionNotFoundFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a thread operation when the target function cannot be found. public record FunctionNotFoundFailure : Failure, IEquatable<Failure>, IEquatable<FunctionNotFoundFailure> Inheritance object Failure FunctionNotFoundFailure Implements IEquatable<Failure> IEquatable<FunctionNotFoundFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors FunctionNotFoundFailure(string) Represents a failure in a thread operation when the target function cannot be found. public FunctionNotFoundFailure(string Message) Parameters Message string Message including details about the failure."
  },
  "api/MindControl.Results.HookCodeAssemblySource.html": {
    "href": "api/MindControl.Results.HookCodeAssemblySource.html",
    "title": "Enum HookCodeAssemblySource | MindControl",
    "summary": "Enum HookCodeAssemblySource Namespace MindControl.Results Assembly MindControl.Code.dll Enumerates potential blocks for a CodeAssemblyFailure. public enum HookCodeAssemblySource Fields AppendedCode = 4 Designates the code block that is appended to the injected code. InjectedCode = 3 Designates the injected code block itself. JumpToInjectedCode = 1 Designates the jump instruction that forwards execution to the injected code. PrependedCode = 2 Designates the code block that is prepended to the injected code. Unknown = 0 Default value used when the source is unknown."
  },
  "api/MindControl.Results.IncompatibleBitnessPointerFailure.html": {
    "href": "api/MindControl.Results.IncompatibleBitnessPointerFailure.html",
    "title": "Class IncompatibleBitnessPointerFailure | MindControl",
    "summary": "Class IncompatibleBitnessPointerFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory read operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. public record IncompatibleBitnessPointerFailure : Failure, IEquatable<Failure>, IEquatable<IncompatibleBitnessPointerFailure> Inheritance object Failure IncompatibleBitnessPointerFailure Implements IEquatable<Failure> IEquatable<IncompatibleBitnessPointerFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors IncompatibleBitnessPointerFailure(nuint) Represents a failure in a memory read operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. public IncompatibleBitnessPointerFailure(nuint Address) Parameters Address nuint Address that caused the failure. Properties Address Address that caused the failure. public nuint Address { get; init; } Property Value nuint"
  },
  "api/MindControl.Results.IncompatibleBitnessProcessFailure.html": {
    "href": "api/MindControl.Results.IncompatibleBitnessProcessFailure.html",
    "title": "Class IncompatibleBitnessProcessFailure | MindControl",
    "summary": "Class IncompatibleBitnessProcessFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a process attach operation when the target process is 64-bit and the current process is 32-bit. public record IncompatibleBitnessProcessFailure : Failure, IEquatable<Failure>, IEquatable<IncompatibleBitnessProcessFailure> Inheritance object Failure IncompatibleBitnessProcessFailure Implements IEquatable<Failure> IEquatable<IncompatibleBitnessProcessFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors IncompatibleBitnessProcessFailure() Represents a failure in a process attach operation when the target process is 64-bit and the current process is 32-bit. public IncompatibleBitnessProcessFailure()"
  },
  "api/MindControl.Results.IncompatibleBitnessWriteFailure.html": {
    "href": "api/MindControl.Results.IncompatibleBitnessWriteFailure.html",
    "title": "Class IncompatibleBitnessWriteFailure | MindControl",
    "summary": "Class IncompatibleBitnessWriteFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory write operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. public record IncompatibleBitnessWriteFailure : Failure, IEquatable<Failure>, IEquatable<IncompatibleBitnessWriteFailure> Inheritance object Failure IncompatibleBitnessWriteFailure Implements IEquatable<Failure> IEquatable<IncompatibleBitnessWriteFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors IncompatibleBitnessWriteFailure(nuint) Represents a failure in a memory write operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. public IncompatibleBitnessWriteFailure(nuint Address) Parameters Address nuint Address that caused the failure. Properties Address Address that caused the failure. public nuint Address { get; init; } Property Value nuint"
  },
  "api/MindControl.Results.IncompatiblePointerPathBitnessFailure.html": {
    "href": "api/MindControl.Results.IncompatiblePointerPathBitnessFailure.html",
    "title": "Class IncompatiblePointerPathBitnessFailure | MindControl",
    "summary": "Class IncompatiblePointerPathBitnessFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a path evaluation operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. public record IncompatiblePointerPathBitnessFailure : Failure, IEquatable<Failure>, IEquatable<IncompatiblePointerPathBitnessFailure> Inheritance object Failure IncompatiblePointerPathBitnessFailure Implements IEquatable<Failure> IEquatable<IncompatiblePointerPathBitnessFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors IncompatiblePointerPathBitnessFailure(nuint?) Represents a failure in a path evaluation operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. public IncompatiblePointerPathBitnessFailure(nuint? PreviousAddress = null) Parameters PreviousAddress nuint? Address where the value causing the issue was read. May be null if the first address in the path caused the failure. Properties PreviousAddress Address where the value causing the issue was read. May be null if the first address in the path caused the failure. public nuint? PreviousAddress { get; init; } Property Value nuint?"
  },
  "api/MindControl.Results.InsufficientSpaceFailure.html": {
    "href": "api/MindControl.Results.InsufficientSpaceFailure.html",
    "title": "Class InsufficientSpaceFailure | MindControl",
    "summary": "Class InsufficientSpaceFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory reservation operation when no space is available within the allocated memory range to reserve the specified size. public record InsufficientSpaceFailure : Failure, IEquatable<Failure>, IEquatable<InsufficientSpaceFailure> Inheritance object Failure InsufficientSpaceFailure Implements IEquatable<Failure> IEquatable<InsufficientSpaceFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InsufficientSpaceFailure() Represents a failure in a memory reservation operation when no space is available within the allocated memory range to reserve the specified size. public InsufficientSpaceFailure()"
  },
  "api/MindControl.Results.InvalidArgumentFailure.html": {
    "href": "api/MindControl.Results.InvalidArgumentFailure.html",
    "title": "Class InvalidArgumentFailure | MindControl",
    "summary": "Class InvalidArgumentFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in an operating system operation when the provided arguments are invalid. public record InvalidArgumentFailure : Failure, IEquatable<Failure>, IEquatable<InvalidArgumentFailure> Inheritance object Failure InvalidArgumentFailure Implements IEquatable<Failure> IEquatable<InvalidArgumentFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidArgumentFailure(string, string) Represents a failure in an operating system operation when the provided arguments are invalid. public InvalidArgumentFailure(string ArgumentName, string Message) Parameters ArgumentName string Name of the argument that caused the failure. Message string Message that describes how the argument fails to meet expectations. Properties ArgumentName Name of the argument that caused the failure. public string ArgumentName { get; init; } Property Value string"
  },
  "api/MindControl.Results.InvalidBytePatternFailure.html": {
    "href": "api/MindControl.Results.InvalidBytePatternFailure.html",
    "title": "Class InvalidBytePatternFailure | MindControl",
    "summary": "Class InvalidBytePatternFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure occurring when the provided byte search pattern is invalid. public record InvalidBytePatternFailure : Failure, IEquatable<Failure>, IEquatable<InvalidBytePatternFailure> Inheritance object Failure InvalidBytePatternFailure Implements IEquatable<Failure> IEquatable<InvalidBytePatternFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidBytePatternFailure(string) Represents a failure occurring when the provided byte search pattern is invalid. public InvalidBytePatternFailure(string Message) Parameters Message string Message that explains what makes the pattern invalid."
  },
  "api/MindControl.Results.InvalidStringSettingsFailure.html": {
    "href": "api/MindControl.Results.InvalidStringSettingsFailure.html",
    "title": "Class InvalidStringSettingsFailure | MindControl",
    "summary": "Class InvalidStringSettingsFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a string read operation when the settings provided are invalid. public record InvalidStringSettingsFailure : Failure, IEquatable<Failure>, IEquatable<InvalidStringSettingsFailure> Inheritance object Failure InvalidStringSettingsFailure Implements IEquatable<Failure> IEquatable<InvalidStringSettingsFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors InvalidStringSettingsFailure() Represents a failure in a string read operation when the settings provided are invalid. public InvalidStringSettingsFailure()"
  },
  "api/MindControl.Results.LibraryFileNotFoundFailure.html": {
    "href": "api/MindControl.Results.LibraryFileNotFoundFailure.html",
    "title": "Class LibraryFileNotFoundFailure | MindControl",
    "summary": "Class LibraryFileNotFoundFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a library injection operation when the library file to inject was not found. public record LibraryFileNotFoundFailure : Failure, IEquatable<Failure>, IEquatable<LibraryFileNotFoundFailure> Inheritance object Failure LibraryFileNotFoundFailure Implements IEquatable<Failure> IEquatable<LibraryFileNotFoundFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors LibraryFileNotFoundFailure(string) Represents a failure in a library injection operation when the library file to inject was not found. public LibraryFileNotFoundFailure(string LibraryPath) Parameters LibraryPath string Path to the library file that was not found. Properties LibraryPath Path to the library file that was not found. public string LibraryPath { get; init; } Property Value string"
  },
  "api/MindControl.Results.LibraryLoadFailure.html": {
    "href": "api/MindControl.Results.LibraryLoadFailure.html",
    "title": "Class LibraryLoadFailure | MindControl",
    "summary": "Class LibraryLoadFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a library injection operation when the library function call fails. public record LibraryLoadFailure : Failure, IEquatable<Failure>, IEquatable<LibraryLoadFailure> Inheritance object Failure LibraryLoadFailure Implements IEquatable<Failure> IEquatable<LibraryLoadFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors LibraryLoadFailure() Represents a failure in a library injection operation when the library function call fails. public LibraryLoadFailure()"
  },
  "api/MindControl.Results.LimitRangeOutOfBoundsFailure.html": {
    "href": "api/MindControl.Results.LimitRangeOutOfBoundsFailure.html",
    "title": "Class LimitRangeOutOfBoundsFailure | MindControl",
    "summary": "Class LimitRangeOutOfBoundsFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory allocation operation when the provided limit range is not within the bounds of the target process applicative memory range. public record LimitRangeOutOfBoundsFailure : Failure, IEquatable<Failure>, IEquatable<LimitRangeOutOfBoundsFailure> Inheritance object Failure LimitRangeOutOfBoundsFailure Implements IEquatable<Failure> IEquatable<LimitRangeOutOfBoundsFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors LimitRangeOutOfBoundsFailure(MemoryRange) Represents a failure in a memory allocation operation when the provided limit range is not within the bounds of the target process applicative memory range. public LimitRangeOutOfBoundsFailure(MemoryRange ApplicativeMemoryRange) Parameters ApplicativeMemoryRange MemoryRange Applicative memory range of the target process. Properties ApplicativeMemoryRange Applicative memory range of the target process. public MemoryRange ApplicativeMemoryRange { get; init; } Property Value MemoryRange"
  },
  "api/MindControl.Results.MemoryProtectionRemovalFailure.html": {
    "href": "api/MindControl.Results.MemoryProtectionRemovalFailure.html",
    "title": "Class MemoryProtectionRemovalFailure | MindControl",
    "summary": "Class MemoryProtectionRemovalFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory write operation when the system API call to remove the protection properties of the target memory space fails. public record MemoryProtectionRemovalFailure : Failure, IEquatable<Failure>, IEquatable<MemoryProtectionRemovalFailure> Inheritance object Failure MemoryProtectionRemovalFailure Implements IEquatable<Failure> IEquatable<MemoryProtectionRemovalFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors MemoryProtectionRemovalFailure(nuint, Failure) Represents a failure in a memory write operation when the system API call to remove the protection properties of the target memory space fails. public MemoryProtectionRemovalFailure(nuint Address, Failure Details) Parameters Address nuint Address where the operation failed. Details Failure A description of the inner failure. Properties Address Address where the operation failed. public nuint Address { get; init; } Property Value nuint Details A description of the inner failure. public Failure Details { get; init; } Property Value Failure"
  },
  "api/MindControl.Results.MemoryProtectionRestorationFailure.html": {
    "href": "api/MindControl.Results.MemoryProtectionRestorationFailure.html",
    "title": "Class MemoryProtectionRestorationFailure | MindControl",
    "summary": "Class MemoryProtectionRestorationFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory write operation when the system API call to restore the protection properties of the target memory space after writing fails. public record MemoryProtectionRestorationFailure : Failure, IEquatable<Failure>, IEquatable<MemoryProtectionRestorationFailure> Inheritance object Failure MemoryProtectionRestorationFailure Implements IEquatable<Failure> IEquatable<MemoryProtectionRestorationFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors MemoryProtectionRestorationFailure(nuint, Failure) Represents a failure in a memory write operation when the system API call to restore the protection properties of the target memory space after writing fails. public MemoryProtectionRestorationFailure(nuint Address, Failure Details) Parameters Address nuint Address where the operation failed. Details Failure Details about the failure. Properties Address Address where the operation failed. public nuint Address { get; init; } Property Value nuint Details Details about the failure. public Failure Details { get; init; } Property Value Failure"
  },
  "api/MindControl.Results.ModuleAlreadyLoadedFailure.html": {
    "href": "api/MindControl.Results.ModuleAlreadyLoadedFailure.html",
    "title": "Class ModuleAlreadyLoadedFailure | MindControl",
    "summary": "Class ModuleAlreadyLoadedFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a library injection operation when the module to inject is already loaded in the target process. public record ModuleAlreadyLoadedFailure : Failure, IEquatable<Failure>, IEquatable<ModuleAlreadyLoadedFailure> Inheritance object Failure ModuleAlreadyLoadedFailure Implements IEquatable<Failure> IEquatable<ModuleAlreadyLoadedFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ModuleAlreadyLoadedFailure() Represents a failure in a library injection operation when the module to inject is already loaded in the target process. public ModuleAlreadyLoadedFailure()"
  },
  "api/MindControl.Results.MultipleTargetProcessesFailure.html": {
    "href": "api/MindControl.Results.MultipleTargetProcessesFailure.html",
    "title": "Class MultipleTargetProcessesFailure | MindControl",
    "summary": "Class MultipleTargetProcessesFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a process attach operation when multiple processes with the given name were found. public record MultipleTargetProcessesFailure : Failure, IEquatable<Failure>, IEquatable<MultipleTargetProcessesFailure> Inheritance object Failure MultipleTargetProcessesFailure Implements IEquatable<Failure> IEquatable<MultipleTargetProcessesFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors MultipleTargetProcessesFailure(int[]) Represents a failure in a process attach operation when multiple processes with the given name were found. public MultipleTargetProcessesFailure(int[] Pids) Parameters Pids int[] Identifiers of running processes with the given name. Properties Pids Identifiers of running processes with the given name. public int[] Pids { get; init; } Property Value int[]"
  },
  "api/MindControl.Results.NoFreeMemoryFailure.html": {
    "href": "api/MindControl.Results.NoFreeMemoryFailure.html",
    "title": "Class NoFreeMemoryFailure | MindControl",
    "summary": "Class NoFreeMemoryFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory allocation operation when no free memory large enough to accomodate the specified size was found in the target process within the searched range. public record NoFreeMemoryFailure : Failure, IEquatable<Failure>, IEquatable<NoFreeMemoryFailure> Inheritance object Failure NoFreeMemoryFailure Implements IEquatable<Failure> IEquatable<NoFreeMemoryFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors NoFreeMemoryFailure(MemoryRange, nuint) Represents a failure in a memory allocation operation when no free memory large enough to accomodate the specified size was found in the target process within the searched range. public NoFreeMemoryFailure(MemoryRange SearchedRange, nuint LastRegionAddressSearched) Parameters SearchedRange MemoryRange Searched range in the target process. LastRegionAddressSearched nuint Last memory region address searched in the target process. Properties LastRegionAddressSearched Last memory region address searched in the target process. public nuint LastRegionAddressSearched { get; init; } Property Value nuint SearchedRange Searched range in the target process. public MemoryRange SearchedRange { get; init; } Property Value MemoryRange"
  },
  "api/MindControl.Results.NotSupportedFailure.html": {
    "href": "api/MindControl.Results.NotSupportedFailure.html",
    "title": "Class NotSupportedFailure | MindControl",
    "summary": "Class NotSupportedFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure when an operation is not supported. public record NotSupportedFailure : Failure, IEquatable<Failure>, IEquatable<NotSupportedFailure> Inheritance object Failure NotSupportedFailure Implements IEquatable<Failure> IEquatable<NotSupportedFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors NotSupportedFailure(string) Represents a failure when an operation is not supported. public NotSupportedFailure(string Message) Parameters Message string Message that describes why the operation is not supported."
  },
  "api/MindControl.Results.OperatingSystemCallFailure.html": {
    "href": "api/MindControl.Results.OperatingSystemCallFailure.html",
    "title": "Class OperatingSystemCallFailure | MindControl",
    "summary": "Class OperatingSystemCallFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a system API call. public record OperatingSystemCallFailure : Failure, IEquatable<Failure>, IEquatable<OperatingSystemCallFailure> Inheritance object Failure OperatingSystemCallFailure Implements IEquatable<Failure> IEquatable<OperatingSystemCallFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors OperatingSystemCallFailure(string, string, int, string) Represents a failure in a system API call. public OperatingSystemCallFailure(string SystemApiName, string TopLevelOperationName, int ErrorCode, string SystemMessage) Parameters SystemApiName string Name of the system API function that failed. TopLevelOperationName string Friendly name of the operation that was attempted. As multiple system API calls may be made to perform a single manipulation, this name is used to identify the broader operation that failed. ErrorCode int Numeric code that identifies the error. Typically provided by the operating system. SystemMessage string Message that describes the error, provided by the operating system. Properties ErrorCode Numeric code that identifies the error. Typically provided by the operating system. public int ErrorCode { get; init; } Property Value int SystemApiName Name of the system API function that failed. public string SystemApiName { get; init; } Property Value string SystemMessage Message that describes the error, provided by the operating system. public string SystemMessage { get; init; } Property Value string TopLevelOperationName Friendly name of the operation that was attempted. As multiple system API calls may be made to perform a single manipulation, this name is used to identify the broader operation that failed. public string TopLevelOperationName { get; init; } Property Value string"
  },
  "api/MindControl.Results.PointerOutOfRangeFailure.html": {
    "href": "api/MindControl.Results.PointerOutOfRangeFailure.html",
    "title": "Class PointerOutOfRangeFailure | MindControl",
    "summary": "Class PointerOutOfRangeFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a path evaluation operation when a pointer in the path is out of the target process address space. public record PointerOutOfRangeFailure : Failure, IEquatable<Failure>, IEquatable<PointerOutOfRangeFailure> Inheritance object Failure PointerOutOfRangeFailure Implements IEquatable<Failure> IEquatable<PointerOutOfRangeFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors PointerOutOfRangeFailure(nuint?, PointerOffset) Represents a failure in a path evaluation operation when a pointer in the path is out of the target process address space. public PointerOutOfRangeFailure(nuint? PreviousAddress, PointerOffset Offset) Parameters PreviousAddress nuint? Address that triggered the failure after the offset. May be null if the first address in the path caused the failure. Offset PointerOffset Offset that caused the failure. Properties Offset Offset that caused the failure. public PointerOffset Offset { get; init; } Property Value PointerOffset PreviousAddress Address that triggered the failure after the offset. May be null if the first address in the path caused the failure. public nuint? PreviousAddress { get; init; } Property Value nuint?"
  },
  "api/MindControl.Results.Result-1.html": {
    "href": "api/MindControl.Results.Result-1.html",
    "title": "Class Result<TResult> | MindControl",
    "summary": "Class Result<TResult> Namespace MindControl.Results Assembly MindControl.dll Represents the result of an operation that can either succeed or fail, with a result value in case of success. public class Result<TResult> : Result Type Parameters TResult Type of the result that can be returned in case of success. Inheritance object Result Result<TResult> Derived DisposableResult<TResult> Inherited Members Result.SuccessString Result.Success Result.Failure Result.IsSuccess Result.IsFailure Result.ThrowOnFailure() Result.ToException() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Result(Failure) Initializes a new failed Result<TResult> instance. protected Result(Failure failure) Parameters failure Failure A description of the failure. Result(TResult) Initializes a new successful Result<TResult> instance. protected Result(TResult value) Parameters value TResult Result of the operation. Properties Value Gets the resulting value of the operation. Throws if the operation was not successful. Use this after checking IsSuccess to ensure the operation was successful. public TResult Value { get; } Property Value TResult Methods CastValueFrom<TOtherResult>(Result<TOtherResult>) Builds a new Result<TResult> instance from a successful result with a different type. public static Result<TResult> CastValueFrom<TOtherResult>(Result<TOtherResult> result) where TOtherResult : TResult Parameters result Result<TOtherResult> Result to convert. Returns Result<TResult> A new Result<TResult> instance with the value of the input result. Type Parameters TOtherResult Type of the value of the result to convert. FailWith(Failure) Creates a new failed Result<TResult> instance. public static Result<TResult> FailWith(Failure failure) Parameters failure Failure A description of the failure. Returns Result<TResult> FromResult(TResult) Creates a new successful Result<TResult> instance. public static Result<TResult> FromResult(TResult result) Parameters result TResult Result of the operation. Returns Result<TResult> ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. ValueOr(TResult) Gets the resulting value of the operation, or the provided default value if the operation was not successful. public TResult ValueOr(TResult defaultValue) Parameters defaultValue TResult Default value to return if the operation was not successful. Returns TResult ValueOrDefault() Gets the resulting value of the operation, or the default value for the resulting type if the operation was not successful. public TResult? ValueOrDefault() Returns TResult Operators implicit operator Result<TResult>(Failure) Implicitly converts a failure to an unsuccessful Result<TResult> instance. public static implicit operator Result<TResult>(Failure failure) Parameters failure Failure Failure to convert. Returns Result<TResult> implicit operator Result<TResult>(TResult) Implicitly converts a result value to a successful Result<TResult> instance. public static implicit operator Result<TResult>(TResult result) Parameters result TResult Result value to convert. Returns Result<TResult>"
  },
  "api/MindControl.Results.Result.html": {
    "href": "api/MindControl.Results.Result.html",
    "title": "Class Result | MindControl",
    "summary": "Class Result Namespace MindControl.Results Assembly MindControl.dll Represents the result of an operation that can either succeed or fail. public class Result Inheritance object Result Derived Result<TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Result() Initializes a new successful Result instance. protected Result() Result(Failure) Initializes a new failed Result instance. protected Result(Failure failure) Parameters failure Failure A description of the failure. Fields Success Gets a successful Result instance. public static readonly Result Success Field Value Result SuccessString Default string representing a success. protected const string SuccessString = \"The operation was successful.\" Field Value string Properties Failure Gets the failure from an unsuccessful result. Throws if the operation was successful. Use this after checking IsFailure to ensure the operation was not successful. public Failure Failure { get; } Property Value Failure IsFailure Gets a boolean indicating if the operation was a failure. public bool IsFailure { get; } Property Value bool IsSuccess Gets a boolean indicating if the operation was successful. public bool IsSuccess { get; } Property Value bool Methods FailWith(Failure) Creates a new failed Result instance. public static Result FailWith(Failure failure) Parameters failure Failure A description of the failure. Returns Result ThrowOnFailure() Throws a ResultFailureException if the operation was not successful. public void ThrowOnFailure() ToException() Converts the result to an exception if it represents a failure. public ResultFailureException ToException() Returns ResultFailureException A new ResultFailureException instance if the operation was a failure. Exceptions InvalidOperationException Thrown if the operation was successful and thus cannot be converted to an exception. ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. Operators implicit operator Result(Failure) Implicitly converts a result value to a successful Result instance. public static implicit operator Result(Failure result) Parameters result Failure Result value to convert. Returns Result"
  },
  "api/MindControl.Results.ResultFailureException.html": {
    "href": "api/MindControl.Results.ResultFailureException.html",
    "title": "Class ResultFailureException | MindControl",
    "summary": "Class ResultFailureException Namespace MindControl.Results Assembly MindControl.dll Exception that may be thrown by failed Result. public class ResultFailureException : Exception, ISerializable Inheritance object Exception ResultFailureException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ResultFailureException(Failure, Exception?) Builds a ResultFailureException with the given details. public ResultFailureException(Failure failure, Exception? innerException = null) Parameters failure Failure Representation of the failure at the origin of the exception. innerException Exception Exception that is the cause of this exception, if any. Properties Failure Gets a representation of the failure at the origin of the exception. public Failure Failure { get; } Property Value Failure"
  },
  "api/MindControl.Results.StringTooLongFailure.html": {
    "href": "api/MindControl.Results.StringTooLongFailure.html",
    "title": "Class StringTooLongFailure | MindControl",
    "summary": "Class StringTooLongFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a string read operation when the string length prefix was evaluated to a value exceeding the configured max length, or a null terminator was not found within the configured max length. public record StringTooLongFailure : Failure, IEquatable<Failure>, IEquatable<StringTooLongFailure> Inheritance object Failure StringTooLongFailure Implements IEquatable<Failure> IEquatable<StringTooLongFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors StringTooLongFailure(ulong?) Represents a failure in a string read operation when the string length prefix was evaluated to a value exceeding the configured max length, or a null terminator was not found within the configured max length. public StringTooLongFailure(ulong? LengthPrefixValue) Parameters LengthPrefixValue ulong? Length read from the length prefix bytes, in case a length prefix was set. Properties LengthPrefixValue Length read from the length prefix bytes, in case a length prefix was set. public ulong? LengthPrefixValue { get; init; } Property Value ulong?"
  },
  "api/MindControl.Results.TargetProcessNotFoundFailure.html": {
    "href": "api/MindControl.Results.TargetProcessNotFoundFailure.html",
    "title": "Class TargetProcessNotFoundFailure | MindControl",
    "summary": "Class TargetProcessNotFoundFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a process attach operation when the target process could not be found. public record TargetProcessNotFoundFailure : Failure, IEquatable<Failure>, IEquatable<TargetProcessNotFoundFailure> Inheritance object Failure TargetProcessNotFoundFailure Implements IEquatable<Failure> IEquatable<TargetProcessNotFoundFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TargetProcessNotFoundFailure() Represents a failure in a process attach operation when the target process could not be found. public TargetProcessNotFoundFailure()"
  },
  "api/MindControl.Results.TargetProcessNotRunningFailure.html": {
    "href": "api/MindControl.Results.TargetProcessNotRunningFailure.html",
    "title": "Class TargetProcessNotRunningFailure | MindControl",
    "summary": "Class TargetProcessNotRunningFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a process attach operation when the target process is not running. public record TargetProcessNotRunningFailure : Failure, IEquatable<Failure>, IEquatable<TargetProcessNotRunningFailure> Inheritance object Failure TargetProcessNotRunningFailure Implements IEquatable<Failure> IEquatable<TargetProcessNotRunningFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TargetProcessNotRunningFailure() Represents a failure in a process attach operation when the target process is not running. public TargetProcessNotRunningFailure()"
  },
  "api/MindControl.Results.ThreadWaitAbandonedFailure.html": {
    "href": "api/MindControl.Results.ThreadWaitAbandonedFailure.html",
    "title": "Class ThreadWaitAbandonedFailure | MindControl",
    "summary": "Class ThreadWaitAbandonedFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a thread operation when a waiting operation was abandoned. public record ThreadWaitAbandonedFailure : Failure, IEquatable<Failure>, IEquatable<ThreadWaitAbandonedFailure> Inheritance object Failure ThreadWaitAbandonedFailure Implements IEquatable<Failure> IEquatable<ThreadWaitAbandonedFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ThreadWaitAbandonedFailure() Represents a failure in a thread operation when a waiting operation was abandoned. public ThreadWaitAbandonedFailure()"
  },
  "api/MindControl.Results.ThreadWaitTimeoutFailure.html": {
    "href": "api/MindControl.Results.ThreadWaitTimeoutFailure.html",
    "title": "Class ThreadWaitTimeoutFailure | MindControl",
    "summary": "Class ThreadWaitTimeoutFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a thread operation when the thread did not finish execution within the specified timeout. public record ThreadWaitTimeoutFailure : Failure, IEquatable<Failure>, IEquatable<ThreadWaitTimeoutFailure> Inheritance object Failure ThreadWaitTimeoutFailure Implements IEquatable<Failure> IEquatable<ThreadWaitTimeoutFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ThreadWaitTimeoutFailure() Represents a failure in a thread operation when the thread did not finish execution within the specified timeout. public ThreadWaitTimeoutFailure()"
  },
  "api/MindControl.Results.UndeterminedStringSettingsFailure.html": {
    "href": "api/MindControl.Results.UndeterminedStringSettingsFailure.html",
    "title": "Class UndeterminedStringSettingsFailure | MindControl",
    "summary": "Class UndeterminedStringSettingsFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a string settings search operation when no adequate settings were found to read the given string from the specified pointer. public record UndeterminedStringSettingsFailure : Failure, IEquatable<Failure>, IEquatable<UndeterminedStringSettingsFailure> Inheritance object Failure UndeterminedStringSettingsFailure Implements IEquatable<Failure> IEquatable<UndeterminedStringSettingsFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UndeterminedStringSettingsFailure() Represents a failure in a string settings search operation when no adequate settings were found to read the given string from the specified pointer. public UndeterminedStringSettingsFailure()"
  },
  "api/MindControl.Results.UnsupportedTypeReadFailure.html": {
    "href": "api/MindControl.Results.UnsupportedTypeReadFailure.html",
    "title": "Class UnsupportedTypeReadFailure | MindControl",
    "summary": "Class UnsupportedTypeReadFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory read operation when the type to read is not supported. public record UnsupportedTypeReadFailure : Failure, IEquatable<Failure>, IEquatable<UnsupportedTypeReadFailure> Inheritance object Failure UnsupportedTypeReadFailure Implements IEquatable<Failure> IEquatable<UnsupportedTypeReadFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsupportedTypeReadFailure(Type) Represents a failure in a memory read operation when the type to read is not supported. public UnsupportedTypeReadFailure(Type ProvidedType) Parameters ProvidedType Type Type that caused the failure. Properties ProvidedType Type that caused the failure. public Type ProvidedType { get; init; } Property Value Type"
  },
  "api/MindControl.Results.UnsupportedTypeWriteFailure.html": {
    "href": "api/MindControl.Results.UnsupportedTypeWriteFailure.html",
    "title": "Class UnsupportedTypeWriteFailure | MindControl",
    "summary": "Class UnsupportedTypeWriteFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure in a memory write operation when the value to write cannot be converted to an array of bytes. public record UnsupportedTypeWriteFailure : Failure, IEquatable<Failure>, IEquatable<UnsupportedTypeWriteFailure> Inheritance object Failure UnsupportedTypeWriteFailure Implements IEquatable<Failure> IEquatable<UnsupportedTypeWriteFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsupportedTypeWriteFailure(Type) Represents a failure in a memory write operation when the value to write cannot be converted to an array of bytes. public UnsupportedTypeWriteFailure(Type Type) Parameters Type Type Type that caused the failure. Properties Type Type that caused the failure. public Type Type { get; init; } Property Value Type"
  },
  "api/MindControl.Results.ZeroPointerFailure.html": {
    "href": "api/MindControl.Results.ZeroPointerFailure.html",
    "title": "Class ZeroPointerFailure | MindControl",
    "summary": "Class ZeroPointerFailure Namespace MindControl.Results Assembly MindControl.dll Represents a failure when a null pointer is accessed. public record ZeroPointerFailure : Failure, IEquatable<Failure>, IEquatable<ZeroPointerFailure> Inheritance object Failure ZeroPointerFailure Implements IEquatable<Failure> IEquatable<ZeroPointerFailure> Inherited Members Failure.Message Failure.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ZeroPointerFailure() Represents a failure when a null pointer is accessed. public ZeroPointerFailure()"
  },
  "api/MindControl.Results.html": {
    "href": "api/MindControl.Results.html",
    "title": "Namespace MindControl.Results | MindControl",
    "summary": "Namespace MindControl.Results Classes BaseModuleNotFoundFailure Represents a failure in a path evaluation operation when the base module specified in the pointer path was not found. CodeAssemblyFailure Represents a failure that occurred in a hook operation when instructions could not be assembled into a code block. CodeDecodingFailure Represents a failure that occurred while writing code to a target process when a disassembling operation failed. ConversionFailure Represents a failure in a memory read operation when trying to convert the bytes read from memory to the target type. ConversionWriteFailure Represents a failure in a memory write operation when trying to convert the value to write to an array of bytes to write in memory. DetachedProcessFailure Failure that occurs when the process is not attached. DisposableResult<TResult> Represents the result of an operation that can either succeed or fail, with a result value in case of success. This variant is disposable and may hold a disposable result. When a successful instance is disposed, the result will be too. DisposedAllocationFailure Represents a failure in a memory reservation operation when the target allocation has been disposed. DisposedThreadFailure Represents a failure in a thread operation when the thread handle has already been disposed. Failure Base class for failures. Can also be used directly when no specific failure type is needed. FunctionNotFoundFailure Represents a failure in a thread operation when the target function cannot be found. IncompatibleBitnessPointerFailure Represents a failure in a memory read operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. IncompatibleBitnessProcessFailure Represents a failure in a process attach operation when the target process is 64-bit and the current process is 32-bit. IncompatibleBitnessWriteFailure Represents a failure in a memory write operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. IncompatiblePointerPathBitnessFailure Represents a failure in a path evaluation operation when the target process is 32-bit, but the target memory address is not within the 32-bit address space. InsufficientSpaceFailure Represents a failure in a memory reservation operation when no space is available within the allocated memory range to reserve the specified size. InvalidArgumentFailure Represents a failure in an operating system operation when the provided arguments are invalid. InvalidBytePatternFailure Represents a failure occurring when the provided byte search pattern is invalid. InvalidStringSettingsFailure Represents a failure in a string read operation when the settings provided are invalid. LibraryFileNotFoundFailure Represents a failure in a library injection operation when the library file to inject was not found. LibraryLoadFailure Represents a failure in a library injection operation when the library function call fails. LimitRangeOutOfBoundsFailure Represents a failure in a memory allocation operation when the provided limit range is not within the bounds of the target process applicative memory range. MemoryProtectionRemovalFailure Represents a failure in a memory write operation when the system API call to remove the protection properties of the target memory space fails. MemoryProtectionRestorationFailure Represents a failure in a memory write operation when the system API call to restore the protection properties of the target memory space after writing fails. ModuleAlreadyLoadedFailure Represents a failure in a library injection operation when the module to inject is already loaded in the target process. MultipleTargetProcessesFailure Represents a failure in a process attach operation when multiple processes with the given name were found. NoFreeMemoryFailure Represents a failure in a memory allocation operation when no free memory large enough to accomodate the specified size was found in the target process within the searched range. NotSupportedFailure Represents a failure when an operation is not supported. OperatingSystemCallFailure Represents a failure in a system API call. PointerOutOfRangeFailure Represents a failure in a path evaluation operation when a pointer in the path is out of the target process address space. Result Represents the result of an operation that can either succeed or fail. ResultFailureException Exception that may be thrown by failed Result. Result<TResult> Represents the result of an operation that can either succeed or fail, with a result value in case of success. StringTooLongFailure Represents a failure in a string read operation when the string length prefix was evaluated to a value exceeding the configured max length, or a null terminator was not found within the configured max length. TargetProcessNotFoundFailure Represents a failure in a process attach operation when the target process could not be found. TargetProcessNotRunningFailure Represents a failure in a process attach operation when the target process is not running. ThreadWaitAbandonedFailure Represents a failure in a thread operation when a waiting operation was abandoned. ThreadWaitTimeoutFailure Represents a failure in a thread operation when the thread did not finish execution within the specified timeout. UndeterminedStringSettingsFailure Represents a failure in a string settings search operation when no adequate settings were found to read the given string from the specified pointer. UnsupportedTypeReadFailure Represents a failure in a memory read operation when the type to read is not supported. UnsupportedTypeWriteFailure Represents a failure in a memory write operation when the value to write cannot be converted to an array of bytes. ZeroPointerFailure Represents a failure when a null pointer is accessed. Enums HookCodeAssemblySource Enumerates potential blocks for a CodeAssemblyFailure."
  },
  "api/MindControl.State.ExceptionEventArgs.html": {
    "href": "api/MindControl.State.ExceptionEventArgs.html",
    "title": "Class ExceptionEventArgs | MindControl",
    "summary": "Class ExceptionEventArgs Namespace MindControl.State Assembly MindControl.dll Event arguments for an exception. public class ExceptionEventArgs Inheritance object ExceptionEventArgs Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ExceptionEventArgs(Exception) Builds a ExceptionEventArgs with the given properties. public ExceptionEventArgs(Exception exception) Parameters exception Exception Exception related to the event. Properties Exception Gets the underlying exception. public Exception Exception { get; } Property Value Exception"
  },
  "api/MindControl.State.IStateTimer.html": {
    "href": "api/MindControl.State.IStateTimer.html",
    "title": "Interface IStateTimer | MindControl",
    "summary": "Interface IStateTimer Namespace MindControl.State Assembly MindControl.dll Provides a common interface for timers that can tick on their own but also be forced to tick manually. public interface IStateTimer Properties Interval Gets or sets the interval between two automatic ticks. TimeSpan Interval { get; set; } Property Value TimeSpan IsRunning Gets a value indicating if the timer is currently running. bool IsRunning { get; } Property Value bool Methods ForceTick() Manually triggers a tick. void ForceTick() Start() Starts the timer. void Start() Stop() Stops the timer. void Stop() Events Tick Event triggered when the timer ticks, either automatically or manually. event EventHandler? Tick Event Type EventHandler"
  },
  "api/MindControl.State.PrecisionTimer.html": {
    "href": "api/MindControl.State.PrecisionTimer.html",
    "title": "Class PrecisionTimer | MindControl",
    "summary": "Class PrecisionTimer Namespace MindControl.State Assembly MindControl.dll High precision non-overlapping timer. public class PrecisionTimer : IStateTimer Inheritance object PrecisionTimer Implements IStateTimer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PrecisionTimer(TimeSpan) Builds a PrecisionTimer with the given properties. public PrecisionTimer(TimeSpan interval) Parameters interval TimeSpan Interval between two automatic ticks Properties Interval Gets or sets the interval between two automatic ticks. public TimeSpan Interval { get; set; } Property Value TimeSpan IsRunning Gets or sets a value indicating if the timer is currently running. public bool IsRunning { get; } Property Value bool RestartThreshold Gets or sets the max duration of a stopwatch before it is restarted. This setting helps prevent precision problems when the stopwatch has been running for too long. The default value is one hour. public TimeSpan? RestartThreshold { get; set; } Property Value TimeSpan? UseHighPriorityThread If true, sets the execution thread to ThreadPriority.Highest (applies at the next start). This setting might improve performance in some cases, but might cause issues in other cases. public bool UseHighPriorityThread { get; set; } Property Value bool Methods ForceTick() Manually triggers a tick. public void ForceTick() Start() Starts the timer. public void Start() Stop() Stops the timer. public void Stop() Events Tick Invoked when the timer is elapsed public event EventHandler? Tick Event Type EventHandler"
  },
  "api/MindControl.State.StateEventArgs-1.html": {
    "href": "api/MindControl.State.StateEventArgs-1.html",
    "title": "Class StateEventArgs<T> | MindControl",
    "summary": "Class StateEventArgs<T> Namespace MindControl.State Assembly MindControl.dll Event arguments for events related to arbitrary process states. public class StateEventArgs<T> : EventArgs Type Parameters T Inheritance object EventArgs StateEventArgs<T> Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StateEventArgs(T) Builds a StateEventArgs<T> with the given properties. public StateEventArgs(T state) Parameters state T State related to the event. Properties State Gets the underlying state. public T State { get; } Property Value T"
  },
  "api/MindControl.State.StateWatcher-1.html": {
    "href": "api/MindControl.State.StateWatcher-1.html",
    "title": "Class StateWatcher<T> | MindControl",
    "summary": "Class StateWatcher<T> Namespace MindControl.State Assembly MindControl.dll An abstract watcher that provides a periodically refreshed state. Inherit this class to track the state of your target process in real time. public abstract class StateWatcher<T> Type Parameters T Type of the state. Inheritance object StateWatcher<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StateWatcher(IStateTimer) Builds a state watcher that updates the state automatically at every tick of the given timer. protected StateWatcher(IStateTimer timer) Parameters timer IStateTimer Timer to use to trigger state updates. StateWatcher(float) Builds a state watcher that updates the state automatically as many times as specified per second. protected StateWatcher(float targetUpdatesPerSecond) Parameters targetUpdatesPerSecond float Target number of times per second the watcher should update the state. Note that the actual number of updates per second might differ because of timer precision and overlapping updates. StateWatcher(TimeSpan) Builds a state watcher that updates the state automatically with a given time interval. protected StateWatcher(TimeSpan updateInterval) Parameters updateInterval TimeSpan Target interval between two state updates. Note that the actual number of updates per second might differ because of timer precision and overlapping updates. Properties Interval Gets or sets the target interval between two automatic state updates. Note that the actual number of updates per second might differ because of timer precision and overlapping updates. public TimeSpan Interval { get; set; } Property Value TimeSpan IsRunning Gets a value indicating if this watcher is automatically refreshing state. public bool IsRunning { get; } Property Value bool LatestException Gets the last exception raised while attempting to read the state. public Exception? LatestException { get; protected set; } Property Value Exception LatestExceptionTime Gets the time of the last exception raised while attempting to read the state. public DateTime? LatestExceptionTime { get; protected set; } Property Value DateTime? LatestState Gets the state read from the last successful update. public T? LatestState { get; protected set; } Property Value T LatestUpdateTime Gets the time of the last successful update. public DateTime? LatestUpdateTime { get; protected set; } Property Value DateTime? Methods OnAfterUpdate(T?, T) Performs actions after the update. protected virtual void OnAfterUpdate(T? previousState, T newState) Parameters previousState T Previous state, before the update occurred. newState T State that was just read. Provided for convenience, but should be the same as the latest state of this instance. OnBeforeUpdate(T?, T) Performs actions in-between getting a new state and raising the StateUpdated event. protected virtual void OnBeforeUpdate(T? previousState, T newState) Parameters previousState T Previous state, before the update. newState T State that was just read. Provided for convenience, but should be the same as the latest state of this instance. ReadState() Reads the current state, as watched by this instance. protected abstract T ReadState() Returns T Start() Starts automatically refreshing state. public void Start() Stop() Stops automatically refreshing state. public void Stop() UpdateState() Performs a state update. This method is automatically called at regular intervals when the watcher is running. public void UpdateState() Events StateUpdateFailed Event triggered when a state update fails. public event EventHandler<ExceptionEventArgs>? StateUpdateFailed Event Type EventHandler<ExceptionEventArgs> StateUpdateSkipped Event triggered when a state update is skipped because another update is still in progress. public event EventHandler? StateUpdateSkipped Event Type EventHandler StateUpdated Event triggered after the state is updated. public event EventHandler<StateEventArgs<T>>? StateUpdated Event Type EventHandler<StateEventArgs<T>>"
  },
  "api/MindControl.State.ThreadingTimer.html": {
    "href": "api/MindControl.State.ThreadingTimer.html",
    "title": "Class ThreadingTimer | MindControl",
    "summary": "Class ThreadingTimer Namespace MindControl.State Assembly MindControl.dll Timer based on Timer. public class ThreadingTimer : IStateTimer Inheritance object ThreadingTimer Implements IStateTimer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ThreadingTimer(TimeSpan) Builds a ThreadingTimer with the given properties. public ThreadingTimer(TimeSpan interval) Parameters interval TimeSpan Interval between two automatic ticks. Properties Interval Gets or sets the interval between two automatic ticks. public TimeSpan Interval { get; set; } Property Value TimeSpan IsRunning Gets or sets a value indicating if the timer is currently running. public bool IsRunning { get; } Property Value bool Methods ForceTick() Manually triggers a tick. public void ForceTick() Start() Starts the timer, if it is not already running. public void Start() Stop() Stops the timer, if it was running. public void Stop() Events Tick Event triggered when the timer ticks, either automatically or manually. public event EventHandler? Tick Event Type EventHandler"
  },
  "api/MindControl.State.html": {
    "href": "api/MindControl.State.html",
    "title": "Namespace MindControl.State | MindControl",
    "summary": "Namespace MindControl.State Classes ExceptionEventArgs Event arguments for an exception. PrecisionTimer High precision non-overlapping timer. StateEventArgs<T> Event arguments for events related to arbitrary process states. StateWatcher<T> An abstract watcher that provides a periodically refreshed state. Inherit this class to track the state of your target process in real time. ThreadingTimer Timer based on Timer. Interfaces IStateTimer Provides a common interface for timers that can tick on their own but also be forced to tick manually."
  },
  "api/MindControl.StringLengthPrefix.html": {
    "href": "api/MindControl.StringLengthPrefix.html",
    "title": "Class StringLengthPrefix | MindControl",
    "summary": "Class StringLengthPrefix Namespace MindControl Assembly MindControl.dll Defines settings about the prefix that holds the length of a string. public class StringLengthPrefix Inheritance object StringLengthPrefix Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StringLengthPrefix(int, StringLengthUnit) Builds length prefix settings with the given properties. public StringLengthPrefix(int size, StringLengthUnit unit) Parameters size int Number of bytes storing the length of the string. unit StringLengthUnit What the length prefix counts. Properties Size Gets or sets the number of bytes storing the length of the string. public int Size { get; } Property Value int Unit Gets or sets what the length prefix counts. public StringLengthUnit Unit { get; } Property Value StringLengthUnit"
  },
  "api/MindControl.StringLengthUnit.html": {
    "href": "api/MindControl.StringLengthUnit.html",
    "title": "Enum StringLengthUnit | MindControl",
    "summary": "Enum StringLengthUnit Namespace MindControl Assembly MindControl.dll Defines what is counted by a string length prefix. public enum StringLengthUnit Fields Bytes = 1 The length prefix is a count of bytes. Characters = 0 The length prefix is a count of characters."
  },
  "api/MindControl.StringSettings.html": {
    "href": "api/MindControl.StringSettings.html",
    "title": "Class StringSettings | MindControl",
    "summary": "Class StringSettings Namespace MindControl Assembly MindControl.dll Defines how strings are read and written in a process' memory. public class StringSettings Inheritance object StringSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StringSettings(Encoding, bool, StringLengthPrefix?, byte[]?) Builds settings with the given properties. If you are unsure what settings to use, consider using FindStringSettings(nuint, string) if possible to automatically determine the appropriate settings for a known string pointer. public StringSettings(Encoding encoding, bool isNullTerminated = true, StringLengthPrefix? lengthPrefix = null, byte[]? typePrefix = null) Parameters encoding Encoding Encoding of the strings. isNullTerminated bool Boolean indicating if strings should have a \\0 delimitation character at the end. The default value is true. lengthPrefix StringLengthPrefix Length prefix settings. If null, strings are considered to have no length prefix. The default value is null. typePrefix byte[] Optional prefix that comes before the string bytes. This is useful for type pointers in frameworks that use them. If the string also has a length prefix, the type prefix comes first, before the length. The default value is null. Fields DefaultMaxLength Default value for MaxLength. public const int DefaultMaxLength = 1024 Field Value int Properties Encoding Gets or sets the encoding of the strings. public Encoding Encoding { get; set; } Property Value Encoding IsNullTerminated Gets or sets a boolean indicating if strings should have a \\0 delimitation character at the end. public bool IsNullTerminated { get; set; } Property Value bool IsValid Gets a boolean indicating if the settings are valid. public bool IsValid { get; } Property Value bool LengthPrefix Gets or sets the length prefix settings. If null, strings are considered to have no length prefix. public StringLengthPrefix? LengthPrefix { get; set; } Property Value StringLengthPrefix MaxLength Gets or sets the maximum length of the strings that can be read with this instance. When reading strings, if the length of the string is evaluated to a value exceeding the maximum, the read operation will be aborted and fail to prevent reading unexpected data. The unit of this value depends on the LengthPrefix settings. If no length prefix is used, the unit used is the number of characters in the string. The default value is defined by the DefaultMaxLength constant. public int MaxLength { get; set; } Property Value int TypePrefix Gets or sets an optional prefix that comes before the string bytes. This is useful for type pointers in frameworks that use them. If the string also has a length prefix, the type prefix comes first, before the length. public byte[]? TypePrefix { get; set; } Property Value byte[] Methods GetByteCount(string) Gets the number of bytes that a specific string would occupy in memory with these settings. public int GetByteCount(string value) Parameters value string String to measure. Returns int The number of bytes that the string would occupy in memory. GetBytes(string) Converts the given string into a byte array using these settings. May fail and return null when using a length prefix that is too small to represent the string. public byte[]? GetBytes(string value) Parameters value string String to convert. Returns byte[] The byte array representing the string, or null if the string is too long to be represented with the length prefix setting. GetMaxByteLength(int) Computes the number of bytes to read when reading a string with these settings, given a maximum string length. public int GetMaxByteLength(int maxStringLength) Parameters maxStringLength int Maximum length of the string to read. Returns int The number of bytes to read. GetString(Span<byte>) Attempts to read a string from the given bytes with this settings instance. public string? GetString(Span<byte> bytes) Parameters bytes Span<byte> Bytes to read the string from. Returns string The string read from the bytes, or null if the string could not be read. Remarks This method ignores the MaxLength constraint, because the full span of bytes is already provided as a parameter. ThrowIfInvalid() Throws an exception if the settings are invalid. protected void ThrowIfInvalid() Exceptions InvalidOperationException Thrown when the settings are not valid."
  },
  "api/MindControl.Threading.RemoteThread.html": {
    "href": "api/MindControl.Threading.RemoteThread.html",
    "title": "Class RemoteThread | MindControl",
    "summary": "Class RemoteThread Namespace MindControl.Threading Assembly MindControl.dll Represents an awaitable thread running an operation in another process. public class RemoteThread : IDisposable Inheritance object RemoteThread Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsDisposed Gets a value indicating whether the thread has been disposed. protected bool IsDisposed { get; } Property Value bool Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public virtual void Dispose() WaitForCompletion(TimeSpan) Synchronously waits for the thread to finish execution and returns its exit code. public Result<uint> WaitForCompletion(TimeSpan timeout) Parameters timeout TimeSpan Maximum time to wait for the thread to finish execution. If the duration is exceeded, the result will hold a ThreadWaitTimeoutFailure instance. Returns Result<uint> A result holding either the exit code of the thread, or a failure. WaitForCompletionAsync(TimeSpan) Asynchronously waits for the thread to finish execution and returns its exit code. This method is just an asynchronous wrapper around WaitForCompletion(TimeSpan). public Task<Result<uint>> WaitForCompletionAsync(TimeSpan timeout) Parameters timeout TimeSpan Maximum time to wait for the thread to finish execution. If the duration is exceeded, the result will contain a ThreadWaitTimeoutFailure error. Returns Task<Result<uint>> A result holding either the exit code of the thread, or a failure."
  },
  "api/MindControl.Threading.html": {
    "href": "api/MindControl.Threading.html",
    "title": "Namespace MindControl.Threading | MindControl",
    "summary": "Namespace MindControl.Threading Classes RemoteThread Represents an awaitable thread running an operation in another process."
  },
  "api/MindControl.html": {
    "href": "api/MindControl.html",
    "title": "Namespace MindControl | MindControl",
    "summary": "Namespace MindControl Classes AssemblerExtensions Provides extension methods around code assembling. ByteSearchPattern Represents a pattern of bytes to search for in memory. FindBytesSettings Settings for the FindBytes method. LiteralAddressResolver Provides a way to resolve an address in the target process. This implementation takes a literal address and always resolves to that same address. MemoryAllocation Represents a range of memory that has been allocated in a process. Can be used to safely manage data or code storage using reservations. MemoryReservation Represents a reservation of a range of memory within a MemoryAllocation. Reservations within an allocation cannot overlap and thus can be used to safely manage data or code storage over a process. Disposing a reservation will free the memory range for other uses. PointerExtensions Provides extension methods for pointers. PointerPath Holds a string expression consisting in a base address followed by a sequence of pointer offsets. Allows programs to consistently retrieve data in the process memory by following pointers to reach a dynamic address. A pointer path instance can be reused to optimize performance, as it is only parsed once, when constructed. PointerPathResolver Provides a way to resolve an address in the target process. This implementation takes a pointer path and resolves it to an address in the target process. ProcessMemory Provides methods to manipulate the memory of a process. ProcessMemoryStream A stream that reads or writes into the memory of a process. ProcessTracker Provides a ProcessMemory for a process identified by its name. The tracker is able to re-attach to a process with the same name after it has been closed and reopened. StringLengthPrefix Defines settings about the prefix that holds the length of a string. StringSettings Defines how strings are read and written in a process' memory. Structs MemoryRange Represents a range of memory addresses in a process. PointerOffset Describes a pointer offset as part of a PointerPath. Effectively, this is a number ranging from -0xFFFFFFFFFFFFFFFF to 0xFFFFFFFFFFFFFFFF. Interfaces IAddressResolver Provides a way to resolve an address in the target process. Enums MemoryProtectionStrategy Enumerates potential strategies to deal with memory protection. RangeAlignmentMode Defines a byte alignment mode for memory ranges. StringLengthUnit Defines what is counted by a string length prefix."
  },
  "guide/guide-requirements.html": {
    "href": "guide/guide-requirements.html",
    "title": "Requirements | MindControl",
    "summary": "Requirements This section details what you are going to need to follow this guide. If you are already familiar with memory hacking and just want to learn about MindControl features, you can skip over to the Project setup section. Grab the test game Throughout the guide, we are going to always use the same target program, so that you can follow along by repeating the same steps. That target program is going to be the demo of a game called Slime Rancher, from the independent studio Monomi Park. It's a fun first-person adventure game about capturing wild monsters called slimes and making money with resources harvested from them. It's available on Steam. You can download the demo for free on the Steam store page. Make sure to use the free demo version, even if you have the full game, so that the exact same steps shown in this guide work for you. The demo is a little bit outdated compared to the full game, is limited in time and doesn't save your progress, but fits our needs perfectly and is still enjoyable. As an aside, if you happen to enjoy the demo, consider buying the full game to have some fun and support the team behind it. Also check out the sequel, Slime Rancher 2. Install Cheat Engine Cheat Engine is a popular memory hacking tool that allows you to inspect and manipulate the memory of a running process. It's a great tool to learn about memory hacking, and it's also useful to complement MindControl, as it provides a set of tools to inspect memory, and lots more. You can download the latest Cheat Engine installer from its official website. The installer is safe to use, but has bundled software offers during the installation process. Make sure to decline these if you don't want them. Setting up the game Before continuing further in the guide, make sure you boot up the game, start a new game, and clear the tutorial to understand how the game works. It should only take a couple of minutes, at most. When you're done, in the game settings, you can turn off tutorials for the next times you'll boot up the game. It's also recommended to set the game in windowed mode, as we will be switching between the game and Cheat Engine a lot. Next step The next section will be about setting up Cheat Engine and exploring basic memory concepts."
  },
  "guide/hacking-basics/basic-memory-concepts.html": {
    "href": "guide/hacking-basics/basic-memory-concepts.html",
    "title": "Basic memory concepts | MindControl",
    "summary": "Basic memory concepts This section is intended to cover some fundamental concepts about memory hacking. If you are already familiar with memory hacking, you can skip ahead to the Project setup section. Memory and structures As previously stated, a program is loaded into memory when it runs. This means that all the data it needs to operate is stored in memory, as a series of numeric values. These numeric values can be just numbers, like a character's health points value, but when grouped together, they can be text, pictures, audio, code instructions, or anything else. The way the data is organized is defined by how the program is written and compiled. An example of a small portion of memory shown in a memory viewer. A structure is a set of related variables that are grouped together in a set. Each variable in the structure is called a member. Structures can be nested, meaning that a member of a structure can be another structure. If you think about it in terms of object-oriented programming, a structure is like a class, and a member is like a field. To give a few examples, in a game, you could have a structure that represents the player's character. This structure could have members for the player's health, position, speed, and so on. You could imagine other structures that represent the game world, weapons, enemies, animations, etc. An extremely simplified example of structures in a game. This is not an accurate representation of any game, just an example. All the structures that are relevant to the state of the game are stored in memory, and the game itself uses that memory to operate. If we manage to identify these values, we can observe and manipulate them. For example, if you were to change the player's health value, you would see the player's health bar change instantly (in most cases). Unless it specifically has cheat protection, the game would have no clue that you changed the value, as it would just read the health value from memory like it does at every frame to update the health bar accordingly. The trouble is that we don't know where in memory these structures are stored, how they are arranged, and most often, what structures are defined. This is where tools like Cheat Engine come in handy. Attaching to the process with Cheat Engine If we start the Slime Rancher demo, and then open Cheat Engine, we can attach Cheat Engine to the game process. This will allow us to inspect the memory of the game. Attaching Cheat Engine to the game process: click the \"Select a process to open\" button in the top-left action icon row, and then pick the process running the game. Note This is not the case for Slime Rancher, but sometimes, your target can have multiple processes. The correct one to pick is usually the one with the highest memory usage (check in the Task Manager). You can also use the \"Windows\" tab in the Cheat Engine process list to find the process handling the main window, which is the correct one in most cases. Memory viewer and addresses Clicking the \"Memory View\" button above the bottom panel will open the memory viewer window. This window allows you to visualize both the memory and the decoded instructions of the game code. The Memory viewer window: The top-most panel, highlighted in green, shows the disassembled (decoded) instructions of the game code. The bottom panel, highlighted in orange and blue, shows the memory contents. Let's focus on the left part of the memory viewer panel for now (the part highlighted in orange in the screenshot shown above). It shows the memory as a series of hexadecimal numbers that range from 00 to FF (255). And as you can see, there are lots and lots of these numbers. You can keep scrolling pretty much forever. This is because each of these numbers is a byte, and this game, like most 3D games, has well over a gigabyte of memory, which means over a billion bytes. On the leftmost part of the panel, you will notice hexadecimal numbers ranging from 00000000 to 7FFFFFFF. These are the memory addresses. Each byte in memory has an address. If we think of the process memory as an immense locker room, the memory addresses are the locker numbers, and the bytes are what we store in the lockers. The address on the left of the panel is the address of the leftmost byte in the matching row. If you select a byte by clicking on it, you will see the address of that byte in the bottom-left corner of the window. Memory addresses are a key concept in memory hacking. Whenever we want to read or write to a specific memory location, we need to know its address. This is why memory hacking tools like Cheat Engine will always show the addresses of everything you inspect. Values and types So, each byte that you can see in the memory viewer represents a value between 0 and 255. But what if we want to store a bigger number, like 123456? We can't do that with a single byte. Well, if you group multiple adjacent bytes together, you can store bigger numbers. For example, if you group four bytes together, you can store a number between 0 and 4294967295. This notion of grouping bytes together to store more than just a small value is called a data type. A data type is a way to define how many bytes are used to store a value, and how that value is interpreted. For example, a short integer is a data type that uses two bytes to store a whole number. A floating-point number (or \"float\") is a data type that uses four bytes to store a decimal number. A string is a data type that uses multiple bytes to store a sequence of characters that form a text. An illustration showing the same bytes interpreted into different types. If you select a byte in the memory viewer, below the memory panel, Cheat Engine will display the base-10 value of the byte, but also its value when grouped together with the following bytes, interpreted as some of the most used data types. This is useful when trying to understand if the byte is the start of a field with a bigger type. Next step Now that we have covered some basic memory concepts, the next section will be about searching for specific values in memory using Cheat Engine."
  },
  "guide/hacking-basics/code-manipulation.html": {
    "href": "guide/hacking-basics/code-manipulation.html",
    "title": "Code manipulation | MindControl",
    "summary": "Code manipulation In this section, we are going to manipulate the code instructions of our target program. This is a slightly more advanced topic, but we will keep things simple. Code instructions in memory As stated in the previous section, a program is loaded into memory when it runs. This means that the code that the program executes is stored in memory, as a series of instructions. We have seen before that these Assembly instructions are represented with a short mnemonic, followed by a list of operands. For example, the instruction MOV EAX, 0x12345678 moves the value 0x12345678 into the EAX register. But these instructions are not stored as text in memory. They are stored as binary values, where each value represents a different instruction. The CPU reads these values and executes the corresponding instruction. These numeric values are called opcodes. For example, the ADD EAX, 0x11BB22CC instruction, which means \"add the value 0x11BB22CC to the EAX register\", is written as 05 CC 22 BB 11 in memory. The 05 opcode tells the CPU that this is an ADD instruction with EAX as the first operand, and the following bytes are the value, in little-endian (in reverse). This means that, if we rewrite instructions in the memory of a running process, we can change the behavior of the program. Locating code instructions Even when you know assembly, reading and understanding the whole code of a program would take ages, because there are lots of instructions, which are all very basic, and not very informative by themselves. So, if we want to modify parts of the code, we need to know where to look. Let's take a quick example. In the Slime Rancher demo, running uses up your stamina, and so you cannot run forever. The first thing that we are going to do is to modify the behaviour of the game so that running does not consume stamina anymore. To do that, we need to find the code that decreases the stamina value when running. But we don't know what this code looks like (what registers it uses, what values it compares, etc.). To find this code, we first need to find out the address of the stamina value in memory. We've already covered how to do so in the \"Finding values with Cheat Engine\" section of this guide. Here are some more hints: Like most values that are displayed in gauges or bars in games, the stamina value is a float You can sprint and then pause the game to freeze the value while you are scanning for it The number you see in-game is rounded, so it's better to use the Value between... scan type instead of exact values. For example, if you see 72, search for values between 71 and 73. Remark: Once you have found the stamina value, notice how it relates to the coin count. They are very close together. It's likely that they are part of the same structure. You can even duplicate the coin count pointer path and replace the +80 offset with a +74 offset to get a stable pointer path to the stamina value. Tip If you cannot find the stamina value and still want to go further, just subtract 0xC from the coin count address. Once we have the address of the stamina value, we are going to use a tool that we've already covered before: the \"Find out what writes to this address\" feature of Cheat Engine. This feature will show us the code that writes to the stamina value in memory. This is likely to lead to the code that decreases the stamina value when running. This opens a window you should already be familiar with, showing the instructions that write to the stamina address. If you go back to the game, without even sprinting, you should see an instruction being called over and over again (probably each frame). This should be movss [rax+74],xmm5. However, we will disregard this instruction, because, when we start sprinting, we see another entry appear in the list. Because that second one only appears when we sprint, we can suppose that it's the instruction that decreases the stamina value when you are sprinting, and so that's the one we are looking for. So that second instruction should be movss [rsi+74],xmm5. Select this one and click the \"Show disassembler\" button. This will open the memory view window and show you the disassembled code around this instruction. The first line highlighted in blue is the instruction that writes to the stamina address. The next lines are the instructions that are executed afterward. Removing code instructions Now that we have located the instruction, let's try modifying it. Our goal is to prevent stamina from decreasing. In theory, this can be done by just removing the instruction that writes to the stamina value. If nothing writes there, stamina won't go down. In practice, the convenient way to do that is to replace the target instruction with NOP instructions. NOP is an assembly instruction that does nothing. It's just a placeholder that takes up space in the code. Its bytecode is 0x90, so it only takes up one byte. To fully replace our instruction, we need to replace the 5 bytes taken by the original movss instruction with 5 NOP instructions. This procedure is actually pretty common, and thus Cheat Engine has a tool for it. Just right-click the instruction you want to replace, and select \"Replace with code that does nothing\". Once you click \"Replace with code that does nothing\", you should see five NOP instructions instead of the original movss instruction. Now, go back to the game and start sprinting. You should see that your stamina does not decrease anymore, and you can sprint forever. Congratulations, you've successfully manipulated the code of the game! Injecting code instructions Deactivating instructions was simple enough. But let's say that instead of disabling a behaviour, we want to modify something. For example, let's say we want to multiply the coins we gain by selling plorts by 10. This is a more complex scenario, because we need to add instructions instead of just removing them. The problem with adding new instructions is that we cannot insert them in the middle of the code. The code is already written in memory, and we cannot just shift it around. If we were to overwrite the existing opcodes, we would write over the next instructions, and the program would probably crash. The best way to insert code is through a trampoline hook, which, as dumb as it sounds, actually makes sense when you know how it works. The idea is to: Write the new instructions in an unused memory location Replace the target instruction with a JMP instruction that jumps (redirects) to the new instructions At the end of the new instructions, add a JMP instruction that jumps back to the original code This normally involves a lot of work (finding or allocating a memory location, writing the new instructions, writing the trampoline with instructions that depend on the distance to the new code, etc.), but Cheat Engine has a tool that simplifies this process. For now, let's find the instruction that adds the coins when selling plorts, using the same technique as before: use \"Find out what writes to this address\" on the coin count address (because we now have a pointer path, Cheat Engine will ask if we want to use the pointer or the address. Pick the \"Find what writes the address pointed at by this pointer\" option), and look for the instruction that writes to the coin count when you sell plorts. The instruction should be mov [rax+80],ecx. It writes the value of the ecx register to the coin count address. This means that ecx holds the new coin count value. If we use the \"Show disassembler\" button, we should see the instructions around this one. The previous instruction in particular is add ecx,edi, which adds the value of the edi register to the ecx register. This is the instruction that adds the coins when selling plorts. When reaching the add instruction, the edi register should hold the value of the plort price. This is the value that we want to multiply by 10. So, we need to insert an instruction that multiplies the edi register by 10 before the add instruction. To perform the code injection in Cheat Engine, select the add instruction, and then in the Tools menu, pick \"Auto Assemble\". This will open a window where you can write the new instructions. In that new window, in the \"Template\" menu, pick \"Code injection\". This will fill the window with the necessary code to perform the injection. You should see something like this: alloc(newmem,2048,1E59C2074A5) label(returnhere) label(originalcode) label(exit) newmem: //this is allocated memory, you have read,write,execute access //place your code here originalcode: add ecx,edi mov [rax+00000080],ecx exit: jmp returnhere 1E59C2074A5: jmp newmem nop 3 returnhere: Note The addresses may be different in your case. This code does exactly what we explained before. It allocates a new memory location, writes the new instructions there, and then replaces the target instruction with a JMP instruction that jumps to the new instructions. At the end of the new instructions, there is a JMP instruction that jumps back to the original code. Now, we need to modify the newmem block to multiply the edi register by 10. The instruction to do that is imul edi,edi,A (meaning: multiply edi by A (or 10 in base-10) and place the result in edi). So, replace the //place your code here comment with this instruction, and click on Execute. Once you've done that, Cheat Engine will ask you if you want to see the new code in the memory viewer. Click \"Yes\", and you should see the new instructions in memory. You should have 4 instructions: imul edi,edi,0A add ecx,edi mov [rax+80],ecx jmp 1E59C2074AD The jmp instruction at the end is the one that jumps back to the original code. The exact address may be different in your case. You should also see a bunch of add [rax],al after the jmp instruction, but these are just there because the new memory location is filled with 0 bytes by default, and 00 00 can be interpreted as an add instruction. They are never executed, because the jmp instruction jumps back to the original code. If you highlight the jmp instruction and press Spacebar, the memory viewer will \"follow\" the jump and go to the original code. Scroll a little bit up, and you will see that the original add ecx,edi and the following mov [rax+80],ecx instructions have been replaced with a jmp instruction that jumps to the new code, and a nop instruction that does nothing and is only there for padding, to make sure the next instructions are aligned correctly, just like they were before. Note that the add and mov instructions that were replaced by the new jmp are now in the new memory location after our imul instruction. They have been automatically moved there by Cheat Engine to make room for the jmp instruction in the original code location. Now, go back to the game and try to sell a plort. It should give you 10 times more coins than displayed on the market panel. Congratulations, you've successfully injected code into the game! Next part This is the end of the \"hacking basics\" tutorial part of this guide. The next chapter will now cover how to make programs that use the MindControl library to interact with the memory of a running process. This will allow you to build your own memory hacking tools, and automate some of the processes we've just done manually."
  },
  "guide/hacking-basics/finding-values.html": {
    "href": "guide/hacking-basics/finding-values.html",
    "title": "Finding values with Cheat Engine | MindControl",
    "summary": "Finding values with Cheat Engine When hacking a game, the first step is to find the values you want to manipulate. This can be anything from the player's health, to the number of coins, to the position of an enemy. In this section, we will cover how to find these values using Cheat Engine. Tip Make sure the Slime Rancher demo is started, and Cheat Engine is running and attached to the process before proceeding. Start a new game to make sure you have the same initial values as we do. Memory scanning Coin count For our first example, we will attempt to modify the number of coins we currently have. The game has a counter shown in the bottom-left corner of the screen. Let's find the memory address that stores this value. This screenshot of the Slime Rancher demo shows the coin counter above the health bar. The value we want to get is going to be 250 (the initial money we get when starting a new game). Now that we have a value to search for, the first step is to identify the type of value we are looking for. In this case, 250 is a small number that would fit into a single byte, but it's likely that the game uses a bigger data type to store this value, because it's a counter that can go up to thousands and more. Determining the type of the value we are looking for can be a little bit tricky, so here are some general guidelines: If the value can be either \"on\" or \"off\", like a switch, it's likely a boolean. Booleans are usually stored as a single byte, that can be either 0 (off, known as \"false\") or 1 (on, known as \"true\"). If the value can only be a round number, like 3 or -1407, it's likely an integer. The most commonly used type to store integers is a 4-byte integer. If it can be extremely large (in the scale of billions or more), it will probably be an 8-byte integer. You may also find 2-byte integers or just single bytes to store this kind of values, but this is less common, even when the value is always small. If the value can be a decimal number, like 3.14 or -100.5, it's likely a float. You may also find 8-byte floats, more commonly called \"doubles\", used when the values may be particularly big or precise (meaning they have many decimal places). Floats are also frequently used for percentages, or values that can be computed with fractions like damage values or health values. If your value is displayed in a gauge or a bar, it's likely a float, even if the numbers are shown as rounded numbers in the UI. If the value is a text, like \"Hello\", it's a string. Strings are sequences of characters. They are a bit more complex, and out of scope for this basics guide. In our case, the coin count is an integer for sure, because we cannot have a fraction of a coin, so it wouldn't make sense to use float or double. Looking for a 4-byte integer is a good guess, because it's the most commonly used type for integers. Next, we are going to perform a first scan. This is the most basic type of scan, and it's the one you will use most often. It will search the memory for all the values that match the type and value you specify. In our case, we are looking for a 4-byte integer, with the value of 250. Here's how to do it: In the main window of Cheat Engine, locate the scan panel on the right In the \"Value\" field, type 250 In the \"Scan type\" dropdown, select Exact value In the \"Value type\" dropdown, select 4 Bytes Click the \"First scan\" button What this does is search the whole memory of the game for any groups of 4 bytes that have the value 250 when read as an integer. After the scan is complete, the left panel will fill up with a list of memory addresses that match the value you searched for. For each result, Cheat Engine will show the address, the current value at that address, and the previous/first value at that address (more on that later). Now, because there are so many bytes in memory (remember, there's more than a billion), the value 250 that we are searching for is inevitably going to show up thousands of times, and not only for our coin counter. Each row in the results panel is a different memory address of a group of 4-bytes that represents an integer value of 250. We have more than 7000 results for the value 250. This is expected. These thousands of results are too many to look through manually. We need to narrow down the search. To do this, we need to make the game change the value, and then filter out the memory addresses that did not change to the expected new value. If you went through the game's tutorial (as you should have!), you know how to gain some money. Just collect a plort, shove it into the plort market, and you should obtain some more coins. In my case, I got 9 coins, so I have 259 coins. Now we can go back to Cheat Engine, enter the value 259 (or however many coins you have now), and hit next scan. Remember that \"Next scan\" is used to filter the results of a previous scan, based on the new value you specify, while \"New Scan\" or \"First scan\" will perform an entirely new search. In the results list: The Address column shows the memory address where the matching value was found. The Value column shows the current value at the address, updated in real-time. When the value changes, it is highlighted in red. The Previous column shows the value the last time we clicked the \"Next scan\" button. The First column shows the value at the time of the first scan. In our case, it should be \"250\" for all results. After the second scan, you should have a much smaller list of results. If you still have some results that are changing (highlighted in red) despite your coin count staying the same, you can perform additional scans without changing the value to filter them out, or remove them from the list manually. For this particular value, we should be able to narrow it down to 3 values pretty quickly with only a couple of scans, but it's not uncommon to have to repeat the operation (make the game change the value & scan for the new expected value) a few more times to get to a manageable results count. The addresses you obtain can be different from the ones shown in this screenshot. This is expected, we will cover this some more later. In the results list, you can double-click on an address to add it to the bottom panel. You can also select multiple results and click the little red arrow on the bottom-right of the results panel. The bottom panel is called the address list, and it's where you can keep track of the addresses you are interested in. Once you have added all of your narrowed-down results to the address list, we have to find out which of the three is the correct one. The most straightforward way to do this is to change the value and see if the coin count changes in the game. To do this, double-click on the value in the address list, enter a different value (e.g. 9999), confirm, and check back in-game. In my case, modifying the second result seems to have no effect in-game, modifying the third one seems to instantly revert it back to 259, but modifying the first one does the trick. The coin count in the game is now 9999. Congratulations! You have successfully found and modified a value in memory, and the game now believes you have 9999 coins. In fact, unless the game specifically guards against memory hacking (which Slime Rancher and most single-player-only games do not), it has no reason to get suspicious about our sudden fortune, and so it will let us use these coins however we want, no matter how ridiculously high we set the value. Warning Reminder: what we are doing here is fine because it's a single-player game, with no competitive aspect. Using memory hacking for cheating in online games or to gain any kind of advantage (no matter how small) in a competitive space is wrong and will get you banned. Always respect the rules of the games you play. Keep it fair and don't ruin the fun for others. If you ignore this, I will do my best to shut down your project. Editing values in the memory of your target is the core of memory hacking. Libraries like MindControl will help you automate the writing process, but you will still have to manually find the addresses. Bonus training: hacking your health points As a bonus, try to find and modify your health points using the same technique. Here are a few hints to help you get started: You can lose health points by colliding with aggressive slimes in some areas of the game. Despite the game showing integral values for health points, remember that most games use floats to store values that show up in gauges or bars. Setting your health above 100 will revert it back to 100. This is a common behavior in games to prevent players from healing above the maximum health. Try setting it to a distinct value below 100 to see if it works. Bonus bonus training: track a global statistic As a second bonus, try to find out the memory address that holds one of the following global stats (they don't reset when you start a new game): Total number of splorts sold Total money made from splorts Total number of chicken fed to slimes Tip These stats are tracked in the achievement menu, but the challenge is to find them without looking. You can look in the achievement menu once you've found them to verify that you have the correct numbers. A few hints: You probably haven't counted how many times you have done these things until now. In these cases, you can use the \"Unknown initial value\" scan type to get started. Once you have an initial scan, you can filter out unwanted addresses by increasing these numbers, and then using the \"Increased value by...\" scan type, specifying a value that represents by how much you have increased the counter since the last scan. For example, for the splorts sold counter, if you've sold 2 additional splorts since the last scan, specify 2. This will only keep addresses that have increased by that amount since the last scan. Next part In the next section, we will point out a big issue with the technique we just used, and find out how to solve it using pointers."
  },
  "guide/hacking-basics/stable-address.html": {
    "href": "guide/hacking-basics/stable-address.html",
    "title": "Stable addresses | MindControl",
    "summary": "Stable addresses In the previous section, we learned how pointers can help us pinpoint the location of a target value in memory, no matter how much the memory layout changes. We also learned that the pointer path has to start with a stable address if we want our hack to be reliable. This section will cover techniques to find stable addresses and follow pointer paths to get to the values we want to read or write. What is a stable address? To explain stable addresses, we first need to cover modules. A module is a file that contains code and data that is loaded into memory when a program runs. In typical cases, you have an EXE (Executable) file, which contains the entry point of the program (first code executed), and then a bunch of DLL (Dynamic Link Library) files, which contain additional code that the EXE can reference. When a module is loaded into memory, it is assigned a base address, which is the memory address where the module starts. A stable address is the address of a value that is always located at the same offset, after the starting address to its parent module. The notation is usually module_name + offset, where module_name is the name of the module, and offset is a fixed value that represents the distance from the module's base address. For example, Game.dll + 12C0 means \"the address 12C0 bytes after the start of the Game.dll module\". Why are stable addresses important? Stable addresses are crucial for building memory hacking programs that are robust and reliable. If we can find a stable address that holds a pointer to a structure that we are interested in, we can follow it to get to the values we want to read or write, no matter how much the game changes things in memory. Without stable pointers, we would have to find addresses from scratch every time we start the game or change the game state in a way that moves things around in memory. How to find stable pointer paths There are several ways to find pointer paths that start with a stable address. Fortunately, because this is a very common task in memory hacking, Cheat Engine provides a few tools to help us with that. This guide will only demonstrate some of the easiest techniques, but there are many ways to find them, that may or may not work depending on the target process. For the examples, we will use the coin count value from the Slime Rancher demo that we have found in a previous section. Start by attaching Cheat Engine to the game process and finding the address of the coin count value as described in the \"Finding values with Cheat Engine\" section. Going backwards with the debugger Let's start with the most reliable way to find a stable address, but also one of the most tedious ones. Starting with the address of the coin count value, we will use the \"Find out what writes to this address\" feature of Cheat Engine to find the code that writes to the coin count value, and inspect it to see what the offset of the coin count member is within the structure that holds it. Then, we will look for a pointer to that structure, and so on, until we find a stable address. Start by right-clicking the coin count address in Cheat Engine from the address list, and selecting \"Find out what writes to this address\". Confirm that you want to attach the debugger. This will open the watcher window and add an entry whenever the game writes to the address. Now, sell a plort in the game to cause it to write a new coin count value. You should see an entry appear in the watcher window. Click it, and then click the \"More information\" button on the right. This opens another window with extra info. So let's explain what we just did here. In the first window, we have a list of all instructions that have been writing a value at the coin count address. If the same instruction writes to that address multiple times, it will appear only once, but the counter on the leftmost column will show how many times it did. We didn't really explain what instructions are. Basically, they are the lines of code that the game is executing. The instructions are stored in memory, and the CPU reads them one by one to execute the program. The instructions that we are seeing in the memory of a process are in a format called assembly language. This is a low-level language, very close to the machine code that the CPU executes. Each instruction is represented by a mnemonic (a short word that represents the operation), followed by some parameters that tell the CPU what to do. For example, the MOV instruction moves a value from one place to another, and the ADD instruction adds two values together. An example of a few assembly instructions, from the \"Extra info\" window of Cheat Engine. Developers very rarely write in assembly language directly, but instead write code in a high-level language that is then transformed (through compilation or interpretation) into assembly. With memory hacking, we always have to work with assembly code, which is much harder to read and understand than the original code. Note This tutorial is not going to cover assembly language, because this is a much larger topic. We will only cover the basic elements required for our specific case. However, it's a good idea to learn more about it if you want to become proficient in memory hacking. You can find many resources online to learn assembly. Back to our example, the \"Extra info\" window shows us the assembly code that wrote to the coin count address. The exact instruction that wrote to the address is highlighted in red: mov [rax+00000080],ecx It's a MOV instruction, which means that we are copying a value from one place to another. The MOV instruction takes two arguments: the destination and the source. In this case, the destination is [rax+00000080], and the source is ecx. So that means it is copying the value of the ecx register to the address [rax+00000080]. If you don't know what registers are, to simplify, you can think of them as a limited set of variables that the CPU can use to store values temporarily. What's interesting here is that the instruction specifies an offset of 80 (in hexadecimal) bytes from the rax register. This typically means that rax stores the address of a structure that contains the coin count value at an offset of +80 bytes. Looking at the bottom part of the \"Extra info\" window, we can see a dump of the values in CPU registers at the time the instruction was executed. Take note of the value of the rax register, as this is the address of the parent structure holding the coin count. In my case, it's 168698616C0, but yours will be different. Once you've noted it down, and also noted down the offset (+80), you can close both windows. Now, let's take a look back at the pointer path example from the previous section: For now, we have only found the last offset of the pointer path. For the next step, we need to find memory values that hold the address of the parent structure. You know how to do that already: use the main window of Cheat Engine to scan for the value of the rax register. Scanning for the value of the rax register in Cheat Engine. Replace the searched value with the value of rax you have noted before. Don't forget to pick 8 Bytes in the value type dropdown (addresses are 8-byte integers in 64-bit programs), and to check the Hex checkbox to let you input a hexadecimal number. This scan will give you a list of pointers that hold the address of the parent structure. If you look at the pointer path diagram from before, we need to keep finding offsets and parent structure addresses until we reach a stable address. So, now, we can repeat the steps we just did with the coin count address, but using the addresses we just found with the scan. For each scan result: Use \"Find out what accesses this address\" (or press Ctrl+F5) to find the instruction that reads the pointer. We have used \"writes\" before, but finding instructions that read the pointer is more reliable after the first step. Mess around in the game until instructions appear in the watcher window. If it never does, give up on this pointer and try another one. Look at the assembly code to find the offset of the next structure in the same way we did before, and take note of the address of the parent structure, and the offset (sometimes there is no offset, in that case it's just +0). Scan for the parent structure address in Cheat Engine to find the next pointers. If the scan brings up stable addresses (they appear in green), you can stop there. If not, repeat the whole process until it does. Be careful with this process, as it's easy to get lost or to fall into a loop of pointers that reference each others. If you are stuck, try to go back a few steps and try another path. Tip Try doing at least a couple of steps of this process to make sure you understand how it works, but don't feel like you have to go all the way to the end. It's a very time-consuming process, and there are easier ways to find stable addresses (keep reading to find out!). Repeating these steps will (hopefully) eventually lead you to a stable address. The last address in the list on this screenshot, highlighted in green, is stable. Once you have a stable address to start with, click the \"Add Address Manually\" button on the right edge of the Cheat Engine main window, pick the target value type (in our case, 4 Bytes), check \"Pointer\", and start filling in the fields. The bottommost field should be the stable address you found, and then the fields above it should be the offsets. Click \"Add Offset\" as needed to add more offset fields. Once you are done, the value shown next to the address field should be the value of the coin count. An example pointer path added manually in Cheat Engine. Note that the +80 offset we found earlier is the first one when read from top to bottom. Now that we've done all this work, we finally have a stable pointer path that we can use to read or write the coin count value, no matter how much the game changes things in memory. Hopefully. In fact, there is no guarantee that the particular path we have found will work no matter what we do in the game. Maybe one of the structures we traverse is not guaranteed to hold a pointer to the next structure in all cases. Or maybe it does and everything works out just fine. To make sure, we have to test it out in the game, restart the game and test it again, and so on, to make sure that the path is indeed stable. If it's not, we have to go back in the process steps and find other paths. So all in all, this process is methodical and rather reliable, but it's also very time-consuming and requires a lot of manual work. It's a good idea to try it out at least once to understand how it works, but let's find out about another method that is much faster and easier. Using the pointer scanner The pointer scanner is a tool in Cheat Engine that can automatically find pointer paths for you. It's not always reliable, but it's often a very efficient way to find stable addresses. So let's start over (restart the game if you have to) and find the coin count value again, as we did in the \"Finding values with Cheat Engine\" section. Start by right-clicking the address of the coin count value in Cheat Engine, and selecting \"Pointer scan for this address\". This will open the pointer scanner option window. Most settings are fine as they are, but the most important one is the \"max level\" setting. This is the maximum number of pointers that the scanner will follow. The higher the number, the longer the scan will take, but the more likely it is to find a stable address. Generally, you should start with a low number for the max level, like 2 or 3, and increase it if you don't find any stable addresses. However, Slime Rancher is a Unity game, which is known to have a lot of pointer layers, so we are going to use a max level of 5. Note Increasing the max level will make the scan exponentially slower. To give you an idea, a max level of 7 may take a few seconds, a max level of 8 may take several minutes, and a max level of 9 may take days. In addition to the max level setting, I also recommend you check the \"Pointers must end with specific offsets\", and add the +80 final offset that we have found earlier through the \"Find out what writes to this address\" method. This will make the scan faster and more reliable, as it will make sure pointer paths end with the offset we know is correct. Once you have set up the options, click \"OK\" to start the scan. Cheat Engine will ask you to save a .ptr file. Try to keep these organized, they are quite useful if you want to go back after making a mistake, or stop and then resume your hacking project later on. Tip A recommended way to keep your .ptr files organized is to create a folder for each game you are hacking, and then create a subfolder for each hack you are working on. Then, name your .ptr files with a descriptive name, a max level indication, and an index (we will see why in a moment). For this first one, I am going to use D:\\Hacking\\SlimeRancherDemo\\CoinCount\\coincount-l5-001.ptr. The scan may take a while, so be patient. When it's done, you will see a list of results. This window shows all the pointer paths that the scanner has found. The number of results is displayed above the table (in my screenshot, it's 984, but yours will probably be slightly different). The \"Points to\" column shows the final address and its value. These should all have a value corresponding to your current coin count for now. Note The values shown in the \"Points to\" column are not refreshed in real time. They are refreshed whenever you select the row. So, in the current state of the game, all of these stable pointer paths lead to our coin count. But that doesn't mean they will always do. We have to test them out to make sure they are indeed stable. The best way to do that is to mess with the game state, and perform an additional scan to filter out results that no longer point to our coin count. The first thing we can do is to go back to the menu and start a new game. This should shuffle things around in memory, but the paths that are stable should still point to the coin count. When you've done that, go back to the pointer scan results window, and in the \"Pointer scanner\" menu, select \"Rescan memory - Removes pointers not pointing to the right address\". The rescan window that opens allows you to specify what you want to filter out. The easiest scan we can do is to pick \"Value to find\" and enter the expected value we should be pointing to. In our case, because we just started a new game, we are looking for the value 250 (the starting coin count). Click \"OK\" to start the rescan. This will effectively filter out paths that no longer point to an address with a value of 250. Tip Every time you rescan, you are asked to save a new .ptr file. As stated before, this is useful to go back to a previous state. Following the convention from before, I am going to save this one as D:\\Hacking\\SlimeRancherDemo\\CoinCount\\coincount-l5-002.ptr. When the rescan is done, your list should have been trimmed significantly. We now have 257 results, down from 984. Your numbers may be different. We can trim the list further by repeating the process of messing with the game state, and then rescanning. For example, you can sell a plort to change the coin count, and then rescan for the new value. This will filter out paths that don't point to the new coin count value. One of the best ways to mess with game state is to close the game and start it back up. This will shuffle things around in memory a lot, which means that paths that still hold after multiple reboots are very likely to be reliable. Note After you restart the game, don't forget to re-attach the process in Cheat Engine! You don't have to close any window, everything will update automatically. After a few iterations of this process, you should have a list of stable pointer paths that you can use to read or write the coin count value. There is no way to know for sure if any of these will always hold no matter what you do in the game. Just keep iterating until you are confident enough that the paths are stable. If all of your results get filtered out, it can mean one of the following: You have made a mistake in the rescan options. Make sure you are looking for the right value, and that the process is attached. You can always load a previous .ptr file to go back to a previous state without having to restart from scratch. There are no stable pointer paths with the specified max level. Start all over again with an increased max level (in the Slime Rancher demo, you should be able to find stable paths with a max level of 5). There are no stable pointer paths for your value at all. This can happen for example when one of the target structures may be at various indexes in a list, or if the game has cheat protections. In this case, we quickly reach a list of 9 paths that are seemingly stable. When you are confident in your results, pick any of the paths that you have found (it's a good idea to pick shorter ones, but in our case, they all have 5 offsets). Double-click any result to add the pointer path to the address list in the main window of Cheat Engine. You now have a stable way to read or write the coin count value, no matter how much the game changes things in memory. Congratulations! Note Cheat Engine allows you to save your address list and more as a .ct file. This is useful to keep your progress, and to share it with others. You can find the save option in the \"File\" menu. Next part We have now covered the basics of finding stable addresses and following pointer paths to get to the values we want to read or write. In the next section, we will learn another key concept in memory hacking: modifying the game code."
  },
  "guide/hacking-basics/unstable-address.html": {
    "href": "guide/hacking-basics/unstable-address.html",
    "title": "Unstable addresses | MindControl",
    "summary": "Unstable addresses In the previous section, we learned how to find a memory address that stores a specific value. We found the address that stores the coin count in the Slime Rancher demo, and we changed it to a different value. This is a very basic form of memory hacking, but it's already quite powerful. However, there is a catch. The issue With the address of the coin count still in the address list in Cheat Engine, try to go back to the main menu of the game, and then start a new game. You will notice that the value at this address doesn't change. It's stuck with the same old value, and won't reflect the coin count in our new game. Worse, if you exit the demo (close it entirely) and then start it back up and load into a new game (don't forget to re-attach to the game in Cheat Engine every time you do that!), the address will either be invalid (the value will show up as ??), or it will hold a value that doesn't have anything to do with the coin count. If you try to find the address again using the same technique we used in the previous section, you will notice that it's not the same as before. It's a different address. Why is that? Programs manipulate structures in memory all the time. They allocate memory for variables, use it, and then deallocate it. They move things around, they change the size of structures, they create new structures, and they destroy them. This is all part of the normal operation of a program. When a program does this, the memory addresses that we found before can be discarded or reused for other purposes. The address that holds the coin count is now different because the memory of the game has been shuffled around when we started a new game or booted up the game again. This is why we call these addresses unstable. To solve this issue, we need to understand two key concepts: structures and pointers. Understanding structures A structure is a set of variables that are grouped together under a single name. Each variable in the structure is called a member. If you think about it in terms of object-oriented programming, a structure is like a class, and a member is like a field. Members are always organized in the same order across different structures of the same type, and will always be of the same length. Let's take some examples and define the following two structures (these are simplified examples, not actual structures in Slime Rancher or any other game): The Player structure Field Type Offset healthPoints float 0x08 weaponHeld pointer 0x10 coinCount 4-byte int 0x18 The Weapon structure Field Type Offset cost 4-byte int 0x08 damage 4-byte int 0x0C swingTime float 0x10 In these tables, the Offset column tells us where the field is located within the structure. For example, if we know the address of a Player structure, we can find the coinCount field by adding 0x18 (hexadecimal notation for the number 24) to the address, no matter where the Player structure itself is located. Doing a little bit of math, if we know our Player structure starts at the address 182F359202C, the coinCount member will be at the address 182F3592034. Now, you'll notice that the weaponHeld member is a pointer, which is the second concept we need to understand to solve our issue. Understanding pointers What is a pointer? A pointer is simply a variable that holds the address of another variable. It's like a note that says \"the value you are looking for is at this address\". In our examples, the weaponHeld member of the Player structure is a pointer to a Weapon structure. This means that the weaponHeld member holds the address of a Weapon structure, and not the Weapon structure itself. Looking at the offsets and value types, we can see that a Weapon structure is 24 bytes long. Regardless of that, the Player structure can have a weaponHeld member that is always 8 bytes long, because it only holds the address of the Weapon structure. The Weapon structure itself can be located anywhere else in memory. How do pointers solve our issue? Let's take a look back at our \"weapon held\" example. Say we want to track our current weapon damage. We have found that the address of the Weapon structure for the weapon we are currently holding is 182F3593120. Using the offset, we know that the damage value is at 182F359312C. Now imagine that, in game, we equip a different weapon. What happens in that case is that the game will update the value of the weaponHeld member in our Player structure to hold the address of the new weapon structure (this can also be called \"pointing to\" the new weapon structure). The previously held Weapon structure will not be touched. When we look at our 182F359312C address, we still see the same damage value as before, because it still is a field within the old Weapon structure. Even worse, if it doesn't need the old weapon anymore, maybe the game will discard the old structure, and the address may become invalid, or be reused to hold different data. We observe the same address, regardless of the change, so we still get the same value of 5 after the weapon changes. Now, let's say that instead of having a fixed 182F359312C address that we watch, we first read the address of the weaponHeld member in the Player structure, to know where the weapon structure is stored. Then, we can add the damage member offset (+C) to that address, and we will always get the correct damage value, no matter how many times the game moves things around in memory. We observe the pointer to the equipped weapon, and follow it with an added +0C offset to get to the damage value. This time, we get the correct value of 17 after the weapon changes. The thing is, the Player structure itself can move around, especially if we do things like going back to the menu and loading back in, or even worse, close the game and start it back again. So, following the same logic, we have to find a pointer within a different structure that holds the address of the Player structure. Maybe there's a GameManager structure that has a player pointer member. And then maybe there's a Game structure that has a gameManager pointer member. And maybe that GameManager structure is always located at the same address, relative to a module (more on that later). If we can figure out this whole chain, we can follow the pointer path: Game structure address + gameManager member offset → GameManager structure address + player member offset → Player structure address + weaponHeld member offset → weapon structure address + damage member offset And that pointer path would always be stable, meaning that no matter how much the game moves things around in memory, and no matter how many times we restart the game, we can always get to the damage member of the weapon we are holding. We observe the stable address game.exe + 1FC08 (we'll learn more about these in the next section) that starts a sequence of pointers, that we follow with known offsets added each time, to finally get to the damage value of the weapon held by the player. The key to these pointer paths is to find the first address in the chain that never moves around. This is called a stable address. Next part In the next section, we will learn techniques to find stable addresses and follow pointer paths to get to the values we want to read or write. This will allow us to build memory hacking programs that are robust and reliable, even when the game moves things around in memory."
  },
  "guide/introduction.html": {
    "href": "guide/introduction.html",
    "title": "Introduction | MindControl",
    "summary": "Introduction This guide is intended to demonstrate how to use the MindControl .net library to interact with the memory of a running process. However, to make sure your understanding of the basics of memory hacking is aligned with the library's design, we will first cover some fundamental concepts. If you are new to memory hacking, this guide will help you get started on your journey. If you are already familiar with process hacking, you can skip ahead to the Project setup section. What is memory hacking and what can we do with it? Memory hacking is basically manipulating the internal values used by a process that is running on your system, while it's running. Every program that runs on your system is loaded into memory. This memory stores everything the program needs to run, including the values of variables, the code that is being executed, and the data that is being processed. By changing these values, you can manipulate the behavior of the program. Usually, each program minds its own business and has a separate set of memory. However, using system functions, you can read and write to the memory of any process running on your system. A memory hacking program will make use of these functions to access the memory of its target program. This technique is often used in gaming, to build all sorts of tools, such as game trainers, cheats, bots, overlays, and automation tools. Mods can also be built using memory hacking, although they typically also require other skills. It can also be used in general-purpose software, for debugging, reverse engineering, security testing, and more. Warning Just a reminder before you keep going: using memory hacking for cheating in online games or to gain any kind of advantage (no matter how small) in a competitive space is wrong and will get you banned. Always respect the rules of the games you play. Keep it fair and don't ruin the fun for others. If you ignore this, I will do my best to shut down your project. What MindControl is about MindControl is a .net library that provides a set of tools to interact with the memory of a running process. It allows you to easily build memory hacking programs that read and write values, search for patterns, inject code, and more. It's designed to be simple to use, reliable, and efficient. As stated before, operating systems like Windows provide functions to do that already. However, these functions are low-level, complex to understand and cumbersome to use. MindControl provides an additional layer on top of that, that considerably simplifies the process. Next step The next section will be about gathering everything you need to follow this guide."
  },
  "guide/mcfeatures/allocations.html": {
    "href": "guide/mcfeatures/allocations.html",
    "title": "Storing data in memory | MindControl",
    "summary": "Storing data in memory This section explains how to allocate memory and store data in the memory of the target process using MindControl. What is a memory allocation? A memory allocation is a block of memory that is reserved in the target process's address space. This memory space can be used to store data, such as structures, arrays, strings, pictures, or even code. For example, if you want to replace a texture in a game, you have to: Allocate memory in the target process to store the new texture data. Write the texture data to the allocated memory. Overwrite pointers to use the new texture data from the allocated memory instead of the normal one. MindControl provides three features for working with memory allocations: allocations, reservations, and storage. Storage For most use cases, you don't need to allocate memory manually. Instead, you can use the ProcessMemory class to store data in the target process's memory. This is done using the Store<T> method, which takes a value and returns a MemoryReservation object that represents a reservation on allocated memory (more on that later). You can then get the address of the reservation and reference it wherever you need to. // Store an integer value in the target process memory. This could be any other data type that you can write. var reservationResult = processMemory.Store(42); if (reservationResult.IsSuccess) { // We can then use the Address property of the MemoryReservation // In this example, we read the value back from the target process memory, but you would typically write a pointer // to this address somewhere so that the process uses it. MemoryReservation reservation = reservationResult.Value; int value = processMemory.Read<int>(reservation.Address).ValueOrDefault(); Console.WriteLine($\"Stored value: {value}\"); // Output: Stored value: 42 } When calling Store, under the hood, MindControl will: Allocate a chunk of memory in the target process that is large enough to hold the data you want to store, but usually bigger than that for various reasons Keep track of the allocated memory in a MemoryAllocation object to maybe reuse it later Reserve a portion of the MemoryAllocation just big enough to hold the data you want to store, essentially creating a MemoryReservation object Write the data at the address of that reservation Return the MemoryReservation object If we call Store again with some data that is small enough to fit in the same MemoryAllocation, MindControl will reuse the same allocation, and create a new MemoryReservation on it, for your new data. This is done to avoid unnecessary memory allocations and to optimize memory usage. var reservation1 = processMemory.Store(42).Value; var reservation2 = processMemory.Store(64).Value; // Only one memory allocation is issued, but two different reservations are created. // Usually, you don't need to worry about this. The advantage of using Store is that it abstracts away the details of memory allocation and management, allowing you to focus on the data you want to store rather than the underlying memory operations. You don't have to worry about where the memory is allocated, how much space is reserved, about the system page size, data alignment, or even about accidentally overwriting the memory you allocated. Note Disposing the MemoryReservation object will automatically free the memory reserved for your data, so that it can be reused to store other data later. If your program dynamically stores more and more data, you have to make sure to dispose of the MemoryReservation objects when you no longer need them, to avoid memory leaks in the target process. The two other features, allocation and reservation, are more low-level and give you more control over the memory management process. They're usually not needed, but there are cases where you might want to use them. Allocations If you need to allocate memory manually, you can use the Allocate method of the ProcessMemory class. This method allows you to allocate a block of memory in the target process's address space. This method returns a MemoryAllocation object that represents the allocated memory. // Allocate a block of memory of at least 1024 bytes in the target process, to store data (not code) MemoryAllocation allocation = processMemory.Allocate(1024, forExecutableCode: false).Result; // The actual allocation size may be larger than 1024 bytes, depending on the system page size and other factors. Note that the second parameter, forExecutableCode, specifies whether the allocated memory should be executable or not. If you plan to write code to this memory, you should set this parameter to true. Otherwise, you can set it to false to avoid performance overhead and potential security risks. There are also two optional parameters that you can use to provide memory range limits for the allocation, and/or to specify that the memory allocation should be made as close as possible to a specific address. This is most useful when performing code injection and other advanced memory manipulation techniques. Note Like the reservations, disposing MemoryAllocation instances will free the memory allocation in the target process. If your program creates allocations dynamically, make sure to dispose of them when you no longer need them, to avoid memory leaks in the target process. With the returned MemoryAllocation object, you can perform reservations, which is the topic of the next section. Reservations If an allocation is a physical block of memory in the target process, a reservation is a logical portion of that allocation that you explicitly mark as used. Basically, reservations are another layer on top of allocations that allow you to manage your allocations more easily. When you make a reservation, you are locking in a portion of the allocated memory, and that makes sure that future reservations will not overlap with it. There are two ways to create a reservation: using the ReserveRange method of the MemoryAllocation class, or using the Reserve method directly on the ProcessMemory class. Using a MemoryAllocation MemoryAllocation allocation = processMemory.Allocate(1024, forExecutableCode: false).Result; // Reserve 256 bytes of that allocation MemoryReservation reservation = allocation.ReserveRange(256).Result; // You can now use the reservation to write data processMemory.Write(reservation.Address, 42); Using ProcessMemory The Reserve method is a more convenient way to create a reservation without having to manage the allocation yourself. It will browse existing allocations to find one that satisfies the required size, create one if none exists, and then make a reservation in it. // Reserve 256 bytes of memory in the target process, without manually creating a new allocation MemoryReservation reservation = processMemory.Reserve(256, requireExecutable: false).Result; // You can now use the reservation to write data processMemory.Write(reservation.Address, 42); Conclusion To recapitulate, in most cases, you can use the Store<T> method to store data in the target process's memory without worrying about allocations and reservations. If you need more control over memory management, you can use the Reserve method to create reservations directly, or, if you need even more control, you can use Allocate to manage allocations yourself."
  },
  "guide/mcfeatures/attaching.html": {
    "href": "guide/mcfeatures/attaching.html",
    "title": "Attaching to a process | MindControl",
    "summary": "Attaching to a process Manipulating the memory of a running process with MindControl requires attaching to that process to get a ProcessMemory instance. In this section, we will cover how to attach to a process using the MindControl library. The Process Tracker In most cases, the best way to attach to a process is to use the ProcessTracker class. This class has a very simple API: you specify the name of the process you want to attach to, and then you can get a ProcessMemory instance whenever you want to perform a memory manipulation operation. If the process is not running at the time of the call, it will return null. Here is an example of how to use a ProcessTracker in a class: public class SlimeRancherProcess { // Keep an instance of the ProcessTracker in your class and give it the name of the target process. private readonly ProcessTracker _processTracker = new(\"SlimeRancher\"); public int? GetCoinCount() { // Attempt to get the ProcessMemory instance for the target process // If the process is not running, this will return null var process = _processTracker.GetProcessMemory(); if (process == null) return null; // Use the ProcessMemory instance to read a value from the target process var coinCountResult = process.Read<int>(\"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"); return coinCountResult.ValueOr(0); } } The ProcessTracker class allows you to easily attach to your target process, without having to worry about: The order in which the processes are started: if your program starts first, GetProcessMemory will just return null until the target process is started. The process being closed: if the target process is closed, GetProcessMemory will return null after the process is closed. The process being restarted: if the target process is restarted, GetProcessMemory will return a new ProcessMemory instance for the new process. You don't have to care about this. Attaching directly through the ProcessMemory class There are cases where you might want to attach to a process directly without using the ProcessTracker. For example: You know the process ID of the target process and want to attach to it directly. You are building a \"one-shot\" tool that attaches to a process, performs some operations, and then exits. You want to attach to multiple processes with the same name. For these cases, you can use the ProcessMemory class directly. Here are examples of how to do this: Attaching to a process by name using MindControl; var result = ProcessMemory.OpenProcessByName(\"MyTargetProcess\"); // Replace with the actual process name result.ThrowOnFailure(); // Throws an exception if the process could not be opened var processMemory = result.Value; Attaching to a process by PID (process ID) using MindControl; var result = ProcessMemory.OpenProcessById(1234); // Replace with the actual process ID result.ThrowOnFailure(); // Throws an exception if the process could not be opened var processMemory = result.Value; Attaching to a process with a System.Diagnostics.Process instance using MindControl; var process = System.Diagnostics.Process.GetProcessById(1234); // You can use other methods to get the Process instance var result = ProcessMemory.OpenProcess(process); result.ThrowOnFailure(); // Throws an exception if the process could not be opened var processMemory = result.Value;"
  },
  "guide/mcfeatures/code-manipulation.html": {
    "href": "guide/mcfeatures/code-manipulation.html",
    "title": "Manipulating code | MindControl",
    "summary": "Manipulating code This section is a bit more advanced and will explain how to manipulate code in the target process using MindControl. Note This section requires the MindControl.Code package to be installed in addition to the MindControl package. What is code manipulation? Code manipulation refers to the ability to modify the executable code of a running process. This can include removing or changing instructions, injecting new code, or redirecting execution flow. Code manipulation is often used in game hacking, reverse engineering, and debugging scenarios. Executable code is stored in the process memory, just like any other data, under the form of instruction bytes called opcodes. These opcodes are executed by the CPU to perform various operations, such as arithmetic calculations, memory access, and control flow changes (jumping to a different instruction, often depending on various conditions). Manipulating code can be challenging, because messing up a single bit in an instruction often leads to crashes or unexpected behavior. Injecting new code without modifying the existing code is especially difficult, because you cannot just insert new instructions in the middle of existing code without breaking the flow of execution. Opcodes Opcodes are the machine-level instructions that the CPU executes. Each opcode corresponds to a specific operation, usually very basic, such as adding two numbers, jumping to a different instruction, or calling a function. Opcodes are represented as byte sequences in memory, and they can vary depending on the CPU architecture (e.g., x86, x64). When using a memory hacking tool such as Cheat Engine, you can view the disassembled code, which shows the opcodes in a human-readable format (assembly language). This allows you to see what the code is doing and how it is structured, but it is still very complex to understand, because meaningful operations (like \"fire a bullet\") are made of thousands of opcodes, each performing a basic operation that has no obvious meaning by itself. Here are some examples of common opcodes in x64 architecture: mov eax, 1 ; B8 01 00 00 00 - Move the value 1 into the EAX register. add eax, 2 ; 05 02 00 00 00 - Add the value 2 to the EAX register. jmp 0x12345678 ; (Bytes depend on multiple factors) - Jump to the instruction at address 0x12345678. call 0x12345678 ; (Bytes depend on multiple factors) - Call the function at address 0x12345678 nop ; 90 - No operation, does nothing. Note that the opcodes are not always the same length, and some operations can take different forms depending on the operands used. For example, the jmp and call instructions can have different byte sequences depending on whether they use absolute addresses, relative offsets, or other addressing modes. Note When diving into code manipulation, it is very advisable to learn the basics of assembly language. This is outside the scope of this guide, but there are many resources available online to help you get started. Removing code instructions The easiest code manipulation operation is to remove code instructions. This can be done by overwriting the instructions with NOP (No Operation) instructions, which effectively make the code do nothing. Fortunately, NOP instructions are only one byte long, so you can replace any instruction with a number of NOP instructions without changing the size of the code. For example, removing a mov eax, 1 instruction would be as simple as writing 5 bytes of 0x90 (the opcode for NOP) at the address of the instruction. MindControl provides easy-to-use methods to remove code instructions. The DisableCodeAt method disables a number of instructions at a specific address by overwriting them with NOP instructions. // Disable 5 instructions, starting at the address \"mygame.exe+0168EEA0\" CodeChange codeRemoval = processMemory.DisableCodeAt(\"mygame.exe+0168EEA0\", 5); // Disposing the CodeChange object will restore the original code codeRemoval.Dispose(); Note It is important to consider that removing code instructions can lead to unexpected behavior, especially if the removed instruction is part of a larger control flow structure (like a loop or a conditional statement). If you don't know what the removed instructions do, chances are you will cause a crash. Injecting code Injecting code is a more advanced operation that allows you to add new instructions to the target process. This can be used to implement custom functionalities or to modify existing behavior. Because we cannot just insert new instructions in the middle of existing code and shift everything around, this is usually done through a hook. A hook is a technique that intercepts the execution flow of the target process and redirects it to your custom code, usually redirecting it back to the original code afterward. The steps are the following: Allocate executable memory in the target process to store the new code. Ideally, the code is located near the original code, to optimize performance. Write the new code to the allocated memory. Overwrite the original code at the address of the target instruction with a jump instruction that redirects execution to the new code. Typically, the code you write at step 2 will end with a jump instruction that redirects execution back to the original code, so that the original code can continue executing after your custom code has run. This is often referred to as a \"trampoline\". (So now you know how to build trampoline hooks.) If you want to inject code without replacing functionality, the code you write at step 2 may start with whatever instructions end up being replaced by the jump instruction at step 3. There is a big issue with that though. The code you write will often use registers and set CPU flags, meaning that, when you redirect execution back to the original code, the state of the CPU will not be what the original code expects. This often leads to crashes or unexpected behavior. To protect against this, you need to save the state of the CPU before executing your custom code, and restore it afterward. This is often done by pushing the registers onto the stack at the start of your custom code, and popping them back at the end. We won't go into the details of how to write assembly code for this, but we will see how to do it using MindControl. Whatever you want to achieve, MindControl provides three ways to inject code. Using InsertCodeAt The InsertCodeAt method of ProcessMemory allows you to inject code at a specific instruction in the target process. It takes either the address of a pointer path to the address of an instruction, and the code to inject. In this variant, the code is going to be executed before the original instruction, and the original instruction will be executed afterward. No instructions are removed, the original code is preserved entirely. The code you provide is either a byte array, or a Iced.Intel.Assembler object that contains some code ready to be assembled. The Iced.Intel.Assembler class is part of the Iced project, which is a library for disassembling and assembling x86/x64 code. You can use it to line up assembly code in your .net project that you can then inject through MindControl. // Create an assembler and write some code to it var assembler = new Assembler(64); assembler.mov(rcx, value); // ... // Insert the code at the address \"mygame.exe+0168EEA0\" CodeChange codeInjection = processMemory.InsertCodeAt(\"mygame.exe+0168EEA0\", assembler).Value; // Disposing the CodeChange object restores the original code and frees the memory reservation where code was written codeInjection.Dispose(); Using ReplaceCodeAt Similarly, the ReplaceCodeAt method allows you to replace one or more instructions with your own code. This is useful when you want to modify the behavior of existing code. The differences with InsertCodeAt are: You can specify the number of instructions to replace, and the code you provide will be executed instead of the original instructions. If your code is shorter or equal in size to the original instructions, the original code will simply be overwritten. If your code is longer, a hook will be performed. You don't have to worry about that. // Create an assembler and write some code to it var assembler = new Assembler(64); assembler.mov(rcx, value); // ... // Replace 3 instructions, starting at the instruction at address \"mygame.exe+0168EEA0\", with the code we just prepared CodeChange codeInjection = processMemory.ReplaceCodeAt(\"mygame.exe+0168EEA0\", 3, assembler).Value; // Disposing the CodeChange object restores the original code and frees the memory reservation where code was written // (in cases where a hook was necessary). codeInjection.Dispose(); Using Hook Finally, the Hook method allows you to specify what kind of hook to perform, through a HookOptions object. This method provides slightly more control over the hook, but it's almost always possible to achieve the same result using either InsertCodeAt or ReplaceCodeAt. // Create an assembler and write some code to it var assembler = new Assembler(64); assembler.mov(rcx, value); // ... // Create hook options to specify the type of hook to perform HookOptions hookOptions = new HookOptions(HookExecutionMode.ExecuteInjectedCodeFirst); // Hook the instruction at address \"mygame.exe+0168EEA0\" with the code we just prepared CodeChange codeInjection = processMemory.Hook(\"mygame.exe+0168EEA0\", assembler, hookOptions).Value; // Disposing the CodeChange object restores the original code and frees the memory reservation where code was written codeInjection.Dispose(); Note It's generally discouraged to use the Hook method directly, as it is more complex and less intuitive than the other two methods. The InsertCodeAt and ReplaceCodeAt methods are usually better and easier to read. Code isolation As we have previously touched, injecting code can lead to unexpected behavior if the injected code does not properly handle the CPU state. To make sure that your injected code does not interfere with the original code, you have to save and restore the CPU registers and flags before and after executing your custom code. You can do this manually by pushing the registers onto the stack at the start of your custom code, and popping them back at the end. However, MindControl provides a more convenient way to do this through an additional parameter in both InsertCodeAt and ReplaceCodeAt. This parameter is an array of HookRegister, an enumeration that you can use to list the registers that your code uses. When performing the code manipulation, MindControl will automatically save and restore the state of these registers. Additionally, if your injected code is very complex or if you want to make sure that it does not interfere with the original code, you can use one of the pre-made arrays available through the HookRegisters static class. For example, HookRegisters.AllCommonRegisters is a pre-made array of all commonly used registers, and using it in a code manipulation operation will almost always guarantee that your code does not interfere with the original code. In performance-critical scenarios, you should try to list only the registers that your code actually uses, to avoid the overhead of saving and restoring unnecessary registers. Example using a few registers // Save and restore the state of the RCX and RBX registers, and the CPU flags CodeChange codeInjection = processMemory.InsertCodeAt(\"mygame.exe+0168EEA0\", assembler, HookRegister.RcxEcx, HookRegister.RbxEbx, HookRegister.Flags).Value; Example using all common registers // Using all common registers is a catch-all solution, but runs slower CodeChange codeInjection = processMemory.InsertCodeAt(\"mygame.exe+0168EEA0\", assembler, HookRegisters.AllCommonRegisters).Value; Note In the HookRegister enumeration, x64 and x86 versions of the same register are grouped together, because MindControl is not compiled against a specific architecture. For example, HookRegister.RcxEcx refers to the x64 RCX register if your target process is x64, or the x86 ECX register if your target process is x86."
  },
  "guide/mcfeatures/dll-injection.html": {
    "href": "guide/mcfeatures/dll-injection.html",
    "title": "Injecting a DLL | MindControl",
    "summary": "Injecting a DLL A common technique in process hacking is to inject a DLL into the target process. This allows you to run custom code within the context of the target process, which can be useful for various purposes, such as modifying the behavior of the application, hooking functions, or even creating a user interface. Creating a DLL for injection To create a DLL for injection, you can write a simple C++ program with an APIENTRY function that will be called when the DLL is loaded. Here's a basic example: #include <windows.h> #include <iostream> BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: // This code will run when the DLL is injected into the target process // In this example, we will just show a messagebox, but you can replace this with your own code MessageBoxA(NULL, \"Injected library attached\", \"DLL Injection\", MB_OK | MB_ICONINFORMATION); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } Compile this code into a DLL using your preferred C++ compiler. Make sure to set the output type to \"Dynamic Link Library\" (DLL), and use the appropriate bitness (x86 or x64) that matches the target process you want to inject into. Then, you can add this DLL to your MindControl project. Note When referencing the DLL in your MindControl project, just add it as a content file, and not a reference. Make sure that the DLL is copied to the output directory of your project. Injecting the DLL using MindControl Once you have your DLL ready, you can inject it into the target process using the ProcessMemory.InjectLibrary method. // Pay attention to the result of the method call, as there are many reasons why the injection might fail processMemory.InjectLibrary(\"path_to_your_dll.dll\").ThrowIfFailure(); This method will attempt to inject the specified DLL into the target process. If the injection is successful, the code in the DllMain function of your DLL will be executed before the method returns. For example, if you used the code provided above, you should see the message \"Injected library attached\" in a message box when the DLL is injected successfully."
  },
  "guide/mcfeatures/freezing.html": {
    "href": "guide/mcfeatures/freezing.html",
    "title": "Freezing values in memory | MindControl",
    "summary": "Freezing values in memory This section covers a technique often called \"freezing\". The idea is to lock the value of a variable in memory so that it does not change, even as the game tries to modify it. This can be useful for debugging or, let's be real, to make cheats in games. In MindControl, this is done through memory anchors. An anchor is like a persisting reference to a specific variable in memory, of a specific type, and it allows you to perform various operations on that specific target. var anchor = processMemory.GetAnchor<int>(); // Freeze that variable to the value 1234567 var freezer = anchor.Freeze(1234567); // To unfreeze the variable, dispose the freezer freezer.Dispose(); When you freeze a variable, MindControl will continuously write the specified value to the target memory location, effectively locking it in place. This means that even if the game changes the value, it will be very quickly overwritten with the frozen value you chose. Note Freezing is resource-intensive, as it requires continuous writes to memory. Be careful not to overuse it, and make sure you dispose freezers that you no longer need."
  },
  "guide/mcfeatures/functions.html": {
    "href": "guide/mcfeatures/functions.html",
    "title": "Executing remote functions | MindControl",
    "summary": "Executing remote functions This section covers how to execute functions in your target process. This can allow you to perform actions in the target process from your program, or to call your own functions after injecting a DLL into the target process. You can execute functions with the method RunThread. There are two main ways to call this method: With an address or pointer path You can call a function by providing its address or a pointer path to it. This is useful when you know the exact location of the function in memory. var result = processMemory.RunThread(\"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"); result.ThrowOnFailure(); // Throws an exception if the function could not be executed // Wait for the function to complete, with a timeout of 10 seconds result.Value.WaitForCompletion(TimeSpan.FromSeconds(10)); // Dispose the result when done to ensure resources are released result.Dispose(); With a module and function name You can also call a function by providing the module name and the function name. This is useful when you want to call a function in a specific module without needing to know its address. This uses the module's export table to find the function, and thus requires the module to explicitly export the function. In the following example, we call the ExitProcess function from the Windows kernel library kernel32.dll. This module is loaded in every Windows process, so you can use its functions without having to inject a DLL. var result = processMemory.RunThread(\"kernel32.dll\", \"ExitProcess\"); result.ThrowOnFailure(); // Throws an exception if the function could not be executed // Wait for the function to complete, with a timeout of 10 seconds result.Value.WaitForCompletion(TimeSpan.FromSeconds(10)); // Dispose the result when done to ensure resources are released result.Dispose(); Function parameters You can also pass parameters to the function you are calling. This is an advanced feature that requires you to understand how the target function expects its parameters to be passed. In MindControl, parameters are passed through a single pointer. You can arrange your parameters in a structure, store them in memory (e.g. using Store<T>), and then pass the pointer to that memory as the parameter. struct MyFunctionParams { public int Param1; public float Param2;} var myParams = new MyFunctionParams { Param1 = 42, Param2 = 3.14f }; var paramsPointer = processMemory.Store(myParams).Value.Address; var result = processMemory.RunThread(\"myprocess.exe+019BAEA1\", paramsPointer); result.Value.WaitForCompletion(TimeSpan.FromSeconds(10)); result.Dispose(); However, this will only work for a specific argument passing convention. What this does is store the pointer in the RCX register (or EBX for 32-bit processes) before calling the function. If the function is not designed to accept parameters in this way, you will need to use a different approach, such as writing a wrapper function that prepares the parameters and calls the target function (also called a trampoline). Here is an example where we call the GetCurrentDirectoryW function from kernel32.dll, which expects two parameters: a buffer size and a pointer to a buffer where the current directory will be stored. Note The following example is complex and requires some understanding of assembly code and registers. For most use cases, you won't need to perform trampoline calls. Don't worry about this unless you need it. // Define the structure that holds the parameters for GetCurrentDirectoryW // The attribute prevents the compiler from adding padding bytes, ensuring the structure is packed tightly in memory. [StructLayout(LayoutKind.Sequential, Pack = 1)] struct GetCurrentDirectoryWArgs { public uint BufferSize; public ulong BufferAddress; } // Reserve memory for the buffer where the current directory will be stored var bufferReservation = processMemory.Reserve(2048, false).Value; // Create an instance of the structure and store it in memory var args = new GetCurrentDirectoryWArgs { BufferSize = 2048, BufferAddress = bufferReservation.Address }; var argsReservation = processMemory.Store(args).Value; // Retrieve the address of the GetCurrentDirectoryW function var kernel32Module = processMemory.GetModule(\"kernel32.dll\"); var functionAddress = kernel32Module!.ReadExportTable().Value[\"GetCurrentDirectoryW\"]; // Using Iced.Intel, prepare the trampoline code to call GetCurrentDirectoryW // Make sure to use \"using static Iced.Intel.AssemblerRegisters;\" to use the registers in a readable way var assembler = new Assembler(64); // In x64, the function uses the fastcall calling convention, i.e. RCX and RDX are used for the two arguments. // When the thread is created, the thread parameter is in RCX. In this case, our parameter is going to be the // address of a GetCurrentDirectoryWArgs struct holding the parameters we want. assembler.mov(rax, rcx); // Move the address of the GetCurrentDirectoryWArgs struct to RAX, to free up RCX assembler.mov(ecx, __dword_ptr[rax]); // Move the buffer size (first argument) to ECX/RCX assembler.mov(rdx, __[rax+4]); // Move the buffer address (second argument) to RDX assembler.call(functionAddress.ToUInt64()); // Call GetCurrentDirectoryW assembler.ret(); // Store the trampoline code in the target process memory // The nearAddress parameter is used to favor allocations close to the kernel32.dll module, for more efficient jumps // This code requires the MindControl.Code package var codeReservation = processMemory.StoreCode(assembler, nearAddress: kernel32Module.GetRange().Start).Value; // Now we can run the trampoline code in a new thread, passing the address of the GetCurrentDirectoryWArgs struct var threadResult = processMemory.RunThread(codeReservation.Address, argsReservation.Address); threadResult.Value.WaitForCompletion(TimeSpan.FromSeconds(10)).ThrowOnFailure(); // Read the resulting string from the allocated buffer var resultingString = processMemory.ReadRawString(bufferReservation.Address, Encoding.Unicode, 512).Value; Console.WriteLine($\"Current Directory: {resultingString}\"); // This should print the directory of the target process // Dispose everything to ensure resources are released bufferReservation.Dispose(); argsReservation.Dispose(); codeReservation.Dispose(); threadResult.Dispose();"
  },
  "guide/mcfeatures/monitoring.html": {
    "href": "guide/mcfeatures/monitoring.html",
    "title": "Monitoring value changes in memory | MindControl",
    "summary": "Monitoring value changes in memory This section covers how to monitor changes to a variable in memory. This can be useful if you need your application to react to changes in your target process, without having to set up timers or other polling mechanisms yourself. You can monitor changes to a variable in memory through anchors. An anchor is a persistent reference to a specific variable in memory, of a specific type, and it allows you to perform various operations on that specific target. var anchor = processMemory.GetAnchor<int>(); var watcher = anchor.Watch(TimeSpan.FromMilliseconds(100)); // Read every 100 milliseconds watcher.ValueChanged += (_, args) => { Console.WriteLine($\"Value changed from {args.PreviousValue} to {args.NewValue}.\"); }; watcher.ValueLost += (_, args) => { Console.WriteLine($\"Value lost. Last known value is {args.LastKnownValue}.\"); }; watcher.ValueReacquired += (_, args) => { Console.WriteLine($\"Value no longer lost. The new value is {args.NewValue}.\"); }; // ... // To stop watching the value, dispose the watcher watcher.Dispose();"
  },
  "guide/mcfeatures/pointer-paths.html": {
    "href": "guide/mcfeatures/pointer-paths.html",
    "title": "Understanding pointer paths | MindControl",
    "summary": "Understanding pointer paths Most methods in the ProcessMemory class that accept an address also accept a pointer path. A pointer path is a string that describes a sequence of memory addresses and offsets, allowing you to navigate through complex data structures in the target process's memory. More importantly, they allow you to get to the value you want reliably, no matter how the target process shuffles its memory around. They are usually represented by a string called a pointer path expression. Here is an example of a pointer path expression: UnityPlayer.dll+0168EEA0,8,100,28,20,80 In this example, the pointer path expression consists of: UnityPlayer.dll+0168EEA0: This is the base address of the module (DLL) in the target process's memory, with an offset of 0168EEA0 bytes. 8,100,28,20,80: These are offsets that will be applied to the base address to navigate through the memory structure. Each number represents an offset in bytes from the previous address. This expression is the equivalent of the following pointer in Cheat Engine: To convert a pointer in Cheat Engine to a pointer path expression, read it from bottom to top, separating every field with a comma. Pointer paths don't have to be based on modules, they can also be based on pointers. For example, if you have a base pointer address of 0x4A018C30A, you can create a pointer path like this: 0x4A018C30A,8,100,28,20,80 You can also use + and - operators within pointer paths, e.g.: UnityPlayer.dll+0168EEA0,100+8C,28-4,20,80 Building pointer paths Pointer paths can be built in a number of ways: Using the expression constructor PointerPath myPath = new PointerPath(\"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"); Using PointerPath.TryParse Use this method when your pointer path is coming from an external source, such as user input or a configuration file. It will return null if the parsing fails, allowing you to handle errors gracefully. var path = PointerPath.TryParse(\"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"); if (path != null) { // Successfully parsed the pointer path } else { // Failed to parse the pointer path } Using implicit string conversion This is a convenient way to create a PointerPath from a string without using the constructor directly. The string will be parsed automatically. PointerPath myPath = \"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"; This can also be used with any method that accepts a PointerPath as an argument: var someValue = processMemory.Read<int>(\"UnityPlayer.dll+0168EEA0,8,100,28,20,80\").ValueOrDefault(); Note When using pointer string expressions, it's more performant to store and reuse your PointerPath instances instead of creating new ones every time you need to read or write memory. This avoids the overhead of parsing the string each time. Using the module constructor This is more performant than the expression constructor, as it does not require parsing the string. PointerPath myPath = new PointerPath(\"UnityPlayer.dll\", 0x168EEA0, 0x8, 0x100, 0x28, 0x20, 0x80); Using the pointer constructor This is a variant of the module constructor that allows you to specify the base address as a pointer when your path is not based on a module. PointerPath myPath = new PointerPath(0x4A018C30A, 0x8, 0x100, 0x28, 0x20, 0x80); Evaluating a pointer path When using a pointer path for memory manipulations, behind the scenes, MindControl will start by evaluating the pointer path to get the target address out of it. In some cases, you may want to do just that and nothing else. For this, you can use the EvaluateMemoryAddress method. UIntPtr address = processMemory.EvaluateMemoryAddress(\"UnityPlayer.dll+0168EEA0,8,100,28,20,80\").ValueOrDefault();"
  },
  "guide/mcfeatures/reading.html": {
    "href": "guide/mcfeatures/reading.html",
    "title": "Reading memory | MindControl",
    "summary": "Reading memory This section will explain how to read data from the target process using MindControl. Note Reading string values is a more complex topic and is covered in the Manipulating string section of this guide. Reading numeric values To read numeric values from the target process, you can use the Read<T> method of the ProcessMemory class. This method takes either an address or a pointer path, and returns a result containing either the read value in the asked type, or a failure in case the read operation failed. Most numeric types are supported, including int, float, double, long, bool, and others. The read operation will attempt to read the value from the specified address or pointer path in the target process's memory. Here are some examples of how to read numeric values from the target process: Reading an integer value from a pointer path var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; // Read an integer value from the specified address. Default to 0 if the read fails. int health = processMemory.Read<int>(\"GameAssembly.dll+12345678\").ValueOr(0); Reading a float value from an address var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; // Read a float value from the specified address. Default to 0.0f if the read fails. float speed = processMemory.Read<float>(0x1A2B3C4).ValueOr(0.0f); Reading arbitrary structures When you need to read multiple values in the same structure, you can define a struct that represents the data structure you want to read, and then use the same Read<T> method to read the entire structure at once. This is more performant than reading each field individually, especially when using pointer paths. In most cases, you won't need all the fields of the structure, so you can define only the fields you are interested in. To handle these cases, you can use [FieldOffset] attributes to specify the offset of each field in the structure. This allows you to define a structure that only contains the fields you need, while still being able to read the entire structure in a single read operation. Here are some examples: Reading a custom unmarked structure // Define a structure that represents the data you want to read // Fields must be in the same order as they are in memory struct PlayerStats { public int Health; public float Speed; public long Score; } var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; PlayerStats playerStats = processMemory.Read<PlayerStats>(\"GameAssembly.dll+12345678\").ValueOrDefault(); Reading a custom structure with field offsets using System.Runtime.InteropServices; // Define a structure with explicit field offsets // This allows you to read only the fields you are interested in, even if they are not contiguous in memory. [StructLayout(LayoutKind.Explicit)] // This is required for field offsets to be respected struct PlayerStats { [FieldOffset(0x00)] public int Health; [FieldOffset(0x0A)] public float Speed; [FieldOffset(0xF0)] public long Score; } var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; PlayerStats playerStats = processMemory.Read<PlayerStats>(\"GameAssembly.dll+12345678\").ValueOrDefault(); // Remarks: even though only 3 fields are defined, the structure is 0xF8 bytes long, because it covers the whole memory // area from 0x00 to the highest field offset plus its length. Don't use this approach if your fields are too far apart. Reading raw bytes Sometimes, you may want to read raw bytes, without interpreting them as a specific type. You can use the ReadBytes method of the ProcessMemory class to read a specified number of bytes from a given address or pointer path. // Read 16 bytes from the specified address in the target process byte[] rawData = processMemory.ReadBytes(\"GameAssembly.dll+12345678\", 16).ValueOr([]); There is also a ReadBytesPartial method variant that takes a byte[] array as a parameter, and populates it with the read data. Contrary to ReadBytes, this method will not fail if only some bytes could be read, and will return the number of bytes that were actually read. // Read up to 2048 bytes into a buffer, and get the number of bytes actually read byte[] buffer = new byte[2048]; int bytesRead = processMemory.ReadBytesPartial(\"GameAssembly.dll+12345678\", buffer, 2048).ValueOr(0); Note ReadBytesPartial is only useful in particular cases, when reading large batches of an unreliable memory area. Most of the time, ReadBytes is simpler to use and preferable."
  },
  "guide/mcfeatures/results.html": {
    "href": "guide/mcfeatures/results.html",
    "title": "Understanding Results | MindControl",
    "summary": "Understanding Results Most methods in MindControl return a Result or Result<T> object, which encapsulates the success or failure of the operation, along with any relevant data or error messages. This allows you to handle errors gracefully and provides a consistent way to check the outcome of operations. For example, when you read a value from a process, you can check if the operation was successful and retrieve the value if it was: Result<int> readResult = processMemory.Read<int>(\"GameAssembly.dll+12345678\"); Instead of directly returning an int, and throwing an exception or returning 0 on failure, we get a Result<int>. You can then check if the read operation was successful using the IsSuccess property: if (readResult.IsSuccess) { int value = readResult.Value; // Use the value as needed } else { // Handle the error Console.WriteLine($\"Error reading value: {readResult.Failure.Message}\"); } This pattern is used throughout the MindControl library, allowing you to handle errors in a consistent way without relying on exceptions for control flow. Even though relying on exceptions is generally discouraged, because they are slower and tend to make the code harder to read, you can use the ThrowOnFailure() method to throw an exception if the operation failed, which can be useful in scenarios where you want to enforce error handling: readResult.ThrowOnFailure(); // Throws an exception if the read operation failed int value = readResult.Value; // After the exception check, you can safely use the value Note Accessing the Value property of an unsuccessful Result<T> will also throw an exception. If you prefer to discard errors and just use default values, you can use the ValueOrDefault() method, which returns the value if the operation was successful, or a default value (like 0 for numeric types) if it failed: int value = processMemory.Read<int>(\"GameAssembly.dll+12345678\").ValueOrDefault(); // value will be 0 if the read operation failed Alternatively, you can use ValueOr() to provide a custom default value: int value = processMemory.Read<int>(\"GameAssembly.dll+12345678\").ValueOr(42); // value will be 42 if the read operation failed The Failure object When an operation fails, the Result object contains a Failure property that provides detailed information about the error. The Failure base class itself contains only a Message property, that describes the error, but methods usually return a more specific type of Failure that provides additional context. // Ask the user for a pointer path string pointerPath = Console.ReadLine(); // Use the pointer path to read a value var readResult = processMemory.Read<int>(pointerPath); if (!readResult.IsSuccess) { // Handle the error in a different way based on the specific failure type // In this example, we just print a different message for each failure type, but the idea is that you can perform // different actions based on the type of failure if you need to. readResult.Failure switch { BaseModuleNotFoundFailure f => Console.WriteLine($\"The module you entered ({f.ModuleName}) is invalid!\"), DetachedProcessFailure _ => Console.WriteLine($\"The process has exited.\"), IncompatiblePointerPathBitnessFailure _ => Console.WriteLine(\"The pointer path you entered is not compatible with the 32-bit target process!\"), _ => Console.WriteLine($\"An unexpected error occurred: {readResult.Failure}\") }; return; } int value = readResult.Value; // (Use the value as needed)"
  },
  "guide/mcfeatures/searching.html": {
    "href": "guide/mcfeatures/searching.html",
    "title": "Searching for byte sequences or patterns | MindControl",
    "summary": "Searching for byte sequences or patterns This section explains how to search through the memory of the target process for specific byte sequences or byte patterns. This type of search is sometimes called \"AoB (Array of Bytes) scanning\", and it's useful to find specific data arrangements in memory, especially in cases where pointer paths fail or are harder to pull off. Let's jump right into an example to make things clearer. IEnumerable<UIntPtr> results = processMemory.SearchBytes(\"90 A8 00 00 ?? 42 A8\"); In this example, we are searching for a specific byte pattern in the target process's memory. The pattern consists of some set hexadecimal byte values, and the ?? is a wildcard that matches any byte value at that position. The search will return all addresses where this pattern is found. So this example would match, for instance, 90 A8 00 00 01 42 A8 or 90 A8 00 00 FF 42 A8, but not 90 A8 00 01 42 A8. Now, this example searches the entire memory of the target process, which is usually very slow, especially if your target process uses up a lot of memory. For modern 3D games, this can easily take over a minute. Let's dive into how to make this search more efficient. Note Do not start your patterns with a wildcard (??). Even though this is supported, it will slow down the search significantly, and has no practical purpose. You can remove leading wildcards from your patterns to achieve the same result without the performance hit. Restricting the search range The second parameter of the SearchBytes method allows you to specify a range of memory addresses to search in. This can significantly speed up the search process, especially if you know where the data you're looking for is likely to be located. MemoryRange range = new MemoryRange(0x10000000, 0x20000000); IEnumerable<UIntPtr> results = processMemory.SearchBytes(\"90 A8 00 00 ?? 42 A8\", range); The typical way to use this parameter is to get a specific module in the target process, and then search only within that module's memory range. Here's how: RemoteModule module = processMemory.GetModule(\"GameAssembly.dll\") ?? throw new Exception(\"Module not found\"); IEnumerable<UIntPtr> results = processMemory.SearchBytes(\"90 A8 00 00 ?? 42 A8\", module.GetRange()); Specifying settings to filter out invalid results Another way to both speed up the search and filter out unwanted results is to use the third FindBytesSettings parameter. This allows you to specify additional criteria for the search, to ignore certain ranges of memory depending on their properties, or to specify a maximum number of results. RemoteModule module = processMemory.GetModule(\"GameAssembly.dll\") ?? throw new Exception(\"Module not found\"); var settings = new FindBytesSettings { SearchReadable = true, // Only search in readable memory SearchWritable = null, // Don't care if the memory is writable or not SearchExecutable = false, // Ignore executable memory, because we are looking for data, not code MaxResultCount = 10 // Limit the number of results to 10 }; IEnumerable<UIntPtr> results = processMemory.SearchBytes(\"90 A8 00 00 ?? 42 A8\", range, settings); Using these settings can greatly improve the performance of your searches, but keep in mind that they are still extremely slow compared to pointer paths or direct memory reads. Use them only when you believe this is the best way to find the data you are looking for."
  },
  "guide/mcfeatures/streams.html": {
    "href": "guide/mcfeatures/streams.html",
    "title": "Using memory streams | MindControl",
    "summary": "Using memory streams For various use cases, you may need to read or write memory using streams. For these situations, MindControl provides a ProcessMemoryStream class, instantiated through a ProcessMemory instance. This can be useful to read or write large amounts of data in a more efficient way, or more generally to work with memory as if it were a file. // Get a stream that starts at a specific address in the target process ProcessMemoryStream stream = processMemory.GetMemoryStream(0x123456789); // Read from the stream byte[] buffer = new byte[1024]; int bytesRead = stream.Read(buffer, 0, buffer.Length); // Write to the stream stream.Write(buffer, 0, bytesRead); // Seek to a specific position in the stream (here, go 8 bytes after the initial address 0x123456789) stream.Seek(8, SeekOrigin.Begin); // Dispose the stream when done stream.Dispose(); Note Internally, the stream uses ReadPartial so that it will still read as much as possible upon reaching an unreadable section of memory. When failing to read a single byte, the Read method will return 0."
  },
  "guide/mcfeatures/strings.html": {
    "href": "guide/mcfeatures/strings.html",
    "title": "Manipulating strings | MindControl",
    "summary": "Manipulating strings Reading and writing strings in a process's memory is more complex than numeric values and requires understanding how strings are represented in memory. In this section, we will cover how strings are stored in memory, and how to manipulate them with MindControl. Understanding string representation in memory Intuitively, strings are sequences of characters, but in memory, they are represented as a sequence of bytes. In some way or another, these bytes represent the characters in the string. But because their length is variable, they are almost always referenced by a pointer. For example, a Player structure could have a Name field that holds a pointer to the start of the string in memory. Now, once you locate a string, the key is then to understand how to translate its bytes into characters and vice versa. Encodings The thing is, there are many ways to represent strings in memory, and it mostly comes down to what is called the \"encoding\". The encoding defines how characters are mapped to bytes. Some common encodings are: ASCII: Uses 1 byte per character, supports only the first 128 characters (English letters, digits, and some symbols). UTF-8: Uses 1 to 4 bytes per character, supports all Unicode characters, like symbols, chinese characters, emojis, etc. It is the most common encoding used in modern applications. UTF-16: Uses 2 bytes per character, also supports all Unicode characters, and is commonly used in Windows applications. You may also see other encodings like UTF-32, ISO-8859-1, or others. It all depends on the application and how it was developed. And in a single application, you may find different encodings used for different use cases, because some encodings are more efficient for certain types of data. For example, you may decide to use UTF-16 for a player name, to handle any language, but still use ASCII for internal item identifiers, because you don't need more than the English alphabet, and it uses up less memory. Let's take a look at some examples of how the same string is represented in memory with different encodings. Example: \"Hello, World!\" in different encodings Encoding Bytes in Hexadecimal ASCII 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 UTF-8 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 UTF-16 48 00 65 00 6C 00 6C 00 6F 00 2C 00 20 00 57 00 6F 00 72 00 6C 00 64 00 21 00 Example 2: \"こんにちは\" (Hello in Japanese) in different encodings Encoding Bytes in Hexadecimal ASCII (This string cannot be represented in ASCII) UTF-8 E3 81 93 E3 82 93 E3 81 AB E3 81 A1 E3 81 AF UTF-16 53 30 93 30 6B 30 61 30 6F 30 We can see several interesting things here: The ASCII and UTF-8 representations of \"Hello, World!\" are the same, because all characters in this string are part of the ASCII character set, and UTF-8 is designed to be backward compatible with ASCII. The Japanese string cannot be represented in ASCII, because it contains characters that are not part of the ASCII character set. However, it can be represented in both UTF-8 and UTF-16. UTF-16 always uses 2 bytes per character, which is kind of wasteful for ASCII-compatible strings like \"Hello, World!\" (you can see every second bit is a zero), but it ends up using way less space for the Japanese string. This is because it always uses 2 bytes per character, while UTF-8 has variable-length characters, meaning it has to dedicate extra bits to indicate one way or another how many bytes are used for each character in the string. So, after locating a string in memory, we need to find out what encoding is used to represent it. Knowing where the string stops When reading a string from memory, we also need to know where it ends. Because bytes in memory are not delimited and keep going on pretty much forever, it's important to know when to stop reading. And to do that, there are 2 main ways that programming languages and libraries use: Null-terminators: This is a special byte (00) or group of bytes (00 00) appended after the final character that indicates the end of the string. When reading a string, you keep reading bytes until you encounter a null terminator. This is common in C-style strings and is used in many programming languages. Length prefix: This is a byte or group of bytes before the first character of the string, that indicates how many bytes or characters follow it. When reading a string, you read the length first, and then read that many bytes. This is common in stacks like .net and Java. Sometimes, both techniques are used together, for compatibility. Example 1: Reading a string with a null terminator Let's say we have a string \"Hello, World!\" stored in memory as UTF-8, and we know it is null-terminated. The bytes in memory would look like this: 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 00 When reading this string, we would know to stop reading as soon as we encounter the null terminator 00. The resulting string would be \"Hello, World!\". Example 2: Reading a string with a length prefix Now, let's say we have the same string \"Hello, World!\" stored in memory as UTF-8, but this time we have identified that it has a length prefix of 2 bytes. The bytes in memory would look like this: 0D 00 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 When reading this string, knowing that it has a length prefix of 2 bytes, we would start by reading the length prefix 0D 00. This is the number 13, meaning that the string is 13 bytes long. Then we would know to read only the next 13 bytes, resulting in the string \"Hello, World!\". Type handles In some cases, especially in managed languages and frameworks like .net, strings, like any other object instance, start with a type handle. This is a pointer to a metadata structure that describes the type of the object (in this case, a string). This type handle is used for various purposes by the runtime. We don't care about this handle, but, when reading a string, we need to know if it exists and how long it is, so we can skip it. And when writing, we actually need to know the full handle, so we can write it properly, the way it would have been written by the runtime. An example of a typical .net string The .net standard for strings has all the things we've discussed so far, which makes it ideal for a final example. So let's take a look at a \"Hello, World!\" string in .net: C0 12 34 56 78 9A BC DE 0D 00 00 00 48 00 65 00 6C 00 6C 00 6F 00 2C 00 20 00 57 00 6F 00 72 00 6C 00 64 00 21 00 00 00 This string is represented in memory as follows: C0 12 34 56 78 9A BC DE: This is the .net type handle, which is a pointer to the metadata structure that describes the string type. This is an example, the actual handle will be different in every application, and even in every run of the same application. 0D 00 00 00: This is the length prefix. In .net, length prefixes are 4 bytes long, and indicate the number of characters. This one reads as 13 (0x0D) characters long. 48 00 65 00 6C 00 6C 00 6F 00 2C 00 20 00 57 00 6F 00 72 00 6C 00 64 00 21 00: These are the UTF-16 encoded characters of the string \"Hello, World!\", with each character taking up two bytes. 00 00: This is the null terminator, which indicates the end of the string. Because we are using UTF-16, the null terminator is represented as two bytes and not just one. We technically don't need it, because we have the length prefix, but .net still has this terminator for compatibility with other systems that expect it. Reading strings with MindControl There are several options to read strings in MindControl, depending on your needs and preferences. Using ReadStringPointer The ReadStringPointer method of the ProcessMemory class is the most versatile way to read strings from memory. It takes an address or a pointer path to the pointer to the string you want to read, along with a StringSettings object that defines how the string is represented in memory. This method will read the pointer, then read the string from the address it points to, and return the string value. Let's take an example to read the string from the previous example (a standard .net string): var stringSettings = new StringSettings( encoding: System.Text.Encoding.UTF8, isNullTerminated: true, lengthPrefix: new LengthPrefix(4, StringLengthUnit.Characters), // 4 byte length, counting characters (not bytes) typePrefix: new byte[] { 0xC0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE }); string? result = processMemory.ReadStringPointer(\"GameAssembly.dll+12345678\", stringSettings).ValueOrDefault(); In this example, we specify the encoding as UTF-8, the string is null-terminated, and it has a 4-byte length prefix that counts characters. We also provide the type handle as a byte array. The method will read the pointer at the specified address, then read the string from the address it points to, and return the string value. Note As stated before, this method takes the address of a pointer to the string, not the address of the start of the string itself. Using ReadRawString An alternative to ReadStringPointer is the ReadRawString method, which reads a string directly from the address or pointer path to its first character byte, without needing to provide a pointer to the string. This method is useful when you don't have a pointer to the string, or if you prefer to read the string directly from its starting address. Instead of a StringSettings object, this method takes an Encoding parameter to specify how the string is encoded, a max length that indicates when to stop, and a boolean to indicate if the string is null-terminated. A matching example for the previous string would look like this: // Note the 'C' offset at the end of the pointer path to skip the type handle (8 bytes) and the length prefix (4 bytes) string? result = processMemory.ReadRawString(\"GameAssembly.dll+12345678,C\", Encoding.UTF8, maxLength: 100, isNullTerminated: true).ValueOrDefault(); Note ReadRawString stops reading when it reaches the specified maximum length, or when it encounters a null terminator, whichever comes first. If you specify no null terminator, it will always read up to the maximum length. Determining the string settings automatically If you don't know the string settings, you can use observation and trial and error to determine them. However, MindControl provides a method that helps you pinpoint the string settings automatically. The FindStringSettings method takes an address or pointer path to a pointer to a string, and the expected string value, and returns a StringSettings object that matches the string representation in memory. It may not be ideal for all cases, especially because it requires you to know a string value that you expect to find in memory, but it can be useful especially when dealing with strings with a type handle that changes every time the application is run. // Determine the string settings automatically thanks to a known \"Hello, World!\" string somewhere in memory var expectedString = \"Hello, World!\"; StringSettings stringSettings = processMemory.FindStringSettings(\"GameAssembly.dll+12345678\", expectedString) .ValueOrDefault(); // Now you can use the string settings to read another string that you don't know string? anotherString = processMemory.ReadStringPointer(\"GameAssembly.dll+ABCDEF012\", stringSettings).ValueOrDefault(); Writing strings with MindControl By design, MindControl does not have a method that directly writes strings to memory. This is because it would make it too easy for users to make mistakes and either corrupt memory, or bloat memory with hundreds of thousands of strings that are never erased. This is because, unless you are certain that your new string is smaller than the original string you want to replace, you cannot simply overwrite the bytes of the original string with the bytes of your new string. If the new string is longer, you would end up writing past the end of the original string, which could corrupt memory and lead to crashes or unexpected behavior. Instead, you can write strings to memory by chaining multiple operations: (Optional) Use FindStringSettings on a known string to determine the string settings for the string you want to write. Use StoreString to store the value of the string somewhere in an allocated space in memory. Use Write to overwrite the pointer to the string with the address of your newly stored string. Here is a concrete example of exactly that: // Determine the string settings automatically thanks to a known \"Hello, World!\" string var expectedString = \"Hello, World!\"; StringSettings stringSettings = processMemory.FindStringSettings(\"GameAssembly.dll+12345678\", expectedString) .ValueOrDefault(); // Store the new string in memory using the determined string settings MemoryReservation reservation = processMemory.StoreString(\"New String Value\", stringSettings).ValueOrDefault(); // Write the pointer to the new string in the target process memory processMemory.Write(\"GameAssembly.dll+12345678\", reservation.Address).ThrowOnFailure(); Note Make sure to dispose of the MemoryReservation object when you no longer need it, to avoid memory leaks in the target process. If you constantly write new strings in this way without disposing of the old reservations, you will quickly end up consuming gigabytes of memory in the target process, which will lead to performance issues and crashes."
  },
  "guide/mcfeatures/writing.html": {
    "href": "guide/mcfeatures/writing.html",
    "title": "Writing to memory | MindControl",
    "summary": "Writing to memory This section will guide you through writing to memory in a target process using MindControl. Note Writing string values is a more complex topic and is covered in the Manipulating string section of this guide. Writing numeric values To write numeric values to the target process, you can use the Write method of the ProcessMemory class. This method takes either an address or a pointer path, and the value to write, and returns a result indicating whether the write operation was successful. Here are some examples of how to write numeric values to the target process: Writing an integer value to a pointer path var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; bool success = processMemory.Write(\"GameAssembly.dll+12345678\", 100).IsSuccess; Writing a float value to an address var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; bool success = processMemory.Write(0x1A2B3C4, 3.14f).IsSuccess; Writing arbitrary structures Just like when reading, you can define a struct that represents the data structure you want to write, and then use the Write<T> method to write the entire structure at once. This is more efficient than writing each field individually. Here are some examples: Writing a custom unmarked structure // Define a structure that represents the data you want to write // Fields must be in the same order as they are in memory struct PlayerStats { public int Health; public float Speed; public long Score; } var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; bool success = processMemory.Write(\"GameAssembly.dll+12345678\", new PlayerStats { Health = 100, Speed = 5.0f, Score = 1000 }).IsSuccess; Writing a custom structure with field offsets using System.Runtime.InteropServices; // See the previous section for more details on how to define structures with field offsets. [StructLayout(LayoutKind.Explicit)] struct PlayerStats { [FieldOffset(0x00)] public int Health; [FieldOffset(0x0A)] public float Speed; [FieldOffset(0xF0)] public long Score; } var processMemory = MindControl.ProcessMemory.OpenProcessByName(\"MyTargetProcess\").Value; bool success = processMemory.Write(\"GameAssembly.dll+12345678\", new PlayerStats { Health = 100, Speed = 5.0f, Score = 1000 }).IsSuccess; Writing raw bytes If you need to write raw bytes to a specific address or pointer path, you can use the WriteBytes method. This method takes a byte array and writes it to the specified location in the target process. byte[] dataToWrite = new byte[] { 0x90, 0x90, 0x90 }; bool success = processMemory.WriteBytes(\"GameAssembly.dll+12345678\", dataToWrite).IsSuccess; Memory protection strategies All writing methods in MindControl have an additional parameter that allows you to specify how to handle memory protection. There are three options: MemoryProtectionStrategy.Ignore: No protection removal. The write will fail if the memory is protected, but if you know it isn't, this is the most performant option. MemoryProtectionStrategy.Remove: Removes the memory protection before writing. Memory protection will not be restored after the write operation, which may cause issues in some cases, but may be more performant than restoring it. MemoryProtectionStrategy.RemoveAndRestore: Temporarily removes the memory protection to allow writing, then restores it. This is the safest, but least performant option. The default strategy is MemoryProtectionStrategy.RemoveAndRestore, for best compatibility. You can change this by passing a different strategy to the Write method. bool success = processMemory.Write(\"GameAssembly.dll+12345678\", 100, MemoryProtectionStrategy.Ignore).IsSuccess;"
  },
  "guide/project-setup/blazor-setup.html": {
    "href": "guide/project-setup/blazor-setup.html",
    "title": "Setting up MindControl in a Blazor (web) application | MindControl",
    "summary": "Setting up MindControl in a Blazor (web) application This section will guide you through setting up a new Blazor application project that uses the MindControl library to interact with the memory of a target process. We will use the Slime Rancher demo (see the requirements page for more info) as our target process, but feel free to use any other target. Define the scope of your project Before we start, let's define what our project should do. In our example, we are going to set up a very simple page, with an editable field for the player's current coin count, with real-time synchronization. Create a new Blazor project First, we need to create a new Blazor application project. There are two types of Blazor applications: Blazor Server and Blazor WebAssembly. Explaining the differences is beyond the scope of this guide, but Blazor server is perfect for our purposes, because it has a built-in mechanism to constantly stream updates from the server app to the browser. Open a command line interface and navigate to the directory where you want to create the project. Then, run the following command to create your project from scratch: dotnet new blazor -n MyMindControlWebProject --empty cd MyMindControlWebProject Note We are using the dotnet command-line tool here, but feel free to use your IDE of choice if you prefer. Add the MindControl library to your project Next, we need to add the MindControl library to our project. Run the following command to add the library to your project: dotnet add package MindControl This will reference the latest stable version of the MindControl library in your project using NuGet. Develop your memory hacking features in a new class It's a good idea to separate your memory hacking features from the rest of your application. This way, you can keep your code organized and easy to maintain. Let's create a new class called SlimeRancherDemo in a new file called SlimeRancherDemo.cs. This class will be our entry point for interacting with the target process, and will define methods for every memory hack our program is able to do. using MindControl; namespace MyMindControlWebProject; public class SlimeRancherDemo { // We have determined the memory path to the coin count value in the target process using Cheat Engine. See the tutorials in this guide to learn how to do this. private readonly PointerPath _coinCountPath = \"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"; // Use the name of your target process here. private readonly ProcessTracker _processTracker = new(\"SlimeRancher\"); public int? GetCoinCount() { var process = _processTracker.GetProcessMemory(); if (process == null) return null; // The target process is not running // Try to read the coin count value from the target process var coinCountResult = process.Read<int>(_coinCountPath); if (!coinCountResult.IsSuccess) { // The coin count value could not be read (maybe we are in the main menu) // Check coinCountResult.Failure for more information return null; } return coinCountResult.Value; } public bool SetCoinCount(int newCoinCount) { var process = _processTracker.GetProcessMemory(); if (process == null) return false; // The target process is not running // Try to write the new coin count value to the target process, and return true if successful var writeResult = process.Write(_coinCountPath, newCoinCount); return writeResult.IsSuccess; } } Note In the next chapter of this guide, we will explain how to use the classes and methods provided by MindControl. For now, we are just focusing on getting a basic project set up. As you can see, in our case, we defined two methods: GetCoinCount and SetCoinCount. Register the service in the Program.cs file Now that we have our memory hacking features defined, we need to register the SlimeRancherDemo service in the Program.cs file so that we can use it in our Blazor components. Open the Program.cs file and add the following code right before the builder.Build() line: // Register the SlimeRancherDemoService as a singleton, so it can be used by multiple pages and components. builder.Services.AddSingleton<MyMindControlWebProject.SlimeRancherDemo>(); Implementing the page Now that we have our memory hacking features defined, let's work on the page itself. In Blazor, pages are defined in .razor files. The template already has a home page in Components/Pages/Home.razor, so let's edit that file to make our page. @page \"/\" @* Specifying the render mode as InteractiveServer allows us to use server-side rendering with interactive components, which is crucial in our case because the client (the browser) cannot directly access the Slime Rancher game state. *@ @rendermode InteractiveServer @* We can access the SlimeRancherDemo service using injection because we have registered it in the Program.cs file *@ @inject SlimeRancherDemo _slimeRancherDemo <PageTitle>Home</PageTitle> <div class=\"field\"> <label for=\"coins\">Coins</label> <input type=\"number\" value=\"@_coinCount\" id=\"coins\" @oninput=\"OnCoinsModified\" /> </div> @code { public int _coinCount; private readonly System.Timers.Timer _stateUpdateTimer = new System.Timers.Timer(TimeSpan.FromMilliseconds(100)); protected override void OnInitialized() { _stateUpdateTimer.Elapsed += OnStateUpdateTimerElapsed; _stateUpdateTimer.Start(); } /// <summary>Called when the timer ticks, every 100ms.</summary> private void OnStateUpdateTimerElapsed(object? sender, System.Timers.ElapsedEventArgs e) { _coinCount = _slimeRancherDemo.GetCoinCount() ?? 0; // Update the UI with StateHasChanged. We need to do that manually when new data comes from events or timers. InvokeAsync(StateHasChanged); } /// <summary>Called when the coin input value is modified manually.</summary> private void OnCoinsModified(ChangeEventArgs e) { // Make sure the input value is a valid number if (!int.TryParse(e.Value?.ToString(), out int coins)) return; _slimeRancherDemo.SetCoinCount(coins); } } This code defines a simple page with an input field for the coin count. The input field is bound to the _coinCount variable, which is updated every 100 milliseconds by the timer we set up in the OnInitialized method. When the user modifies the input field, the OnCoinsModified method is called (through the oninput event), which updates the coin count in the game. At this stage, the program should be complete and functional. You can run it using dotnet run from the project directory and try it out. Note You may need to manually access the page in your browser by navigating to the link output by the application after running it, which should look like http://localhost:5273. Try spending or earning coins in the game, and see how the coin count updates in real-time in your application. You can also change the coin count value in the input field, and it will be reflected in the game. Going further Now, to learn how to use classes and methods provided by the MindControl library, check out the next chapter of this guide. Alternatively, if you want to see a more advanced example of a Blazor application using the MindControl library, check out the MindControl Blazor app sample in the MindControl repository. Here is a breakdown of the features in the sample: Fully automated process tracking (process detection with no need for user input, supports the game closing and restarting). Editable sliders and input fields, synchronized in real-time with the game, for the player's health, stamina, and coin count values. A button to toggle infinite stamina."
  },
  "guide/project-setup/console-setup.html": {
    "href": "guide/project-setup/console-setup.html",
    "title": "Setting up MindControl in a console application | MindControl",
    "summary": "Setting up MindControl in a console application This section will guide you through setting up a new console application project that uses the MindControl library to interact with the memory of a target process. We will use the Slime Rancher demo (see the requirements page for more info) as our target process, but feel free to use any other target. Define the scope of your project Before we start, let's define what our project should do. In our example, we are going to set up a very simple program that reads the player's current coin count in our target game, and then after pressing a key, we will increment the coin count by 1000. Create a new console application project First, we need to create a new console application project. Open a command line interface and navigate to the directory where you want to create the project. Then, run the following command to create your project from scratch: dotnet new console -n MyMindControlProject cd MyMindControlProject Note We are using the dotnet command-line tool here, but feel free to use your IDE of choice if you prefer. Add the MindControl library to your project Next, we need to add the MindControl library to our project. Run the following command to add the library to your project: dotnet add package MindControl This will reference the latest stable version of the MindControl library in your project using NuGet. Develop your memory hacking features in a new class It's a good idea to separate your memory hacking features from the rest of your application. This way, you can keep your code organized and easy to maintain. Let's create a new class called SlimeRancherDemo in a new file called SlimeRancherDemo.cs. This class will be our entry point for interacting with the target process, and will define methods for every memory hack our program is able to do. using MindControl; namespace MyMindControlProject; public class SlimeRancherDemo { // We have determined the memory path to the coin count value in the target process using Cheat Engine. See the tutorials in this guide to learn how to do this. private readonly PointerPath _coinCountPath = \"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"; // Use the name of your target process here. private readonly ProcessTracker _processTracker = new(\"SlimeRancher\"); public int? GetCoinCount() { var process = _processTracker.GetProcessMemory(); if (process == null) return null; // The target process is not running // Try to read the coin count value from the target process var coinCountResult = process.Read<int>(_coinCountPath); if (!coinCountResult.IsSuccess) { // The coin count value could not be read (maybe we are in the main menu) // Check coinCountResult.Failure for more information return null; } return coinCountResult.Value; } public bool SetCoinCount(int newCoinCount) { var process = _processTracker.GetProcessMemory(); if (process == null) return false; // The target process is not running // Try to write the new coin count value to the target process, and return true if successful var writeResult = process.Write(_coinCountPath, newCoinCount); return writeResult.IsSuccess; } } Note In the next chapter of this guide, we will explain how to use the classes and methods provided by MindControl. For now, we are just focusing on getting a basic project set up. As you can see, in our case, we defined two methods: GetCoinCount and SetCoinCount. Implement the main program logic Now that we have our memory hacking features defined, let's implement the main program logic in the Program.cs file. This is where we will interact with the SlimeRancherDemo class we just created. using MyMindControlProject; var slimeRancher = new SlimeRancherDemo(); Console.WriteLine(\"Press any key to read the current coin count.\"); Console.ReadKey(true); int? coinCount = slimeRancher.GetCoinCount(); if (coinCount == null) { Console.WriteLine(\"Could not read the coin count. Make sure the game is running, and a new game is started.\"); return; } Console.WriteLine($\"Current coin count: {coinCount}\"); Console.WriteLine(\"Press any key to add 1000 coins.\"); Console.ReadKey(true); bool isWriteSuccessful = slimeRancher.SetCoinCount(coinCount.Value + 1000); if (!isWriteSuccessful) { Console.WriteLine(\"Could not write the new coin count. Make sure the game is running, and a new game is started.\"); return; } Console.WriteLine(\"Coin count updated successfully.\"); This code will read the current coin count from the target process, display it to the user, and then increment the coin count by 1000. Feel free to modify this code to fit your own project. As of this stage, the program should be complete and functional. You can run it using dotnet run from the project directory and try it out. Going further Now, to learn how to use classes and methods provided by the MindControl library, check out the next chapter of this guide. Alternatively, if you want to see a more advanced example of a console application using the MindControl library, check out the MindControl console app sample in the MindControl repository. Here is a breakdown of the features in the sample: Fully automatic process tracking (process detection with no need for user input, supports the game closing and restarting, etc). A live view of the player's current coin count, health, and stamina values, automatically updated multiple times per second. Simple user input to change the player's coin count, health, and stamina values. A command to toggle infinite stamina."
  },
  "guide/project-setup/creating-mc-project.html": {
    "href": "guide/project-setup/creating-mc-project.html",
    "title": "Creating a MindControl project | MindControl",
    "summary": "Creating a MindControl project In this chapter, we are going to implement a simple example program that uses the MindControl library to interact with the memory of our example target process, the Slime Rancher demo. Requirements Before we start, make sure the .net SDK is installed on your system. You can download it from the official Microsoft .net website. Pick the latest LTS (Long-Term Support) version. Alternatively, you can use Visual Studio or your .net IDE of choice, which should come with the .net SDK. To make sure everyone can follow equally, this guide will not assume any particular IDE and use the dotnet command-line tool included in the SDK, instead of IDE-specific instructions. This guide assumes you have a basic understanding of C# programming. If you are new to C#, you can learn in the official Microsoft C# portal. What do you want to build? This guide will show an implementation for multiple different scenarios. It's not necessary to read through them all, just pick the one you are most interested in building. Console application Console apps are the simplest to develop, but also the most limited choice in terms of interface. Follow the Console application implementation guide WPF (desktop) application WPF apps provide a rich desktop interface that can be customized to your liking. Follow the WPF application implementation guide Blazor (web) application Blazor server apps are web applications. They can be accessed through a web browser, and provide a rich interface that can also be reached from other devices, as long as the server app runs on the same machine as the target process. Follow the Blazor application implementation guide Want to build something that isn't listed here? If you prefer to build a WinForms app, an ASP .net Core web app, a Windows service, or any other type of .net application, you can still follow the general guidelines in the Console application implementation guide. You should be able to adapt the code to your preferred type of application relatively easily."
  },
  "guide/project-setup/wpf-setup.html": {
    "href": "guide/project-setup/wpf-setup.html",
    "title": "Setting up MindControl in a WPF application | MindControl",
    "summary": "Setting up MindControl in a WPF application This section will guide you through setting up a new WPF application project that uses the MindControl library to interact with the memory of a target process. We will use the Slime Rancher demo (see the requirements page for more info) as our target process, but feel free to use any other target. Define the scope of your project Before we start, let's define what our project should do. In our example, we are going to set up a very simple window, with an editable field for the player's current coin count, with real-time synchronization. Create a new WPF application project First, we need to create a new console application project. Open a command line interface and navigate to the directory where you want to create the project. Then, run the following command to create your project from scratch: dotnet new wpf -n MyMindControlWpfProject cd MyMindControlWpfProject Note We are using the dotnet command-line tool here, but feel free to use your IDE of choice if you prefer. Add the MindControl library to your project Next, we need to add the MindControl library to our project. Run the following command to add the library to your project: dotnet add package MindControl This will reference the latest stable version of the MindControl library in your project using NuGet. Develop your memory hacking features in a new class It's a good idea to separate your memory hacking features from the rest of your application. This way, you can keep your code organized and easy to maintain. Let's create a new class called SlimeRancherDemo in a new file called SlimeRancherDemo.cs. This class will be our entry point for interacting with the target process, and will define methods for every memory hack our program is able to do. using MindControl; namespace MyMindControlWpfProject; public class SlimeRancherDemo { // We have determined the memory path to the coin count value in the target process using Cheat Engine. See the tutorials in this guide to learn how to do this. private readonly PointerPath _coinCountPath = \"UnityPlayer.dll+0168EEA0,8,100,28,20,80\"; // Use the name of your target process here. private readonly ProcessTracker _processTracker = new(\"SlimeRancher\"); public int? GetCoinCount() { var process = _processTracker.GetProcessMemory(); if (process == null) return null; // The target process is not running // Try to read the coin count value from the target process var coinCountResult = process.Read<int>(_coinCountPath); if (!coinCountResult.IsSuccess) { // The coin count value could not be read (maybe we are in the main menu) // Check coinCountResult.Failure for more information return null; } return coinCountResult.Value; } public bool SetCoinCount(int newCoinCount) { var process = _processTracker.GetProcessMemory(); if (process == null) return false; // The target process is not running // Try to write the new coin count value to the target process, and return true if successful var writeResult = process.Write(_coinCountPath, newCoinCount); return writeResult.IsSuccess; } } Note In the next chapter of this guide, we will explain how to use the classes and methods provided by MindControl. For now, we are just focusing on getting a basic project set up. As you can see, in our case, we defined two methods: GetCoinCount and SetCoinCount. Implementing the application logic Now that we have our memory hacking features defined, let's work on the application logic. We are going to use the MVVM (Model-View-ViewModel) pattern to separate our application logic from the user interface. This is a very common pattern in WPF applications, that helps keep the code organized and maintainable. So let's make a ViewModel that will hold our coin count and update it in real-time. Create a new file called MainViewModel.cs in the project directory, and add the following code: using System.ComponentModel; using System.Runtime.CompilerServices; namespace MyMindControlWpfProject; public class MainViewModel : INotifyPropertyChanged { private readonly SlimeRancherDemo _slimeRancherDemo = new(); private int _coinCount; public int CoinCount { get => _coinCount; set => SetProperty(ref _coinCount, value); } // We set up a timer to update the displayed game values every 100 milliseconds. private readonly System.Timers.Timer _stateUpdateTimer = new(TimeSpan.FromMilliseconds(100)); public MainViewModel() { _stateUpdateTimer.Elapsed += OnStateUpdateTimerTick; _stateUpdateTimer.Start(); } /// <summary>Called from the view when the user inputs a new value for the coin count.</summary> public void OnCoinCountInput() => _slimeRancherDemo.SetCoinCount(CoinCount); /// <summary>Called every time the refresh timer ticks.</summary> private void OnStateUpdateTimerTick(object? sender, EventArgs e) { CoinCount = _slimeRancherDemo.GetCoinCount() ?? 0; } // The code below is boilerplate code for implementing INotifyPropertyChanged. // Feel free to move that to a base class if you want to reuse it in other view models. public event PropertyChangedEventHandler? PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null!) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null!) { if (Equals(field, value)) return false; field = value; OnPropertyChanged(propertyName); return true; } } This is the code that will handle our main window logic. It will update the coin count every 100 milliseconds, and it will also allow the user to input a new coin count value that will be reflected instantly in-game. Setting up the user interface Now, open the MainWindow.xaml file and set up the user interface. Here is a simple example of how you can do that: <Window x:Class=\"MyMindControlWpfProject.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Slime Rancher Demo Trainer\" Height=\"200\" Width=\"400\"> <StackPanel Margin=\"10\"> <TextBlock Text=\"Current Coin Count:\" Margin=\"0,0,0,10\"/> <TextBox Text=\"{Binding CoinCount, UpdateSourceTrigger=PropertyChanged}\" Width=\"100\" TextChanged=\"OnCoinCountInput\"/> </StackPanel> </Window> And finally, edit the MainWindow.xaml.cs file to set the DataContext to our MainViewModel and define the OnCoinCountInput method: using System.Windows; using System.Windows.Controls; namespace MyMindControlWpfProject; public partial class MainWindow : Window { private readonly MainViewModel _viewModel; public MainWindow() { InitializeComponent(); _viewModel = new MainViewModel(); DataContext = _viewModel; } private void OnCoinCountInput(object sender, TextChangedEventArgs e) { _viewModel.OnCoinCountInput(); } } As of this stage, the program should be complete and functional. You can run it using dotnet run from the project directory and try it out. Try spending or earning coins in the game, and see how the coin count updates in real-time in your application. You can also change the coin count value in the input field, and it will be reflected in the game. Going further Now, to learn how to use classes and methods provided by the MindControl library, check out the next chapter of this guide. Alternatively, if you want to see a more advanced example of a WPF application using the MindControl library, check out the MindControl WPF app sample in the MindControl repository. Here is a breakdown of the features in the sample: Fully automated process tracking (process detection with no need for user input, supports the game closing and restarting, tracks when in the main menu). Editable sliders and input fields, synchronized in real-time with the game, for the player's health, stamina, and coin count values. A button to toggle infinite stamina."
  },
  "index.html": {
    "href": "index.html",
    "title": "MindControl Documentation | MindControl",
    "summary": "MindControl Documentation This is the documentation for MindControl, a .net library for memory manipulation and process hacking. It provides a set of features to manipulate memory in other processes, making it useful for game hacking, debugging, and reverse engineering. Start with the Introduction and navigate through the pages to learn about the features and how to use them. The documentation also includes a tutorial to hacking in general, if you are new."
  }
}
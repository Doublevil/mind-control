<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Class ProcessMemoryHookExtensions | MindControl </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Class ProcessMemoryHookExtensions | MindControl ">
      
      <meta name="description" content="Provides extension methods for  related to code hooks.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Doublevil/mind-control/new/v1.0.0/apiSpec/new?filename=MindControl_Hooks_ProcessMemoryHookExtensions.md&amp;value=---%0Auid%3A%20MindControl.Hooks.ProcessMemoryHookExtensions%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="MindControl">
            MindControl
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="MindControl.Hooks.ProcessMemoryHookExtensions">



  <h1 id="MindControl_Hooks_ProcessMemoryHookExtensions" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions" class="text-break">
Class ProcessMemoryHookExtensions  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L10"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="MindControl.html">MindControl</a>.<a class="xref" href="MindControl.Hooks.html">Hooks</a></dd></dl>
  <dl><dt>Assembly</dt><dd>MindControl.Code.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Provides extension methods for <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a> related to code hooks.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static class ProcessMemoryHookExtensions</code></pre>
  </div>




  <dl class="typelist inheritance">
    <dt>Inheritance</dt>
    <dd>
      <div><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object">object</a></div>
      <div><span class="xref">ProcessMemoryHookExtensions</span></div>
    </dd>
  </dl>



  <dl class="typelist inheritedMembers">
    <dt>Inherited Members</dt>
    <dd>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">object.Equals(object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object-system-object)">object.Equals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode">object.GetHashCode()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.gettype">object.GetType()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.memberwiseclone">object.MemberwiseClone()</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.referenceequals">object.ReferenceEquals(object, object)</a>
    </div>
    <div>
      <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.object.tostring">object.ToString()</a>
    </div>
  </dd></dl>






  <h2 class="section" id="methods">Methods
</h2>


  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_MindControl_PointerPath_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook(MindControl.ProcessMemory,MindControl.PointerPath,Iced.Intel.Assembler,MindControl.Hooks.HookOptions)">
  Hook(ProcessMemory, PointerPath, Assembler, HookOptions)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L119"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code into the target process to be executed when the instruction at the executable address pointed by
the given pointer path is reached. Depending on the options, the injected code may replace the original target
instruction, or get executed either before or after it. If specified, additional instructions that save and
restore registers will be added to the injected code.
Execution of the original code will then continue normally (unless the provided code is designed otherwise).
This signature uses an assembler, which is recommended, especially if your code contains instructions with
relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to
the intended locations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; Hook(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, Assembler codeAssembler, HookOptions options)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionPointerPath</code> <a class="xref" href="MindControl.PointerPath.html">PointerPath</a></dt>
    <dd><p>Pointer path to the first byte of the instruction to hook into.</p>
</dd>
    <dt><code>codeAssembler</code> <span class="xref">Assembler</span></dt>
    <dd><p>Code assembler loaded with instructions to inject into the target process. The jump
back to the original code will be appended automatically, so it is not necessary to include it.</p>
</dd>
    <dt><code>options</code> <a class="xref" href="MindControl.Hooks.HookOptions.html">HookOptions</a></dt>
    <dd><p>Options defining how the hook works.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains a reference to the injected code reservation
and allows you to revert the hook, or a failure.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_MindControl_PointerPath_System_Byte___MindControl_Hooks_HookOptions_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook(MindControl.ProcessMemory,MindControl.PointerPath,System.Byte[],MindControl.Hooks.HookOptions)">
  Hook(ProcessMemory, PointerPath, byte[], HookOptions)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L46"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code into the target process to be executed when the instruction at the executable address pointed by
the given pointer path is reached. Depending on the options, the injected code may replace the original target
instruction, or get executed either before or after it. If specified, additional instructions that save and
restore registers will be added to the injected code.
Execution of the original code will then continue normally (unless the provided code is designed otherwise).
This signature uses a byte array containing the code to inject. If your code contains instructions with relative
operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_">Hook(ProcessMemory, nuint, Assembler, HookOptions)</a> signature.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; Hook(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, byte[] code, HookOptions options)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionPointerPath</code> <a class="xref" href="MindControl.PointerPath.html">PointerPath</a></dt>
    <dd><p>Pointer path to the first byte of the instruction to hook into.</p>
</dd>
    <dt><code>code</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>Assembled code to inject into the target process. The jump back to the original code will be
appended automatically, so it is not necessary to include it. Warning: if your code contains instructions with
relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_MindControl_PointerPath_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_">Hook(ProcessMemory, PointerPath, Assembler, HookOptions)</a> signature.</p>
</dd>
    <dt><code>options</code> <a class="xref" href="MindControl.Hooks.HookOptions.html">HookOptions</a></dt>
    <dd><p>Options defining how the hook works.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains a reference to the injected code reservation
and allows you to revert the hook, or a failure.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook(MindControl.ProcessMemory,System.UIntPtr,Iced.Intel.Assembler,MindControl.Hooks.HookOptions)">
  Hook(ProcessMemory, nuint, Assembler, HookOptions)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L149"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code into the target process to be executed when the instruction at the given executable address is
reached. Depending on the options, the injected code may replace the original target instruction, or get
executed either before or after it. If specified, additional instructions that save and restore registers will
be added to the injected code.
Execution of the original code will then continue normally (unless the provided code is designed otherwise).
This signature uses an assembler, which is recommended, especially if your code contains instructions with
relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to
the intended locations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; Hook(this ProcessMemory processMemory, nuint targetInstructionAddress, Assembler codeAssembler, HookOptions options)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uintptr">nuint</a></dt>
    <dd><p>Address of the first byte of the instruction to hook into.</p>
</dd>
    <dt><code>codeAssembler</code> <span class="xref">Assembler</span></dt>
    <dd><p>Code assembler loaded with instructions to inject into the target process. The jump
back to the original code will be appended automatically, so it is not necessary to include it.</p>
</dd>
    <dt><code>options</code> <a class="xref" href="MindControl.Hooks.HookOptions.html">HookOptions</a></dt>
    <dd><p>Options defining how the hook works.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains a reference to the injected code reservation
and allows you to revert the hook, or a failure.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_System_Byte___MindControl_Hooks_HookOptions_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.Hook(MindControl.ProcessMemory,System.UIntPtr,System.Byte[],MindControl.Hooks.HookOptions)">
  Hook(ProcessMemory, nuint, byte[], HookOptions)
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L78"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code into the target process to be executed when the instruction at the given executable address is
reached. Depending on the options, the injected code may replace the original target instruction, or get
executed either before or after it. If specified, additional instructions that save and restore registers will
be added to the injected code.
Execution of the original code will then continue normally (unless the provided code is designed otherwise).
This signature uses a byte array containing the code to inject. If your code contains instructions with relative
operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_">Hook(ProcessMemory, nuint, Assembler, HookOptions)</a> signature.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; Hook(this ProcessMemory processMemory, nuint targetInstructionAddress, byte[] code, HookOptions options)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uintptr">nuint</a></dt>
    <dd><p>Address of the first byte of the instruction to hook into.</p>
</dd>
    <dt><code>code</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>Assembled code to inject into the target process. The jump back to the original code will be
appended automatically, so it is not necessary to include it. Warning: if your code contains instructions with
relative operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_">Hook(ProcessMemory, nuint, Assembler, HookOptions)</a> signature.</p>
</dd>
    <dt><code>options</code> <a class="xref" href="MindControl.Hooks.HookOptions.html">HookOptions</a></dt>
    <dd><p>Options defining how the hook works.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains a reference to the injected code reservation
and allows you to revert the hook, or a failure.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt(MindControl.ProcessMemory,MindControl.PointerPath,Iced.Intel.Assembler,MindControl.Hooks.HookRegister[])">
  InsertCodeAt(ProcessMemory, PointerPath, Assembler, params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L270"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code in the process to be executed right before the instruction pointed by the given pointer path, by
performing a hook.
This signature uses an assembler, which is recommended, especially if your code contains instructions with
relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to
the intended locations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; InsertCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, Assembler codeAssembler, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionPointerPath</code> <a class="xref" href="MindControl.PointerPath.html">PointerPath</a></dt>
    <dd><p>Pointer path to the first byte of the target instruction. The
injected code will be executed just before the instruction.</p>
</dd>
    <dt><code>codeAssembler</code> <span class="xref">Assembler</span></dt>
    <dd><p>Code assembler loaded with instructions to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains the memory reservation holding the
injected code and also allows you to revert the operation, or a failure.</p>
</dd>
  </dl>







  <h4 class="section" id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_Iced_Intel_Assembler_MindControl_Hooks_HookRegister____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is essentially a shortcut for <a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_MindControl_PointerPath_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_">Hook(ProcessMemory, PointerPath, Assembler, HookOptions)</a>
with the execution mode set to <a class="xref" href="MindControl.Hooks.HookExecutionMode.html#MindControl_Hooks_HookExecutionMode_ExecuteInjectedCodeFirst">ExecuteInjectedCodeFirst</a>. It is provided for
convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to
achieve the same result.</p>
</div>




  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_System_Byte___MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt(MindControl.ProcessMemory,MindControl.PointerPath,System.Byte[],MindControl.Hooks.HookRegister[])">
  InsertCodeAt(ProcessMemory, PointerPath, byte[], params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L216"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code in the process to be executed right before the instruction pointed by the given pointer path, by
performing a hook.
This signature uses a byte array containing the code to inject. If your code contains instructions with relative
operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___">InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[])</a> signature.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; InsertCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, byte[] code, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionPointerPath</code> <a class="xref" href="MindControl.PointerPath.html">PointerPath</a></dt>
    <dd><p>Pointer path to the first byte of the target instruction. The
injected code will be executed just before the instruction.</p>
</dd>
    <dt><code>code</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>Assembled code to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains the memory reservation holding the
injected code and also allows you to revert the operation, or a failure.</p>
</dd>
  </dl>







  <h4 class="section" id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_System_Byte___MindControl_Hooks_HookRegister____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is essentially a shortcut for <a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_MindControl_PointerPath_System_Byte___MindControl_Hooks_HookOptions_">Hook(ProcessMemory, PointerPath, byte[], HookOptions)</a> with
the execution mode set to <a class="xref" href="MindControl.Hooks.HookExecutionMode.html#MindControl_Hooks_HookExecutionMode_ExecuteInjectedCodeFirst">ExecuteInjectedCodeFirst</a>. It is provided for
convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to
achieve the same result.</p>
</div>




  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt(MindControl.ProcessMemory,System.UIntPtr,Iced.Intel.Assembler,MindControl.Hooks.HookRegister[])">
  InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L297"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code in the process to be executed right before the instruction at the given address, by performing a
hook.
This signature uses an assembler, which is recommended, especially if your code contains instructions with
relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to
the intended locations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; InsertCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, Assembler codeAssembler, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uintptr">nuint</a></dt>
    <dd><p>Address of the first byte of the target instruction. The injected code
will be executed just before the instruction.</p>
</dd>
    <dt><code>codeAssembler</code> <span class="xref">Assembler</span></dt>
    <dd><p>Code assembler loaded with instructions to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains the memory reservation holding the
injected code and also allows you to revert the operation, or a failure.</p>
</dd>
  </dl>







  <h4 class="section" id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookRegister____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is essentially a shortcut for <a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookOptions_">Hook(ProcessMemory, nuint, Assembler, HookOptions)</a> with
the execution mode set to <a class="xref" href="MindControl.Hooks.HookExecutionMode.html#MindControl_Hooks_HookExecutionMode_ExecuteInjectedCodeFirst">ExecuteInjectedCodeFirst</a>. It is provided for
convenience, readability, and discoverability for users who might not be familiar with hooks but are looking to
achieve the same result.</p>
</div>




  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_System_UIntPtr_System_Byte___MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.InsertCodeAt(MindControl.ProcessMemory,System.UIntPtr,System.Byte[],MindControl.Hooks.HookRegister[])">
  InsertCodeAt(ProcessMemory, nuint, byte[], params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L243"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Injects code in the process to be executed right before the instruction at the given address, by performing a
hook.
This signature uses a byte array containing the code to inject. If your code contains instructions with relative
operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_System_UIntPtr_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___">InsertCodeAt(ProcessMemory, nuint, Assembler, params HookRegister[])</a> signature.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeHook&gt; InsertCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, byte[] code, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uintptr">nuint</a></dt>
    <dd><p>Address of the first byte of the target instruction. The injected code
will be executed just before the instruction.</p>
</dd>
    <dt><code>code</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>Assembled code to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a>&gt;</dt>
    <dd><p>A result holding either a code hook instance that contains the memory reservation holding the
injected code and also allows you to revert the operation, or a failure.</p>
</dd>
  </dl>







  <h4 class="section" id="MindControl_Hooks_ProcessMemoryHookExtensions_InsertCodeAt_MindControl_ProcessMemory_System_UIntPtr_System_Byte___MindControl_Hooks_HookRegister____remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This method is essentially a shortcut for <a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_Hook_MindControl_ProcessMemory_System_UIntPtr_System_Byte___MindControl_Hooks_HookOptions_">Hook(ProcessMemory, nuint, byte[], HookOptions)</a> with the
execution mode set to <a class="xref" href="MindControl.Hooks.HookExecutionMode.html#MindControl_Hooks_HookExecutionMode_ExecuteInjectedCodeFirst">ExecuteInjectedCodeFirst</a>. It is provided for convenience,
readability, and discoverability for users who might not be familiar with hooks but are looking to achieve the
same result.</p>
</div>




  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_System_Int32_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt(MindControl.ProcessMemory,MindControl.PointerPath,System.Int32,Iced.Intel.Assembler,MindControl.Hooks.HookRegister[])">
  ReplaceCodeAt(ProcessMemory, PointerPath, int, Assembler, params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L416"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Replaces the instruction or instructions pointed by the given pointer path with the provided code. If the
injected code does not fit in the space occupied by the original instructions, a hook will be performed so that
the injected code can still be executed instead of the original instructions.
This signature uses an assembler, which is recommended, especially if your code contains instructions with
relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to
the intended locations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeChange&gt; ReplaceCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, int instructionCount, Assembler codeAssembler, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionPointerPath</code> <a class="xref" href="MindControl.PointerPath.html">PointerPath</a></dt>
    <dd><p>Pointer path to the first byte of the first instruction to replace.</p>
</dd>
    <dt><code>instructionCount</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>Number of consecutive instructions to replace.</p>
</dd>
    <dt><code>codeAssembler</code> <span class="xref">Assembler</span></dt>
    <dd><p>Code assembler loaded with instructions to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Code.CodeChange.html">CodeChange</a>&gt;</dt>
    <dd><p>A result holding either a code change instance that allows you to revert the operation, or a failure.
If the operation performed a hook, the result will be a <a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a> that also contains the
reservation holding the injected code.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_System_Int32_System_Byte___MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt(MindControl.ProcessMemory,MindControl.PointerPath,System.Int32,System.Byte[],MindControl.Hooks.HookRegister[])">
  ReplaceCodeAt(ProcessMemory, PointerPath, int, byte[], params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L321"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Replaces the instruction or instructions at the address pointed by the given path with the provided code. If the
injected code does not fit in the space occupied by the original instructions, a hook will be performed so that
the injected code can still be executed instead of the original instructions.
This signature uses a byte array containing the code to inject. If your code contains instructions with relative
operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_MindControl_ProcessMemory_MindControl_PointerPath_System_Int32_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___">ReplaceCodeAt(ProcessMemory, PointerPath, int, Assembler, params HookRegister[])</a> signature.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeChange&gt; ReplaceCodeAt(this ProcessMemory processMemory, PointerPath targetInstructionPointerPath, int instructionCount, byte[] code, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionPointerPath</code> <a class="xref" href="MindControl.PointerPath.html">PointerPath</a></dt>
    <dd><p>Pointer path to the first byte of the first instruction to replace.</p>
</dd>
    <dt><code>instructionCount</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>Number of consecutive instructions to replace.</p>
</dd>
    <dt><code>code</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>Assembled code to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Code.CodeChange.html">CodeChange</a>&gt;</dt>
    <dd><p>A result holding either a code change instance that allows you to revert the operation, or a failure.
If the operation performed a hook, the result will be a <a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a> that also contains the
reservation holding the injected code.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_MindControl_ProcessMemory_System_UIntPtr_System_Int32_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt(MindControl.ProcessMemory,System.UIntPtr,System.Int32,Iced.Intel.Assembler,MindControl.Hooks.HookRegister[])">
  ReplaceCodeAt(ProcessMemory, nuint, int, Assembler, params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L448"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Replaces the instruction or instructions at the given address with the provided code. If the injected code does
not fit in the space occupied by the original instructions, a hook will be performed so that the injected code
can still be executed instead of the original instructions.
This signature uses an assembler, which is recommended, especially if your code contains instructions with
relative operands (like jumps or calls), because the assembler will adjust addresses to guarantee they point to
the intended locations.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeChange&gt; ReplaceCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, int instructionCount, Assembler codeAssembler, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uintptr">nuint</a></dt>
    <dd><p>Address of the first byte of the first instruction to replace.</p>
</dd>
    <dt><code>instructionCount</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>Number of consecutive instructions to replace.</p>
</dd>
    <dt><code>codeAssembler</code> <span class="xref">Assembler</span></dt>
    <dd><p>Code assembler loaded with instructions to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Code.CodeChange.html">CodeChange</a>&gt;</dt>
    <dd><p>A result holding either a code change instance that allows you to revert the operation, or a failure.
If the operation performed a hook, the result will be a <a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a> that also contains the
reservation holding the injected code.</p>
</dd>
  </dl>











  <a id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt*"></a>

  <h3 id="MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_MindControl_ProcessMemory_System_UIntPtr_System_Int32_System_Byte___MindControl_Hooks_HookRegister___" data-uid="MindControl.Hooks.ProcessMemoryHookExtensions.ReplaceCodeAt(MindControl.ProcessMemory,System.UIntPtr,System.Int32,System.Byte[],MindControl.Hooks.HookRegister[])">
  ReplaceCodeAt(ProcessMemory, nuint, int, byte[], params HookRegister[])
  <a class="header-action link-secondary" title="View source" href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L353"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Replaces the instruction or instructions at the given address with the provided code. If the injected code does
not fit in the space occupied by the original instructions, a hook will be performed so that the injected code
can still be executed instead of the original instructions.
This signature uses a byte array containing the code to inject. If your code contains instructions with relative
operands (like jumps or calls), they may not point to the intended address. In these cases, prefer the
<a class="xref" href="MindControl.Hooks.ProcessMemoryHookExtensions.html#MindControl_Hooks_ProcessMemoryHookExtensions_ReplaceCodeAt_MindControl_ProcessMemory_System_UIntPtr_System_Int32_Iced_Intel_Assembler_MindControl_Hooks_HookRegister___">ReplaceCodeAt(ProcessMemory, nuint, int, Assembler, params HookRegister[])</a> signature.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static Result&lt;CodeChange&gt; ReplaceCodeAt(this ProcessMemory processMemory, nuint targetInstructionAddress, int instructionCount, byte[] code, params HookRegister[] registersToPreserve)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>processMemory</code> <a class="xref" href="MindControl.ProcessMemory.html">ProcessMemory</a></dt>
    <dd><p>Process memory instance to use.</p>
</dd>
    <dt><code>targetInstructionAddress</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.uintptr">nuint</a></dt>
    <dd><p>Address of the first byte of the first instruction to replace.</p>
</dd>
    <dt><code>instructionCount</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.int32">int</a></dt>
    <dd><p>Number of consecutive instructions to replace.</p>
</dd>
    <dt><code>code</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.byte">byte</a>[]</dt>
    <dd><p>Assembled code to inject into the target process.</p>
</dd>
    <dt><code>registersToPreserve</code> <a class="xref" href="MindControl.Hooks.HookRegister.html">HookRegister</a>[]</dt>
    <dd><p>Optionally provided registers to be saved and restored around the injected
code. This allows the injected code to modify registers without affecting the original code, which could
otherwise lead to crashes or unexpected behavior.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="MindControl.Results.Result-1.html">Result</a>&lt;<a class="xref" href="MindControl.Code.CodeChange.html">CodeChange</a>&gt;</dt>
    <dd><p>A result holding either a code change instance that allows you to revert the operation, or a failure.
If the operation performed a hook, the result will be a <a class="xref" href="MindControl.Hooks.CodeHook.html">CodeHook</a> that also contains the
reservation holding the injected code.</p>
</dd>
  </dl>












</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Doublevil/mind-control/blob/v1.0.0/src/MindControl.Code/Hooks/ProcessMemory.Hooks.cs/#L10" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
